<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于人本身谈—说教、洗脑、教育]]></title>
    <url>%2F2024%2F11%2F26%2F20241126%2F</url>
    
      <content type="text"><![CDATA[明辨洗脑preface: 很多时候，在听到一些片面的观点，一些不符合自己认知的东西时，常常冒出一种洗脑的想法，常常因此而没有任何接收（不是接受）的想法。细细想来，想必还是没有明辨洗脑、说教、教育这大概三者间的区别，以至于什么都成了洗脑，在反感中踽踽而行。 &emsp; 于是乎，本文就来浅浅谈一谈罢，为何是说浅浅呢？自然是因为只要能解决上面的问题即可，太过深入并不是一朝一夕之事。 先让我们有个基本的预设： 洗脑：对于被洗脑者而言是不好的，带有强烈的目的性、利用性，会给发起洗脑者带来好处，有一种强制性。 说教：强硬味的、地位相对倾听者高的、本意可以认为是好的（或者带有引诱性的，但一般而言还是认为是好的，因为我们这里的说教一般是指长辈、老师导师等有一定关系的） 教育：举一反三的，包容开放，启发性的，可选择的（理想） 下面先附上gpt的回答： 1. 洗脑目的： 强制性地灌输某种特定观念，通常为了控制个人思想或行为。 目的是让受众无条件接受某种信念，排除其他可能性。 方法： 使用重复性高、逻辑性低的内容，强调情绪感染或恐惧。 控制信息流（只允许接触特定信息，屏蔽其他视角）。 削弱受众的独立思考能力，常伴随心理压迫或胁迫手段。 效果： 形成僵化的观念，受众通常缺乏自主性，难以质疑。 可能短期有效，但长期会因环境变化或外界刺激而崩塌。 场景举例： 某些极权体制或邪教组织通过单一渠道灌输意识形态。 2. 说教目的： 传递某种道德标准、价值观或行为规范，往往是为了“规训”或“纠正”他人。 希望让受众改变某种行为或态度，但未必系统化。 方法： 多以单向输出为主，强调权威立场（“我是对的，你应该听我的”）。 缺乏互动性，较少关注受众的心理接受程度。 内容往往偏向主观，缺乏对具体情境和多样性的考虑。 效果： 可能引起反感或抵触心理，效果因人而异。 如果方法恰当，可能对行为产生短期约束；否则效果有限。 场景举例： 家长用严厉语气对孩子说“不要这样做，否则你会后悔！” 3. 教育目的： 促进全面发展，包括知识的获取、价值观的建立，以及批判性思维能力的培养。 目标是让受众能够独立判断，并具备适应社会和解决问题的能力。 方法： 系统性、开放性地传授知识，强调逻辑性和多元化。 注重互动和讨论，鼓励质疑和创新。 以引导为主，而非强制灌输；重视因材施教。 效果： 提升个人的认知能力和社会适应力，具有长期影响。 受众能在复杂环境中独立做出判断，而非盲从。 场景举例： 教师通过互动和引导式问题帮助学生理解数学问题的解题思路。 总结比较 方面 洗脑 说教 教育 目的 控制思想，排斥多样性 改变行为，纠正观念 培养能力，促进发展 方法 强制灌输，重复信息 单向灌输，主观评价 引导互动，系统思考 效果 思想僵化，易受控 短期规训，易引反感 长期成长，独立思考 这三者之间的核心区别在于自由度和受众的主动性： 洗脑剥夺自由，受众被动； 说教强调权威，受众部分主动； 教育尊重自由，受众主动性最强。]]></content>
    
  </entry>
  <entry>
    <title><![CDATA[剖析生活中的纸]]></title>
    <url>%2F2024%2F11%2F24%2F20241124%2F</url>
    
      <content type="text"><![CDATA[简析——纸preface:花点时间彻底了解一下纸。 纸的分类普通打印纸经常打印东西的同学应该十分熟悉了，可惜在小地方，大部分人连这样的东西都要被收以巨额费用。其厚度较日常用的草稿纸较厚，大约是0.104mm（国际规定，实际不知道了）。按照大小，分A3（8k），A4（16k即16开），A5（32k），A6（64k）…… 就作这么多了解是了。 复写纸有蛮多类型的，我目前见过的就是工厂等里会用的蓝印纸。想必大家应该也见过：就说你手写了一份，下面那张纸就有蓝色的印痕（可能不准确，应该这方面的资料几乎没有正规来源，只有国内的laji百度，如果是找国外的，奈何现在英文基本不愿意学了。日后再补充） 卫生纸其实就是厕纸，专门用来如厕用的！虽然但是，很多人都分不清，用它来擦拭面部，鼻涕等等。据要求，还是不能用卫生纸，应该其对安全性的要求并不高（虽然便宜就是了）。卫生纸则一般不允许具有湿韧性，以防止在使用后纸张不易分解而堵塞卫生化粪池。就是说，卫生纸吸水性不强，吸水后就会破碎化了。——这种纸一般就是圆柱状，想必不用多讲。 面巾纸 如图，面巾纸一般具有湿韧强度（一种代表纸张在完全润湿状态下的韧性指标），这也不用多说了罢。 厨房用纸这种没用过。据介绍是吸油性比较好。 其他1、包装用纸 牛皮纸、板纸、防油、防潮纸、商标、标签纸、卡纸、其他包装用纸、瓦楞原纸、纸袋纸、杯纸 2、生活用纸 卫生纸、卫生巾、纸巾、湿巾、其他生活用纸 3、文化、印刷用纸 艺术纸、铜版纸、其他文化、印刷用纸、新闻纸、胶版纸、书刊纸、字典纸、水印纸 4、办公用纸 打印、复印纸、书写纸、其他办公用纸、复写纸、描图、绘图纸、收银纸、彩喷纸、传真纸 &ensp; 就说这么多罢，知道这么多对于我们平常人已经够了。 ——11.25]]></content>
    
      <categories>
        <category>Chase Cat</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投资理财]]></title>
    <url>%2F2024%2F11%2F24%2Fconlicai%2F</url>
    
      <content type="text"><![CDATA[从零开始的理财（长期更新preface:个人认为，投资理财是一件很重要的技能，即使没有多少存款，也应当学会这一基本的技能，否则到时候你连自己有多少可用的财产都分不清。经过搜查整理，有了下文，开学！ 理财方式银行存款银行存款，就是把钱存在银行，这是最为大众所知道的理财方式了。对于理财意识薄弱的人群来说，银行存款是一个比较好且安全的理财方式。不过，安全归安全，需要提醒的是，央行已经出了新规定，一旦银行破产，你存在银行的钱，最高只能赔付50万元。打个比方解释：你存在银行是25万元，你是赔25万元；如果你存的是51万元或者100万元，你都只能获赔50万元。 但是银行存款的收益率也很低，目前银行存款是按照央行基准利率来执行的。其中，活期存款年利率为0.35%，一年定期存款年利率为1.5%，而三年定期存款年利率也才只有2.75%。也就是说，如果今年把1000元存银行三年定期，三年后的利息仅为1000x2.75%x3&#x3D;82.5元。——作者注：这是2018年左的数据了，现在又减少了。活期0.15%，三年定期1.9% 国债国债，是国家发行的债券，简单来说就是把钱借给国家。一般来说，国债的投资期限有3年、5年、10年等。 国债低风险的同时收益也很低。我从财政部了解到最近两期的国债中，3年期国债票面年利率为4%，5年期国债票面年利率4.27%。——作者注：现在看了看，在2.4%左右。近几年从3%一直在下降。 但是购买国债之后，如果没有持有到规定时间而是提前兑取的话，利率会降低。另外，从投资期限来看，我们很清楚国债的流动性是不高的，买国债就相当于长期存款。 国债有好几种分类，对于普通人来说，常见的是凭证式国债和电子式国债。凭证式国债要到就近的银行储蓄网点购买，而电子式国债可以直接在电脑登陆银行官网购买，也可以使用手机银行APP进行购买。 不过，国债比较难抢。第一，国债不是随时都可以购买，财政部会有发行的日期规定，所以要在发行时间内才能购买。第二因为国债相对安全且收益比银行存款高，因此很受大爷大妈的欢迎，所以你想要购买国债还得和大爷大妈进行一番速度比拼。 银行理财产品待有缘补充， ——作者注：翻遍了手机银行，应该是手机银行中财富—理财，这一部分的内容，叫做工银理财·***，一般要存3，6个月等等。 基金一般是由基金公司，向普通大众募集资金，然后把那些募集到的资金拿去投资股票、债券等权益类或者固收类的理财产品。 从基金募集到的资金的投资去向，我们可以知道，由于投资的是固收类或者权益类的理财产品，还有的是两者都投资，因此你买基金很可能亏损，也可能赚钱。比如，如果是货币基金这类资产就很安全，因此你可以拿到一个比较固定的正收益。 但如果拿我们的钱去投资股票或者其他大宗商品，那就不好说了，毕竟那些都是随着市场行情波动而波动的，关键是看基金经理的操盘能力。 收益率就不好说了，毕竟基金类型很多种，有的是股票型基金，有的是债券型基金，有的是混合基金，不同投资方向，盈亏都不同。比如，你买的是货币基金，可能拿到年化收益4.5%，如果你买的是股票型基金，刚好碰上大牛市，或者基金经理判断准确，你的基金可能在短期之内的盈利达到50%或者更多。当然，就如同一枚硬币的两面，你买基金也可能亏得一塌糊涂。 从流动性得角度看的话，基金可以分为开放型基金和封闭型基金，顾名思义，就是看你的买的是什么类型的，如果是封闭型的，你只能到封闭周期到了之后才能赎回，如果是开放型的，你可以随时赎回。 你可以一次性买入，也可以分次买入，一般这种分次且定额定时的方式，叫定投。至于购买的渠道，现在很多了，很多互联网理财平台都可以买，非常便利，要么你直接去基金公司的官网、银行和天天基金网买也行。 互联网理财产品这里说的互联网理财产品是指各大互联网公司推出的类似余额宝的理财产品，例如微信零钱通、京东小金库和百度钱包的余额盈等。 安全性：互联网理财产品大部分对接的是货币基金，而货币基金投资的也是风险很低的国债以及央行票据等，所以这类互联网理财产品的风险也是很低的。 收益率：收益方面，互联网理财产品的收益大部分在4%上下浮动，跟银行的定期理财产品收益差不多。——作者注：现在感觉被打压了，甚至不如银行的天天盈了 流动性：你的闲钱存在这类互联网理财产品可以获得收益，在需要的时候可以提出到银行卡中，也可以直接用来支付，比如余额宝，微信零钱通可以线下支付。 购买方式：一般是下载对应的APP找到对应的入口就可以购买。比如在支付宝APP里可以购买余额宝，而微信零钱通则在微信里。 P2P待日后更了解理财后再补充。 总结（待继续更新&emsp; 只存在银行里面吃活期利息，这实在少的可怜。追求稳健的话可以存放在银行开发的天天盈利中，目前的年化利率为稳定的1.7%-1.8%左右，相比于微信零钱通的1.4%，支付宝的余额宝长期的1.45%还是比较赚的。这些从个人角度来看风险基本为零了，如果这都不放心的话，那还是老老实实的送给银行罢。当然，不缺钱也确实没必要在乎这点蝇头小利，说不定突如其来个银行倒闭（这些没有内部消息确实就寄了，求稳没问题）。目前本人就是停留在了这一步。 &emsp;更进一步就是理财当中的产品了。再之后就是基金，股票之类存在亏损的东西。这些等待慢慢的学习罢了。下一步本人会尝试理财，其年化大概在2%-3%左右？ 上文引用链接： 推荐6种适合普通人的理财方式（内含最全面的分析介绍） - 知乎 基金—收益伴随风险（待补充&emsp; 基金必须要有所了解，否则存的钱的收益永远就是在2%以下了（就现在而言）。 1、基金的基础知识基金就是我们这些投资者把手里的钱交给专业的基金公司打理，他们拿着我们的钱投资。投资获得的收益一起参与分红，亏损了大家共同承担 基金公司是在国家证监会的监管下设立的，基金公司聘请的有专业的基金团队管理资产。因此，相比股票，我们买基金就相当于请了专业人士帮我们打理 而且基金最大的优势就是投资门槛低，非常适合小白。基金的起购金额很低，几十块钱、几百块钱都可以买 2、基金的分类基金按照投资方式划分可以分为四种，货币型基金、债券型基金、混合型基金和股票型基金 ①货币型基金的特点是低风险、取用灵活，年化收益在1.2%-1.8%，主要是投资银行存款、短期保本型产品 ②债券型基金的特点是波动小、收益较为稳定，年化收益在5%-10%，主要投资债券，投资比例在80%以上 ③混合型基金的特点是灵活调整、能随机应变，年化收益在（-15%）-15%，主要投资债券和股票，比例都不超过80% ④股票型基金的特点是高风险和高收益，年化收益在（-30%）-30%，主要投资股票，投资比例在80%以上 总计基金上文参考链接： 理财小白如何高效理财？（含新手入门时机+风险规避+养鸡经验） 学习理财第3年，我整理了一些免费学习渠道（适合新人阅读）]]></content>
    
      <categories>
        <category>study in life</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的舀起蜂蜜]]></title>
    <url>%2F2024%2F11%2F23%2F20241123%2F</url>
    
      <content type="text"><![CDATA[品尝蜂蜜那些事preface:有幸听说过蜂蜜的小伙伴或许不知道，但有幸正打算尝试一杯蜂蜜兑水的（我们还是把它称为蜂蜜水罢，似乎也没查到官方的称谓）小伙伴一定知道，想要优雅的用勺子舀起蜂蜜并不是一件很容易的事。结果常常是要擦拭桌面或者舔舐杯子壁缘。于是乎，便有了本次的探讨。 &emsp;具体现象一般如下图 在舀起蜂蜜时，总是会出现黏连现象，蜂蜜久久的在勺子底部，拉成细细的丝缓慢滴落，就像藕断丝连一样，就就不能断绝。下面直接介绍方面。 等待其自然滴落：十分的漫长，扰乱心情（等不急la 舀前用热水浸泡几秒勺子（注意，要是铁勺），加热之后舀起，这时会发现蜂蜜会很快的滴落，没有长丝下落。原理暂不知，本人亲测有效。 如下图：一般我们是移动勺子，但这样总会有些许落在桌上，我们直接移动杯子就行了。 使用两个勺子，相信这就不用多讲啦 &ensp;&emsp; 下面来谈谈其他的。 关于勺子，有人称不能用金属制勺子，而要用木制或者蜂蜜棒舀蜂蜜。这点经过查阅，认为：无所谓，金属勺子亦可以使用，嫌麻烦直接用就完事。毕竟勺子太多看着也烦。 关于水温：确实不建议用开水（7、80℃上），原因为破坏维生素和一些抗氧化物质。但更为致命的是，用开水喝太烫了，而且不甜，有损口感。 总而言之，没有必要担心什么营养流失什么的，开心就好。你每周多喝几次蜂蜜不就全补回来了？哪在乎这点流失？（况且还要算上转化效率） 关于如何优雅的舀起蜂蜜就说这么多了。 plus：蜂蜜兑热牛奶也很好喝（甜甜 ——11.23]]></content>
    
      <categories>
        <category>Chase Cat</category>
      </categories>
      <tags>
        <tag>探讨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当今的优秀——跨越阶级的代名]]></title>
    <url>%2F2024%2F11%2F14%2F20241114%2F</url>
    
      <content type="text"><![CDATA[偷偷地优秀，掩饰着阶级的对立preface: 优秀是什么？仿佛只存在于年轻的一代。在当下似乎优秀不再是自身纯粹所追求的，而是外界所胁迫、诱导的。于是，本是高尚的优秀变得也要偷偷摸摸起来，为什么？因为怕别人也优秀。 &emsp; 在开始之前，让我们确定一些词语在本文章中的定义。 优秀：大多数人（或者说主流、面试官、Somebody）所认同、认为的。在大学这个环境下，我们可以认为，分数、奖项、职务、社团、经历……这些是定义优秀与否的。 对立：这里的对立，是指一些人心中所认为的，即他们的行为已经显露出，优秀与否会产生一种隔阂、对立。这种现象是随他们个人的想法而出现的。 阶级：这里的阶级仅仅是代表一种不平等、地位的不等。 &emsp; 那么下面便展开正文。为了能够简化讨论的范围，所以关于标题——偷偷地优秀，掩饰着阶级的对立，本文仅仅从高中大学的角度出发。 &emsp; 吃的苦中苦，方为人上人。不知何时，这句话逐渐的入侵了高中时期的我们。于是乎，所谓天道酬勤、努力就会有回报、功夫不负有心人……当周围的一切都告诉你要追求优秀的时候，你是否问过为什么？你做出要追求优秀决定的那一刻，究竟是你自身的渴望，还是外界的唆使、诱惑和逼迫？ &emsp; 在高中，我们每个人都在追求优秀，都坐在同一个教室里，明目张胆的进行着优秀化，当然一天之中还有一些生存所需的时间，但每个人的优秀化的可利用时间总体是大差不差的。这种情况下，所谓的偷偷优秀还是很少见的，或者说总体是微不足道的，唯一有的差距也就只剩下了短暂的假日。所以，在一个内卷已经成准则的环境下，偷偷优秀，也只剩下了中午、晚上休息时间自己学习了，而这并不能体现偷偷的用意了。 &emsp; 而进入了大学，有了一定的选择权、自主权，摆烂、躺平的人也出现了。你有没有想过，为什么高中那么优秀的人，到了大学，却变得如此起来，变得不优秀，以至于挂科呢？我想，会不会是，这种优秀本就不是合理的，这种优秀本就不是他们想选择的，这种优秀本就不是优秀。当然，也不乏很多人延续了高中的优良传统或者幡然醒悟、奋发图强，不断追求的优秀——我太想进步了！ &emsp; 于是乎，在大学便很容易看到这样一种现象——这也十分的司空见惯，习以为常，见怪不怪了。这就是一些偷偷优秀的人。那这些人一般有什么特征呢？想必不用多说，懂得都懂，或许自己也是其中一员罢哈哈哈。就比如，一个寝室中，三个人都很摆，其中有一个人是那种假装摆，但实则偷偷优秀。于是总是漂浮着一种虚伪、尴尬的氛围。有时有不知气氛的室友问：你出去干嘛，又去约会？等等等等，诸如此类，也总是被带过、或则糊弄过去。在寝室看似一直在玩乐，实则总是在偷偷优秀。这种室友、人，相信也随地可见。也确实引人深思：什么时候，优秀也要偷偷的了？细细联想到阶级的对立，才发现原来这也太合理了。 &emsp; 我们在大学的偷偷优秀，是因为这种优秀代表着日后的阶级的跨越。而这种阶级的不同，势必会带来无法逾越的隔阂。毕竟，原来还是同一层阶级，然后突然摇身一变成为了人上人，联系日渐式微也很正常。而且，优秀的名额是有限的，偷偷的优秀，一方面有因为注定的阶级对立，还有对其名额的考量。 &emsp; 好了，就说这么多罢。虽然不完整，但实在是没有任何的灵感和动力了。 ——2024.11.07]]></content>
    
      <categories>
        <category>Life Diary</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔是怎样炼成的]]></title>
    <url>%2F2024%2F11%2F10%2F20241110%2F</url>
    
      <content type="text"><![CDATA[简析:笔preface: 笔，从小到大一直在用，却鲜有人能够分清、了解一点东西。 总体笔、笔芯等的分类 毛 笔 当今用毛笔的人已经很少见了，这里也不做过多的简析。 铅 笔 小学里面一般都是用这种木制的铅笔，有一定的安全因素考虑。之后都是使用自动铅笔了（除制图等） 自动铅笔分粗细，一般分0.5mm，0.7mm，这也就决定了笔迹的粗细。 按笔芯分类一般有HB，2B。 H：Hardness（硬度），B：Blackness（黑度）。石墨含量越高，铅笔芯越软，颜色越深；粘土含量越高，铅笔芯越硬，颜色越浅。按照国家标准GB&#x2F;T 26704，铅笔笔芯一共有17种，分别是：6B、5B、4B、3B、2B、B、HB、F、H、2H、3H、4H、5H、6H、7H、8H、9H。 所以显而易见，2B相较HB，更软（也就是更容易断，不耐磨），颜色深。填涂答题卡用2B而不用HB，就是因为2B的黑色深度更高（具体可自行搜索。 钢 笔 目前也鲜少见过有人使用。也不做过多分析，感兴趣可自行搜索。 圆 珠 笔 市场主流的一类笔。按油墨的性质，可以分为以下几类： 油性圆珠笔： 使用油性墨水，这种墨水主要由油性溶剂（如石蜡油、环己烷等）和颜料组成。油性圆珠笔的墨水流动性较好，书写顺滑，但墨水干燥速度相对较慢，且不易擦除。 水性圆珠笔（也称为宝珠笔或走珠笔）： 使用水性墨水，这种墨水主要由水和颜料组成，可能含有少量的溶剂。水性圆珠笔的墨水流动性好，颜色较淡，书写感觉清爽，干燥速度较快，且墨水容易擦除。 中性圆珠笔（中性笔）： 使用中性墨水，这种墨水的粘度介于油性和水性墨水之间。中性笔墨水的流动性和颜色饱和度都比较好，书写顺滑，干燥速度适中，且墨水不易渗透纸张。 勾 线 笔（记号笔） 可以书写在很多材质上，比如金属、光滑的木材表面、玻璃等等。 蜡 笔 荧 光 笔 透明的，一般用来标记，相当于给文字加底色 水 彩 笔 白 板 笔 一些学校里面可能还存在白板，用在这上面。容易被擦除。 签 字 笔 可以认为就是圆珠笔。 翻页笔 用于方便展示ppt 粉笔 银行柜台签字笔 根本上可以认为是圆珠笔，只不过绑了线，防止你拿走。 笔写字的原理这里介绍两种常见的，圆珠笔和钢笔，其他的无非就是摩擦力（粉笔、蜡笔）等等，或者类似于染色（水彩笔）比较容易理解 &emsp; 钢笔的工作原理主要依靠两个物理现象：重力和毛细作用。重力使墨水从储墨槽流向笔舌和笔尖，而毛细作用使墨水在笔尖中形成一个连续而稳定的液柱1。钢笔中间的缝实现了重力与墨水表面张力的平衡，使墨水可控地流出。当用力写字时，缝会张开，表面张力变小，墨水流出，写的字越粗。 &emsp; 圆珠笔书写工作原理：主要是利用球珠在书写时与纸面直接接触产生摩擦力，使球珠在球座内滚动，利用重力带出笔芯内的油墨或墨水，使圆珠笔油墨或墨水下渗到笔头，通过笔头球珠滚动形成图形文字。 后续油墨或墨水在大气压的作用下，不停地补充过来，以达到书写的目的。 早期的大多数球珠笔芯在靠近尾部的地方，都会钻一个小孔以保证空气流通。 圆珠笔球珠直径的大小，决定了字迹线条的粗细。 那种形状利于笔墨流动？突然发现买的直液式走珠笔笔芯，其为正立圆台式结构（顶部窄、底部宽），于是突然想，哪种结构利于水性油墨的流动呢？有圆柱形，倒立圆台形，正立圆台形。 于是这里便认为是正立圆台性更利于油墨流出了。因为大雾实在没学，所以也就直接问了gpt了。 从流体力学的角度，正立圆台形（顶部窄、底部宽）能够通过以下几方面促进水性油墨的流动： 重力驱动下的压力梯度形成漏斗式流动路径，减少流动障碍。 底部大半径设计提高了流动稳定性，使流速平稳。 面积逐渐增大的结构降低了粘性阻力，确保油墨供给流畅。 笔芯探究笔芯，由一种塑料（应该）和里面的墨水组成，外面加上一个金属头和滚珠 墨水组成（以中性笔的墨水为例）这里只介绍笔芯最上面附带的白色、黄色的透明液体。 随动密封剂（ink follower）：墨水的塞子。随动密封剂可以阻止墨水向后流动，还有一定防冲击作用，它可以让中性笔无论立着放、躺着放还是掉在地上时都不会漏墨。同时，它还能防止墨水中的水分蒸发它非常粘稠，但又可以在墨水使用减少时跟随墨水向前流动——这也就是“随动”的意思。这样可以避免密封的部分形成负压，影响正常使用。 参考：墨水跟随器及其在水基圆珠笔中的应用 中性笔各种头区别这些都是常见的笔头类型，每种笔头都有各自的特点和适用场景。以下是它们的简单介绍及优缺点： 子弹头 特点：笔尖圆润，通常用于签字笔或圆珠笔。 优点：出墨均匀，书写流畅，适合书写大字或快速书写，因笔头圆滑不易划伤纸张。 缺点：对于细节要求较高的绘画或写小字时，精准度可能不足。 葫芦头 特点：笔尖呈小葫芦形，类似子弹头但笔尖略微细化。 优点：可以兼顾子弹头的顺滑性和一定的细腻度，适合细致书写，特别是硬笔书法中常用。 缺点：相对子弹头易磨损，且可能不适合书写特别细小的字。 CS尖（Capillary Stylus） 特点：主要用于绘图和高精度书写，墨水通过毛细管作用流出。 优点：出墨稳定，适合精细绘图、标注和较小字体的书写。 缺点：结构相对复杂，价格较高，出墨速度较慢，不适合快速书写。 全针管 特点：笔尖类似于细针，适合精细描绘。 优点：精准度高，适合细致的线条绘画或小字体书写，可以控制线条粗细。 缺点：尖细的笔头容易损坏或断裂，长时间书写时可能感到疲劳，尤其在粗糙的纸面上使用时，笔头更易损伤。 半针管 特点：介于全针管与子弹头之间，笔头较短而粗壮，带有一点针状设计。 优点：比全针管更耐用，但依然能实现一定的细腻度，适合书写和标记。 缺点：细节精度稍逊全针管，灵活性不如子弹头。 总结： 书写：子弹头和葫芦头适合日常书写和快速书写。 精细描绘或绘图：全针管和CS尖更适合精细的绘画和标注。 兼顾耐用和精细：半针管适合希望兼具耐用性和一定精细度的使用者。 根据具体的使用需求选择合适的笔头类型，可以提升书写或绘画体验。 &emsp; 这里因为实在难以找到权威的资料、测评，于是就问了下gpt，具体情况到底如何，可以自己感兴趣分别购置多种笔芯，分别测评。我个人一般不用子弹头，因为很多垃圾货，中性笔也几乎不用，好的笔芯太难找了，推荐使用直液式走珠笔，不会出现断墨等搞心态现象（高中几乎三年都饱受垃圾笔芯的气） 笔壳的组成由于合适的资料实在难以找到，不知道是不是因为国内网络环境的原因，搜来搜去，要么是知乎，要么是百度知道，贴吧什么的。根本找不到权威信息，只有下面这张来源不明的图。 &emsp; 关于笔，就说这么多罢，虽然并不是很深入权威，但还是可以吹嘘一下的。 ——11.10]]></content>
    
      <categories>
        <category>Chase Cat</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对深渊，莫堕深渊]]></title>
    <url>%2F2024%2F11%2F09%2F20241109%2F</url>
    
      <content type="text"><![CDATA[利益关系决定立场preface: 我们自诩、我们自夸、我们自大、我们自亡。当面对深渊的时候，如何能够不堕入深渊？第一步就是要知道有这种事情，而这，正是今天这篇artical要探讨的。 &emsp; 就让我们从下面这段评论，从一个小小的方面、特定的例子，来简单的思考，或许能够有所启发。 &emsp; 这种类似的例子有很多，比如有认为我们与日本是仇敌，而大搞对立的（反对和服、日式文化、二次元、动漫、上升到运动类、人身攻击、种族歧视等等等等）；有唯恐外国不乱的，认为外国越乱对我国自己的发展越有利…… &emsp; 仔细想想，都不过一个词；利益。自诩为大国、自诩为好人，结果反倒如同当初的雨果所言，成为了披着文明人的皮的——野蛮人。那既然如此，何必不大大方方承认呢？何必给自己贴个可鄙的金呢？仿佛认为自己真的与众不同，有所改变似的。 &emsp; 回到主题，让我们细细分析。该commenter认为，因为trump上台对中国而言不是好事，所以我们不该夸他，也就是说我们应该把其作为敌对关系来看待，或者说，我们希望，要一个无能的人上台，搞的America越乱越好（这样我们就能夸他了）。乍一看，似乎并没有任何问题，这难道不是很正常的事情吗？欸，当我们认为这是一件很正常的事情的时候，我们就已经堕入了深渊。我们认为这很正常，说明我们从心底认同了它，认同了其的合理性，也是认同了利益关系决定立场。那既然我们能够因为国家立场而反对外国，那么内部又怎能不是如此。于是乎，我们发现，一切合理了起来，因为利益不同，所以就视妨碍自身利益的别人为敌军，要消灭批斗，这件事也成为了人之常情，为自己某利益不择一切手段也成为了一种默契，问到就是：这是很正常的事情，这就是现实。于是，自诩文明的我们，自诩优越的我们，不过也如此罢了。必须要改变！认为很正常，只是受到外界影响，就像古人认为男尊女卑很合理一样。失去了改变的想法，是可怕的。 &emsp; 能有如此看法，有如此言论，说明其就是利益论者。中美两国对立，作为中国人，要时时刻刻祈祷美国有衰败、民不聊生、甚至是天天暴乱，反正我不是美国人，美国越乱，我中国人越开心，哈哈哈。这就是这类人的观点。当你的诉求，妨碍了这种人索求利益时，他便也如此对待你。难道这能说是正常的吗？难道这是应该被称颂高歌的吗？作为文明人，自然是荒诞的。我们既然声称人生而平等，声称为人民服务，声称爱国爱人民，那其他国家的人民就不是人民了？如果不是，那国家不就是一众利益小团体，所谓的爱国爱人民就是为了保障利益？ 两军对战，其中A方将领使用计谋战胜B方，A方的人民大肆宣扬歌颂：这就是智慧、计谋。B方人民大骂、唾骂：下三滥的计谋、阴险狡诈。这难道不很是讽刺吗？倘若A方将领投靠B方，战胜了A方，那结果就更加讽刺了。 利益关系决定立场 的 广泛存在不是没有原因的。无论有什么别的看法，首先应该认识到它的存在。总而言之，历史周期律的牢不可破，也不是毫无理由的 plus：今天浅浅捐了个10 r，也顺便记录一下。 ——11.9]]></content>
    
      <categories>
        <category>Life Diary</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[讨论应当如何？]]></title>
    <url>%2F2024%2F11%2F04%2F20241104%2F</url>
    
      <content type="text"><![CDATA[讨论不是辩论——讨论应该是怎样的？preface: 也曾参加过大大小小的讨论，发现总是散漫、略感失败的。要么便是一言不发、面面相觑着，要么便是反驳争论、面红耳赤着……那么，请问 讨论该如何？如何方能有一场受益颇多而非浪费生命，融洽和谐而非不合决裂似的的讨论？ &emsp; 先让我们确定讨论这一行为本身的真正目的（意义）所在。讨论——陈述、交流已经存在于脑海中的观点、见解、想法的一种方式途径，而非解决问题、找到或者发现新东西的途径。 这里注意到，讨论的过程中，出现的绝大多数（除非是受某种刺激而昙花一现的），都是现有的、已经存在的。我们讨论，并不是能够发现、提出新的东西的，讨论本身的短暂性、浅薄性、目的，决定了讨论的作用仅仅是为了交流，是为了告知你一件事、一种思路、一种观点，而非是为了能够希冀能真正解决什么。 &emsp; 关于这点，我们先思考一个问题：我们的观点、思想从何而来？我想，有两个大来源：外界、自我。外界的影响，比如别人（亲戚、认识的人等），书籍，一切来源于外界的观点、思想都是。细细思考，你会发现，有时你的一些观念，就是深深受到的别人的影响（当然这并不是不好的）。自我，主要来源是自我思考。比如，你某一天兴起，或者由于什么而有所感触，于是花了一段时间，自己静静细细的思考、分析，得到了某个结论或者看法，那么这些东西，来源就是自我。我们可以认为，前者是早就已经存在的，后者是新的、是创造出来的（虽然前者可能早已包含后者，但不可否认，后者得出的往往具有天然的优势）。在现实生活中，或者说在讨论中，我们会惊恐的发现，我们的大部分，绝绝大大多数都来源于外界，从小到大，几乎都是被牵引着，仿佛被遛着般。那么，外界，总是对的么？（从来如此，便对么） &emsp; 于是乎，我们便自然而然的发现，哦，原来讨论过程中，你我所发表的一些看法、观点，大都是已经客观存在了的，大都是一些已经被谈论过千百遍的了。我们所讲出来的，大都是一些根生蒂固、我们潜意思里 早就认为 或者说所存在的东西。 &emsp; 那么，便很容易理解，讨论不是辩论，讨论应当是要包容的。讨论是一种交流，你可以在此过程中接受到一些前所未闻的观点、对你而言新的东西。这些东西可能并不合你胃口，但显而易见的，你无需、也很大程度上不必为了说服的目的而驳斥。讨论的目的不是为了说服，而是为了自己能够听到一些新的东西，或者自己能够受到某种启迪。我们当然可以就别人的发言提出自己的疑问，目的是为了提醒别人其可能疏忽了某些地方，而这种疑问是不需要得到回答。这一切，都是因为，讨论仅仅是陈述个人已经存在的东西，它并不能够有意义的得出新东西，所以一些突发的回答，往往是胡言乱语的。 &emsp; 而现实是，讨论仿佛大小型吵架现场，亦或者是沉默的可怕。我们还是以前者为例（后者的出现往往涉及到人本身）。在这种情况下，往往出现的是争吵，混乱，为何？因为谁也说服不了谁，这很正常，每个人的经历不同，于是想法看法当然不同。其根本还是人固有的同化思想，总是想着让别人完全认同自己，遇到不同的，总想着反对。其实，没有必要。讨论，只要把自己的东西有条理的陈述出来就可以了。这样分享的讨论，才是应有的讨论。 &emsp; 下面，就如何开展一场好的讨论，随意谈谈。略分有四步，确定主题—提前准备—紧扣主题—记录思考。 确定主题：就是定下讨论的主题，同时注意要提前定义一些东西，限定讨论的范围。讨论往往是有限的，并不能够很好的适应大的东西（尤其是当很多小方面都没达成一定的共识的情况下，这时候往往是一片乱象）。 提前准备：依据字面意思，就是提前通知一下参加者，准备好材料，留有时间思考等等。 紧扣主题：讨论的过程中，很容易出现跑偏的现象，很多时候就莫名奇妙的脱离了主题，开始为了一些其他的东西而争辩。所以，清晰的定义好要讨论的主题就很重要了，这能够帮助我们理解：我们到底要讨论什么，于是也就更能够围绕着主题而讨论。 记录思考：记录讨论过程中发表出的东西，在讨论过后，要有思考的行动。正如前文所言，讨论是为了交流、接收到新东西，所以我们需要思考，思考讨论中的新的东西，而非讨论过后一场空，没有任何的收获启迪。那我想说，这场讨论（于你个人而言），要么毫无意义，要么就是一种宣扬大会。 &emsp; 总而言之，讨论不是辩论。我们应该抱有一种包容，交流的心态参与讨论，不要一听到不合意的东西就嗤之以鼻。 plus：关于好的讨论并没有举例，所以有点抽象，但相信随着经历讨论的次数变多，你会体会到这四步的必要性 &ensp;——05&#x2F;11&#x2F;2024]]></content>
    
      <categories>
        <category>Life Diary</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听歌中的“首因效应”]]></title>
    <url>%2F2024%2F10%2F28%2F20241028%2F</url>
    
      <content type="text"><![CDATA[浅谈”首因效应“preface: 一首歌曲，往往有原唱和翻唱之分。最近听歌的时候，突然发现原来并不是原唱的一首歌，忍着性子翻了翻评论区，于是便有了分析了解首因效应的动机。 &emsp; 先看普遍认可的一种定义——首因效应（Primacy Effect）指的是人们在接收信息时，最初获得的信息往往会对后续的认知和判断产生较大的影响，使得人们倾向于根据最早获得的信息来形成初步印象。”首因效应“又称“第一印象效应”。 &emsp; 那么先谈谈个人的通俗理解。首因效应（第一印象效应），是指人们对某个事物的第一判断，会极大的影响人们后续的判断标准。简单举例，一个罪大恶极的杀人犯，倘若你第一次看见他的时候，他给你留下了好印象（让你对他有好感之类，比如帮了一下你，或者什么别的），那么你在日后的接触中，就会不自觉的带上一个好人的滤镜，会不自觉的为其一些其他行为辩解、逃脱、不相信其是坏人。又如，假如你心里不太喜欢一些着装打扮的过于怪异的人（比如刺身染发吸烟什么的），那么你的第一印象便是不好的，于是你会无意识的对其和其所作所为有一种不好的滤镜，于是便可能难以相信其是好人，这和以貌取人有些许类似。先暂且把首因效应的好坏放一边，这种现象，几乎你第一次见到或者知道任何事物生物的时候，其均有所体现。 &emsp; 在听歌的过程中，总是有着原唱翻唱之争。原因在于总有一批人认为原唱或者翻唱唱的更好听，于是乎就总是免不了一番网路上的对战。而结果往往是支持原唱的居多，人们也更倾向于对不是原唱的所唱的歌报以些许恶意，仿佛一首歌属于第一个唱的歌手一样（更严谨的说是第一个广为人知的歌手）。究其原因，这不就是一种首因效应吗？作为原唱，自然而然是一首歌的第一个歌唱者，当这首歌风靡、火起来的时候，就会涌现出大大小小的翻唱（当然具体不了解，或许还有版权什么的）。这个时候，大部分的听众都已经听过了这首歌，喜欢的人自然也就对这首歌的歌手抱有好感，还会多次欣赏歌曲，循环个几十几百遍。这样，这首歌就定型了，人们就会认为这首歌就应该这样唱，就只能这样唱。当他们遇见一种另类的音色或者唱法时，就会拿其和原唱比较，由于自己显然是更偏袒于原来的品味的，所以自然而然会对翻唱有一种贬低。对于一开始就不喜欢原唱唱的歌的人，大概率也不会再关注翻唱了。举一个类似的例子，动画片的配音和角色的形体塑造。比如熊出没、加菲猫的幸福生活、GGbond、猫和老鼠等等，相信绝大多数人都十分的在意配音和角色的绘画吧。我们常常说找不到童年的感觉，其实就是那种配音和绘画。我们心里把我们小时候所知道的配音、风格，融入了角色本身，因此，当我们听到其他配音、看到其他外表时，就会产生不喜欢、违和感觉。这点我深有体会（我经常反复刷童年经典动画）。故而，首因效应的产生，我们对原唱固有的偏向，也就一目了然了。 &ensp; &emsp; 接下来我们来深入剖析一下，这种现象产生的一些可能的原因。当然，这些原因仅仅是就听歌这件事而言——也就是，为什么我们会不自觉的偏袒原唱？(为了更清楚方便的论述，假定我们第一次听到的歌就是原唱) &emsp; 一个比较有意思的原因，|认为是在于人们往往对于自己的选择有一种天生的袒护感。也就是说，我们会希望自己的选择总是符合自己预期的，该是正确的，所以当反对或者其他颠覆性因素出现时，我们会想着消灭、抹杀它。我听了一首原唱唱的歌，我认为他唱的好。当其他翻唱出现时，我不自觉的认为它的出现，破坏的我选择品味的正确性，于是乎，我开始攻击他，和其他相同想法的人一起，目的是得到一种认同感、自己选择正确的成就感，而不是一种就自己一个人喜欢原唱的挫败感。简言之，就是我们会有一种寻求普遍认同感的趋向，这促使着我们坚持我们最初的选择——原唱。 &emsp; 那么，意义是什么？ &ensp; 首因效应是一种客观存在的东西，是由当下环境、人本身决定的，我们无需对其抱有恶意和批判。认识到其存在后，有什么新认识，有什么作为，更值得关注。 &emsp; 一个词：包容性。对于一些不同的看法，包容性的看待。我们或多或少的都会受到首因效应的影响，不同的动画配音可能对应的是不同人的童年，有什么争论谁谁谁配的更好的必要呢，有什么争论谁谁谁唱的好听的必要呢？（但不可否认，当加入了滥竽充数、粗制滥造等因素之后，这些又变得十分冗杂困难了）总而言之，当我们不自觉想反驳，对喷时，不妨想想是不是存在的首因效应带来的偏差，或许也能增加一点点包容心。 &emsp; 其次就是更好的运用首因效应了。比如尽量克服其带来的一些偏见，让自己能够吸收不同的观点等等。或者其他什么 &emsp; 关于首因效应就谈这么多吧，相信我们也能够十分了解它。]]></content>
    
      <categories>
        <category>Life Diary</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2024%2F10%2F26%2Ftop%2F</url>
    
      <content type="text"><![CDATA[公告（更新于10.26.2024​ 一些前言 一些小问题： 关于界面加载慢，延迟高：背景图大，文章附图，最好耐心等待一会，或者退出浏览器重输网址。建议减少清理浏览器缓存的频率（因为缓存过后进入本站将更流畅 关于界面的透明，透明确实影响文章字的清晰度，但早已忘记了如何修改，所以就搁置。看不清可以用鼠标选中…… 关于域名。 目前是买了三年（2023），后面极大可能会更换域名，请注意到时候的文章（更换域名的时候也可能会重新搭建blog，文章到时候应该会全部搬迁，有可能会换用其他主题（比如butterfly等等 关于评论。目前需要magic方可注册账号评论，注册最左边——也就是第一个（liveRe）。极少情况下会出现广子，请勿点击和相信。 关于wx二维码，真实有效 关于部分文章需要密码解锁。法1：自己破解。法2：评论区留言。法3：邮件联系 关于音乐错乱。其为用网yy插件实现，有些vip歌曲实在没办法（有些歌莫名其妙就成了付费的了），而且会出现信息错乱等现象。 联系方式：请通过邮件发送信息，要求来信请详细说清楚，否则按诈骗分子处理，发送到：&#106;&#105;&#97;&#x71;&#105;&#x6a;&#105;&#110;&#103;&#108;&#105;&#x75;&#x40;&#111;&#117;&#x74;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#x63;&#x6f;&#x6d; 请低调浏览此站，禁止宣传。 其他：待补充……]]></content>
    
      <tags>
        <tag>preface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[picture]]></title>
    <url>%2F2024%2F10%2F25%2F20241025%2F</url>
    
      <content type="text"><![CDATA[以前的记录preface: 记录一下以前（有一些是小学画的，有些是高二画的）]]></content>
    
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[当下社会中的竞争与合作]]></title>
    <url>%2F2024%2F10%2F21%2F20241021%2F</url>
    
      <content type="text"><![CDATA[浅谈competition &amp; cooperationpreface: 总是听到下面的词语。团结，集体，合作……常常同听说：团结就是力量，你们是一个集体，合作共赢。然而在实际生活中，竞争方是唯一，我们可以发现，当下社会中是不存在纯粹的合作，合作表面之下，仍然逃脱不了竞争的本质。 &emsp; 在谈论之前，首先明确一下竞争和合作的含义。竞争，有几大要素：两个人及以上，资源有限，存在失败方和胜利方，会产生矛盾、考验人性。显而易见，当资源足够时（当然这里涉及到分配问题，我们姑且认为分配不均是因为资源不足而非其他因素所导致的），竞争是很难存在的，至少就我看来没有普遍的反例。就比如，假设考0分都能上清华北大，那又何来高考竞争一言？竞争的本质，在于争夺为数不多的资源，显然这些资源是不被平均分配的。合作，亦有几大要素：两个人及以上，共同的目标，同败同胜，分工，相互信任。合作很难见到，或许只有一些科学研究？或者我国提出的一带一路？可以认为是合作了。 &emsp; 这里必须指出，合作并不是相互利用，相互利用是一种只为了个人利益而选择的一种手段，会随着利益的权衡而随时变化，而合作是长期的持久的，是相契合的，牢固可靠的。简言之，合作不是以个人利益之上，而是有一种欣赏对方的意思。（你总不会喜欢和仇人、反感的人合作吧？，这种就只能称为利用了）。 &emsp; 还有很多言论，总是喜欢用“相辅相成”这个词语，把对立的东西统一起来，仿佛二者是一个东西、可以共存似的。就本质而言，合作与竞争从来不是相辅相成，否则也只是一种安慰般的说法罢了。 &ensp; &emsp; 不知道从什么时候开始，所谓的班级荣誉感，变得越来越不可显现。犹记得小学，仍是往昔最快乐的时光，虽然亦有矛盾冲突，但是团结的，是有集体荣誉感的。这或许与人的心性有关，毕竟见的少，看的少，知道的少，还未曾沾染或者说被教导 现实。初中、高中，班级存在的意义，仅仅是聚起一堆人，方便教学罢。高二、高三尤盛。连最基本的打扫卫生都成了罕见，更别说团结了。也是，毕竟不同人与人之间本来就没有任何关系的，这一点无需感概。而到了大学，更加体会到 什么叫 沧海之一粟，独来独往，哪来团结合作一言？毕业之后或许更甚。人只是为自己而活罢了。这是由人的本质决定的，否则人也就不会成为人了。 &emsp; 上面说了一大段，不过是回顾一下往生。我们必须清楚的认识到生物多样性，而且品种的占比最高的，往往是个体获利最大化的。 &emsp; 为何说，在实际生活中，竞争方是唯一呢？这一点我认为不必赘述。从大学里面中各种乱七八槽的竞赛比赛，到社团的面试，从社会中的求职，到公司内部的晋升……你会发现，竞争处处都是，根本无法避免，唯有逃避一时，然后饿死。为什么连小小社团都要面试？难道是我不行？为什么进一个学生组织，同面试的人要么经验丰富，要么精通ps，视频剪辑……?难道人生来就该学这么多吗？？很明显，当然不是。名额有限，僧多粥少，就要优胜劣汰。这是当下社会一个非常明显，传承悠久的传统（当然，这是明面上的）。但肯定会说，这就是公平，这不很合理吗？潜意识里，人其实就已经被分了个三六九等了。但不得不说，我们总是大谈古代，殊不知，原来我们也是古代。单单从一个普通的人，这个单独的个体来看，往后他的一生，都是在工作，老了便消磨时间，然后噶。那么试问，他的一生，哪里能看到合作、团体的影子呢？说到底，都是单打独斗，都是在同其他的个体抢夺已经剩下的资源罢了，而这不正是竞争么？说到底，一切表面的和谐，在涉及竞争的情况下，便会被不谋而合的撕破。 &emsp; 那又为何说，合作的表面之下，依然是竞争？因为，合作是为了竞争。在高中时期，班主任曾这样说，你们不是和同班同学竞争，你们要和全省的人竞争，所以你们这个班要团结起来，相互帮助。（虽然，班里该竞争的还是竞争，并未听从）我要说的是，这种合作，其实是一种转移了的竞争，是一种混淆视听的竞争。难道把肉眼可见的竞争（班内竞争），转移到虚无的竞争（外界的、你看不到的）里去，以此形成的合作，本质不还是竞争吗？这种合作，是一种短暂性的，一种以利益为基础的，一种变相的竞争。因为，合作应该是使人没有那种外来的压力感，催促感，而竞争，往往会有外来的无形的压力，让你不断的去做一些你本不会选择去做的事情。读初中的时候我就想过：总有人是要考倒数第一的，总有人是考不上学校的，那么我们天天鼓吹努力学习，有什么意义呢？假如每个人都发了疯似的，拼命学习，都坚信着天道酬勤，努力就会有回报，那请问学习究竟有什么用？现在看来，这就是竞争的一种本质——分配资源。而社会上大部分的合作，比如学校竞赛中的组队，其合作的目的还是为了争夺资源，为了更好的竞争。 &emsp; 为什么竞争成为了主流？竞争是不好的吗？从人类发展的角度来看，竞争很明显更容易受到青睐，为何？因为一般而言人们都趋近于安逸、安稳，在资源充足的情况下，人们更倾向于享乐，休息——而这正是目前绝大数人都想要的。然而，美好的生活必定是属于少部分人的，因为物质不会凭空出现，所以竞争出现了。竞争带来了压力，也就有了物竞天择，优胜劣汰。在竞争的驱动下，你尽可能可以做着自己不想做的事情，燃烧自己。俗话说的好，人是被逼出来的。想要做成一件大事，就必须有一种东西支撑着你坚持、奋斗。要么是内心的力量（诸如兴趣、信仰），要么是要么是外界的驱使（诸如利益、压迫）。显然，后者往往更加有效而且十分简单容易普及。而竞争就是属于这一种。就人类追求幸福生活的目标而言，竞争是不好的( is totally bad )。然而，我们称赞它的原因，就在于它能够带来效益，带来进步，其本身并不是能值得推崇的。当然，我们并不是为了美好的生活，美好的生活要实现是一件很简单的事情，然而想要实现，难如登天。人并不是生来就是所谓的好人。 &emsp; 其实，说了这么多，要说实际用处吧，只能说毫无用处，毕竟这也不能成为学校书本上的名人名言。明白这些胡言乱语，并不会让你提高现实的甲醛、分数，只能让你明白：竞争与合作本质是什么——这个毫无意义的问题。 &ensp; ——26&#x2F;10&#x2F;2024 凌晨]]></content>
    
      <categories>
        <category>Life Diary</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被奴役的人]]></title>
    <url>%2F2024%2F10%2F08%2F20241008%2F</url>
    
      <content type="text"><![CDATA[命运的奴隶preface: 总是被逼迫着，总是被压榨着，总是顺受着，总是服从着。 &emsp; 一直是奴隶，从未变过。不知道从什么时候开始，也许是早在出生之前，渐渐的，真话变少了，质疑变少了，反对变少了，取而代之是沉默，顺从，麻木。为什么？因为我们渐渐的成为了奴隶，失去了一切。 &ensp; 无力改变，也无心改变，唯有嗟叹。因为，人并不是本来就应该存在的。 &emsp; 不敢言，是因为有顾虑，有把柄，或者害怕。仿佛生来就是低人一等似的，仿佛一些虚无的东西真的存在似的。终究还是因为，是奴隶。于是便十分能理解，为什么总有人幻想着超级英雄，超越一切的存在。唯有如此，方才敢言，敢做。可惜的是，人不过蝼蚁一般，又有自私等是生存本能，既无力对抗哪怕数十人，也有一堆顾虑，于是乎即使心有所愤，也只能默默忍受了。国家也不过如此吧。 &emsp; 虽自诩为智慧生物，统治主宰太阳系。但为何，总感觉，倒不如不出生的好。&emsp; ——于08&#x2F;10&#x2F;2024]]></content>
    
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>离奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STUDY OF C]]></title>
    <url>%2F2024%2F10%2F03%2Fc%2F</url>
    
      <content type="text"><![CDATA[MY STUDY Cpreface: help myself learn C better. 调试程序入门&emsp; 程序示例 1234567891011121314#include &lt;stdio.h&gt;int main(void)&#123; int n, int n2, int n3; /*该程序有多处错误*/ n = 5; n2 = n * n; n3 = n2 * n2; printf(&quot;n = %d, n squared = %d, n cubed = %d\n&quot;, n, n2, n3); return 0;&#125; 注意到，int n, int n2, int n3是错误的，而且输出结果亦是错误的，cubed为三次方的意思。 Some tricks printf中想要打印” % “，利用%%。例如 1printf(&quot;it accounts for %d%%&quot;, a); printf长输出，如示例 123printf(&quot;i &quot; &quot;am a monkey&quot;)printf(&quot;i am &quot;&quot;monkey&quot;) 负数求模： 11 &#x2F; 5 &#x3D;&#x3D; 2，11 % 5 &#x3D;&#x3D; 1 11 &#x2F; -5 &#x3D;&#x3D;-2， 11 % -5 &#x3D;&#x3D; 1 -11 &#x2F; -5 &#x3D;&#x3D; 2， -11 % -5 &#x3D;&#x3D; -1 -11 &#x2F; 5 &#x3D;&#x3D; -2， -11 % 5 &#x3D;&#x3D; -1 ++在while中的妙用 12int shoe = 2;while(++shoe &lt; 18.5) //shoe先递增再比较。 ++优先级 ++优先级仅比 ( ) 低，且只有一个可修改的左值可以用++。(x*y)++是错误的。 scanf在while中的妙用 scanf的返回值是成功读取项的数量。故有 1234while (scanf(&quot;%f%d&quot;, &amp;x, &amp;exp)) == 2&#123;&#125; switch的多重标签（ 直接见例子 123456789101112switch(ch)&#123;// a 和 A直接成了两个条件 case &#x27;a&#x27;: case &#x27;A&#x27;: a_cat++; break; case &#x27;b&#x27;: b++; break; default: break; &#125; for中 i 在数组应用的声明 注意，此时i类型应该为 unsigned int。printf用%u。unsigned short 为 %hu。 short int 为 %h long 在x64上占8字节(windows特殊规定为4)。long long 在X64占8字节。%zu是用于sizeof的，例如：sizeof(int) 企业开发 在windows，VS架构下，使用 1234__int8 代替 char__int16 代替 short__int32 代替 int__int64 代替 long long C99跨平台开发 1234567891011121314151617引入stdint.h头文件如下：typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;分别用以上的东西代替char, short, int, long longint16_t max = 32767;uint_q6 max = 65535;使用uint32_t s = 4294967295U // 后面更大的 都要加后缀，U表明其无符号 int64_t a = 23434234LL // uint64_t b = 34343434ULL // UINT32_MAX代表数值max 开发一般不使用I-O函数。 1234567891011121314151617181920// 必要做如下替代：#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//注意，这里为了方便直接用了linux中的简写u8，u16等代替uint8_t, uint16_t等int main(void) &#123;//固定宽度整数类型（占用的字节是固定的，所以上限也是固定的）s8 my8 = INT8_MAX;s16 my16 = INT16MAX;u32 myu32 = UINT32MAX;u64 myu64 = UINT64MAX;printf(&quot;% &quot;PRId8&quot; \n&quot;, my8);printf(&quot;% &quot;PRId16&quot; \n&quot;, my16);printf(&quot;% &quot;PRIu32&quot; \n&quot;, myu32);printf(&quot;% &quot;PRIu64&quot; \n&quot;, myu64);return 0;&#125; 还有least与fast类型 12int_least8_t //占的字节最少为8位（无上限。够用就不会扩充——适用于需要保证最小容量的可移植代码。int_fast8_t //至少8位，保证最快的操作。够用，但是速度不行，就会扩充。 浮点数一般要用f后缀]]></content>
    
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新闻学的魅力]]></title>
    <url>%2F2024%2F08%2F28%2F20240828%2F</url>
    
      <content type="text"><![CDATA[浅谈语言魅力——以一则新闻为例preface: 语言，尤其是中文，是很有深意的。同样的一件事情，用一种语言，可以表达出完全不一样的意思。这就是新闻学啊。类似于各种潜规则，语言也有潜在的意思。就让我们以一则新闻为例子。 这里的第二大段：老人家属赶来后…… 我们可以分析，向家属解释相关情况，这里应该是怎样的。也不过就是说，我看到老人摔倒了，然后把他扶起来了。但是，这里却说，情绪激动的老人，推搡，掌锢，争执不下。那么我请问，老人家属赶来的时候，老人是什么状态？为何家属一来，老人就不醉了？还激动了起来?? 于是，可以猜想，1.老人本身清醒的，等家属来了可以趁此敲诈。2.老人不清醒，误以为是被撞的。但我认为不太可能，首先老人不可能倒在地上很久，应该是跌倒后，小孟就看到了。否则这社会也太颠了。其次老人也不太可能连自己撞没被撞都不知道吧？如果是喝醉，为何家属没来时不发作？家属一到了就清醒了？ 我们看这一段：老人家属则执意要求…… 难道说老人家属就不知道时小孟好意扶起来的吗？我想家属也大概是心知肚明的，要赔偿也是肯定的，毕竟没有实质性的证据。 这里的“会不会真的” “民警心里也犯了嘀咕”，就很好笑了。一个还在读书的青年，还能怀疑到了？这里很明显的就是 出事有责 的现象。出了事情，必须不能闹大，要有人背锅。倘若没有监控，我想说，即使所有人都知道人家是主动去扶老人的，但还是会被罚。 这里还用到了见义勇为这个词语，未免隐射了 当代，连扶老人也成了一件有风险的事情。唉！人与人之间的信任的脆弱，可见一斑了。 这里的老人家属意识到了自己的错误，连连道歉.. 更是可笑，大人也是经历过社会，有一定见识的人了，也懂人情世故。连连道歉难道是真心的吗？我想，大部分都是走个过场罢了。 最后这里说并不后悔，但我想说，即使小孟真的没有丝毫后悔，而且下次碰见也会毫不犹豫的去做，那别人呢？那些犹豫不决的人呢？包括我，我一定也会先思考，或许我也会视而不见，扪心自问。谁想碰到这种敲诈呢？谁有那么多时间被这种事浪费呢？也就当代学子罢了。 ——8.28.2024 附：碰见这种事，要先留下证据等，防人之心不可无，虽然我很无奈，但奈何对于大部分人来说，的确如此！]]></content>
    
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[订书机]]></title>
    <url>%2F2024%2F08%2F27%2F20240827%2F</url>
    
      <content type="text"><![CDATA[订书机——我不知道的那些事preface:在装订废稿纸的时候，一时兴起搜查了很早之前就有的疑惑，于是便知道了一些大多人可能并不知道的事。 &emsp;为了方便，请看图片 这个订书机右边那一片金属片是干什么的呢？我一直以为是放长方体盒子（订书钉），或者来压平纸张的。但实际并不好用，结果一查，原来是用来撬起钉子的。 总所周知，这个铁片是可以向上掰起，并且旋转180°的，小时候我也这样做过，但直到此时此刻，我才知道，这也是一种订书方式，如下图 可以看到，左边为不常用的，右边是我们一直以来的订书方式。两种不同在于钉腿的咬合方向，左边是向外，右边是向内。所以，可以知道，左边适用于临时装订，后面要分开的那种。就说这么多了 ——8.27 结语：原来一个小小的订书机竟然隐藏了如此多的功能！在日常生活中，我们往往习惯于按部就班地使用某些工具，却忽略了它们的多种用途。通过这次对订书机的探索，我们不仅发现了它的独特设计和功能，更提醒我们要以好奇心去发掘和了解那些我们习以为常的事物，或许会有更多意想不到的收获。—by gpt]]></content>
    
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语标题大小写原则]]></title>
    <url>%2F2024%2F08%2F13%2F20240812%2F</url>
    
      <content type="text"><![CDATA[【英语】标题首字母大小写规则preface: 转载自网上，遵循互联网传播原则（直接照搬的。个人建议直接看一遍记住，用到生活中就不会忘 在阅读英文资料时，最常接触的英语标题大写方式有两种，一种是全部字母大写，另一种是部分单词首字母大写。如： THE TRUE COST OF BEING LAST IN LINE ——《哈佛商业评论》The Case of the Offensive Band Name （the本不应该大写，这里大写是因为首字母） ——《读者文摘》 其中，前一种较少用，而后一种最为常用。为何？小站认为原因在于前一种多用于强调，而不太利于阅读。 对于后一种方式，一般知道最多的就是，标题中的实词首字母需要大写，而虚词则一律小写。其实，这只是最基本的要求。下面就带大家看看还有哪些具体的规则。 基本规则 ⭐规则1：永远大写标题的第一个和最后一个单词的首字母，无论这两个单词是什么词性。规则2：永远大写以下5类单词的首字母：名词、代词（We、I、He）、动词、形容词、副词。规则3：永远大写5个及以上字母的单词，无论这个单词是什么词性。介词举例：Among, Between, Within连词举例：Although, Because, Until 2 哪些单词不能大写首字母？字母少于5个的介词和连词。介词举例：at, down, for, from连词举例：and, as, but, for, if冠词：a, an, the 。to（即使是作为不定式出现）。 3 常用虚词分类汇总如果有些小伙伴仍然感觉拿捏不清，别担心，下面小站把常用虚词做个汇总，分成两列，请收藏本文，随时需要随时翻开查阅即可。 大写：About, Above, Across, After, Against, Along, Although, Among, Around, Because, Before, Behind, Below, Beneath, Beside, Between, During, Except, Inside, Outside, Since, Through, Toward, Under, Underneath, Unless, Until, Whenever, Where, Whereas, Wherever, While, Within, Without小写：a, an, and, as, as if, as long as, at, but, by, even if, for, from, if, if only, in, into, like, near, now that, nor, of, off, on, on top of, once, onto, or, out of, over, past, so, so that, than, that, the, till, to, up, upon, with, when, yet最后，一些细心的小伙伴可能会发现一些比较糟心的词组，比如“as Though”，就是一个要小写首字母、一个要大写首字母。 转载自：https://blog.csdn.net/weixin_42468475/article/details/134052240 参考：https://zhuanlan.zhihu.com/p/447542998]]></content>
    
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循迹的实现思路]]></title>
    <url>%2F2024%2F08%2F05%2F01%2F</url>
    
      <content type="text"><![CDATA[基于BC的循迹动画的一种实现思路preface: 总所周知，在BC中实现动画，一般只能实现一些比较简单的直线，或者特定的斜线运动，但是如果要实现完全不确定的斜线运动，或者更加复杂的运动，至少我完全没有思路。所以呢，在大概4月份，受到了小车循迹的启发，便写出了下面的代码，作为一种思路。你可以发现，我队友实现的无人机避障等功能就是依据下面的思路改进完善的。原理很简单，相信理解起来不难，但是想完善、优化并非一朝一夕之事。 代码如下，只是演示思路，所以并没有很完善 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//画无人机的函数，不用看，不用看，不用看，不用看，不用看，不用看。void drfdrone(int x, int y)//xy是左上角坐标&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); //circle(x + 12, y + 12, 4); fillellipse(x + 12, y + 12, 4, 4); rectangle(x + 8, y + 9, x + 15, y + 15);// floodfill(x + 12, y + 12, DARKGRAY); line(x + 5, y + 4, x + 9, y + 8); line(x + 3, y + 4, x + 9, y + 9); line(x + 3, y + 5, x + 8, y + 10); line(x + 9, y + 1, x + 1, y + 9); line(x + 8, y + 1, x + 0, y + 9); line(x + 7, y + 1, x + 0, y + 8); line(x + 15, y + 8, x + 19, y + 4); line(x + 15, y + 9, x + 20, y + 4); line(x + 15, y + 10, x + 20, y + 5); line(x + 15, y + 0, x + 24, y + 9); line(x + 16, y + 0, x + 24, y + 8); line(x + 14, y + 1, x + 23, y + 9); line(x + 16, y + 15, x + 21, y + 20); line(x + 15, y + 15, x + 20, y + 20); line(x + 14, y + 16, x + 20, y + 21); line(x + 24, y + 15, x + 15, y + 24); line(x + 24, y + 16, x + 16, y + 24); line(x + 24, y + 14, x + 14, y + 24); line(x + 9, y + 15, x + 3, y + 21); line(x + 8, y + 15, x + 3, y + 20); line(x + 9, y + 16, x + 4, y + 21); line(x + 0, y + 15, x + 9, y + 24); line(x + 0, y + 16, x + 8, y + 24); line(x + 0, y + 14, x + 10, y + 24);&#125;//简单的void move11(int* x, int* y, int* buffer1)&#123; //这里的xy 是无人机现在的坐标 int a[3][3];//储存无人机坐标3*3的正方形区域点的颜色,9个点 int i; int j; int temp1, temp2; int judge = 1; int dx, dy; //下面应该是核心功能的实现思路。。。。。。 while (1) &#123; for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 3; j++) &#123; temp1 = i - 1; temp2 = j - 1; a[i][j] = getpixel(*x + temp1, *y + temp2);//注意这里实现了对 无人机坐标 （正方形中心）边长为5的矩形区域点列 //的颜色get if (a[i][j] == BLUE) &#123; judge = 0; &#125; &#125; &#125; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 3; j++) &#123; if (a[i][j] == BLUE) &#123; temp1 = i - 1; temp2 = j - 1; dx = temp1; dy = temp2; putpixel(*x, * y, RED);//无人机运动过后,清除该点颜色。 //注意这里没考虑路线交叉的情况。。。。。。。 *x += dx; *y += dy; &#125; &#125; &#125; &#125;&#125;void dronemove1(void)//这里不是核心&#123; //-======================================================== void* buffer1 = malloc(imagesize(0, 0, 25, 25)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i; *x1 = 100;//注意这里的初始化 *y1 = 100; move11(x1, y1, buffer1); free(buffer1); free(x1); free(y1);&#125;//主函数void main(void)&#123; int gd = VGA;//graphdriver int gm = VGAHI;//graphmode initgraph(&amp;gd, &amp;gm, &quot;C: \\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 setbkcolor(WHITE);//background color setcolor(RED); setfillstyle(1, RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//右上角画 退出 setcolor(GREEN); line(80, 100, 520, 100);//画标题 rectangle(220, 120, 420, 200); rectangle(220, 240, 420, 320); rectangle(220, 360, 420, 440); //++++++++++++++ //这里应该是运动的路径，可以随意更改。这里的循迹是根据颜色来的，蓝色为路径，无人机行驶过后就会变色 setcolor(BLUE); line(100, 100, 200, 200); line(200, 200, 400, 300); while (1) &#123; dronemove1();//动画，加while应该是便于观察。 &#125; closegraph();&#125; 这里的演示没有考虑到路线交叉等复杂情况，具体怎么完善可以看看C课设拯救计划中我队友的代码（具体文件是哪个我也不知道，或者看演示也行）。这里的主要原理是先画出路径的线（假定为蓝色），然后编写一个函数判断无人机这个点 旁边的点的颜色，使得无人机向周围蓝色的点移动，然后把这个点换别的颜色。（我现在也看不懂我的代码写的啥。思路就是这样 bye~~~ ——8.05.2024]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品书记]]></title>
    <url>%2F2024%2F08%2F05%2Fconmyreading%2F</url>
    
      <content type="text"><![CDATA[My Diary of Reading Bookspreface: 浅记一下，浅评一下，不接受任何反驳 &nbsp; 我认为的文学&emsp; 广为流传的文学是很难得的，由此，我们不难猜测，能够广为流传的文学作品，一定是有所共性的，这也就意味着，能够流传的文学作品，也必然会缺失什么。像四大名著，小说形式、表达含蓄隐晦。这种方式很巧妙。因为不同的人，看同一个作品往往只根据自己的想法和理解来评价，于是乎，一个能够包容很多，有很多解读方式的作品，就能满足大部分人的认同感。倘若一部文学作品，是完全直勾勾的表达作者的观点，那么我想，如果没有时代、气运什么的外部推动的加成，是不可能流传起来的（当然，不排除被骂得风行一阵子）。一本书，往往作者写的时候是按照自己的一种想法来写的，解读出来，就有了千变万化的隐喻，给人一种很高大尚的感觉，高不可攀，说的天花乱坠。但实际往往并非如此。我只问一句，写这么多的隐喻讽刺有什么用呢？难道一切会改变哪怕一丢丢呢？ &emsp; 我想，文学应该是一种个人的东西，是自己的牢骚，是自己的表达。文学倘若要得到大多数人的认可，在当下这种难以言语的环境下，必须得失去一些东西才行。至于这些东西重不重要，那就不得而知了。就我回忆从小到现在的人生经历，我没有体会到任何所谓的文学滋养，我所学的东西都是古代的、近代的，现代的呢？显然没有。那么未来呢？想必还是代代相传。那现在的文学发展在一个完全的局外人看来是怎样的呢？毫无生气。日渐式微，没落。就我个人看来，礼乐、礼仪、文明，这些字词显然不适用于现代。就如同我们站在今天的视角来看古代觉得他们可怜，制度落后，仿佛我们有优越感一样，我一直认为，我们也不过是未来人眼中的可悲的古代人罢了（前提是还有未来。 &emsp;总而言之，也不知道言何了 李白能豪迈地说：安能摧眉折腰事权贵，使我不得开心颜！现代又有几人能如此，或者哪怕有一丝想法？义务教育在教导，但社会现实呢？这何尝又不是一种讽刺。这是最好的时代，这是最坏的时代。我想，省略了“看似”和“实则”这两个词罢… … ——8.13 如何看待现实中艺术创作者和其作品之间的关系&emsp; 答：分开来看。不要因作品而推崇作者，不要因作者而否定作品。 这里直接引用一些段落：（并不代表本人的观点，只是说有些地方颇有启示意义 我始终觉得，真正残酷的其实是观众。他们时常不同程度地被肉眼看到的表象或者自己一厢情愿认定的“真实”所迷惑。他们认为自己理解艺术家的艺术、充分了解对方的品格和行为方式，稍有差池就引发毫无根据的论战与不满。之所以说此类纷争与不满缺乏根据是在于一个很简单的理由：对于任何一个人的人格与人品，若非经过一定时间的亲身接触与观察，是无法得到相对客观结论的；至于观众所接触到的到底是什么呢？首先是作品，然而作品与人品、美学与道德是没有必然联系的；其次就是经由包括电视、广播、报纸、图书、网络等各种媒体所传播的、大量经过人为加工而成的间接信息。以艺术家的作品为基础，辅以各种未必完整客观的二手信息，并自行添加想象的泡沫而产生的结晶，就是观众心中所认定的那个“真实的艺术家”。就在这个摇摇欲坠缺乏客观基础的认识平台上，为彼此认识上的差异反复进行论争与辩驳，怎么看都是一件让人啼笑皆非的事。其实大可不必舍近求远，只要扪心自问：在日常生活中，你能够百分百保证自己真正了解谁？你是否能够理解和包容他们的过去和他们的缺陷？在思考了这个问题之后，再去重新审视对心中那位遥不可及的艺术家的固有评价，或许就可以心平气和地对自己的想法做出适当调整了吧。原文链接 这和作者的作品有什么关系。毕加索虽然渣，但是作品依然有艺术价值；郁达夫情感生活也风评不佳，也不耽误我们欣赏《沉沦》，在国内同性之爱还zz不正确呢，那我就不能看维特根斯坦和福柯了吗？以及zz正确这真的是个褒义词吗链接 （附：正止 Maybe it comes down to this: For people able to separate the artist from the art, whatever the habits good or bad of its creators, as Gertrude Stein might have put it, “The art is the art is the art.” Can We Separate Art from the Artist? Should We? **I think it isn’t either&#x2F;or; its much more complicated. Sometimes it is good and necessary to separate. Art is created by imperfect beings. The fact that imperfect beings, even those who in some ways are horrible people, can at times create something beautiful should give us pause before we cancel or censor it. Should We Separate the Art from the Artist? - Open to Debate** &nbsp; The Moon and Sixpence 知书，知作者（中文为浏览器插件翻译，显然有些地方不准确） W. Somerset Maugham（毛姆）​ The Moon and Sixpence, novel by W. Somerset Maugham, published in 1919. It was loosely based on the life of French artist Paul Gauguin. ​ W. Somerset Maugham (born Jan. 25, 1874, Paris, France—died Dec. 16, 1965, Nice) was an English novelist, playwright, and short-story writer whose work is characterized by a clear unadorned style, cosmopolitan settings, and a shrewd understanding of human nature. ​ Maugham was orphaned at the age of 10; he was brought up by an uncle and educated at King’s School, Canterbury. After a year at Heidelberg, he entered St. Thomas’ medical school, London, and qualified as a doctor in 1897. He drew upon his experiences as an obstetrician in his first novel, Liza of Lambeth (1897), and its success, though small, encouraged him to abandon medicine. He traveled in Spain and Italy and in 1908 achieved a theatrical triumph—four plays running in London at once—that brought him financial security. During World War I he worked as a secret agent. After the war he resumed his interrupted travels and, in 1928, bought a villa on Cape Ferrat in the south of France, which became his permanent home. ​ His reputation as a novelist rests primarily on four books: Of Human Bondage (1915), a semi-autobiographical account of a young medical student’s painful progress toward maturity; The Moon and Sixpence (1919), an account of an unconventional artist, suggested by the life of Paul Gauguin; Cakes and Ale (1930), the story of a famous novelist, which is thought to contain caricatures of Thomas Hardy and Hugh Walpole; and The Razor’s Edge (1944), the story of a young American war veteran’s quest for a satisfying way of life. Maugham’s plays, mainly Edwardian social comedies, soon became dated, but his short stories have increased in popularity. Many portray the conflict of Europeans in alien surroundings that provoke strong emotions, and Maugham’s skill in handling plot, in the manner of Guy de Maupassant, is distinguished by economy and suspense. In The Summing Up (1938) and A Writer’s Notebook (1949) Maugham explains his philosophy of life as a resigned atheism and a certain skepticism about the extent of man’s innate goodness and intelligence; it is this that gives his work its astringent cynicism. ​ W·萨默塞特·毛姆（W. Somerset Maugham，1874 年 1 月 25 日生于法国巴黎，1965 年 12 月 16 日卒于尼斯）是一位英国小说家、剧作家和短篇小说家，其作品的特点是清晰朴素的风格、国际化的背景和对人性的敏锐理解。 ​ 毛姆在10岁时成为孤儿;他由叔叔抚养长大，并在坎特伯雷国王学校接受教育。在海德堡学习一年后，他进入伦敦圣托马斯医学院，并于 1897 年获得医生资格。他在第一部小说《兰贝斯的丽莎》（Liza of Lambeth，1897）中借鉴了他作为产科医生的经历，这部小说的成功虽然很小，但鼓励他放弃了医学。他在西班牙和意大利旅行，并于1908年取得了戏剧上的胜利——同时在伦敦上演了四部戏剧——为他带来了经济上的保障。在第一次世界大战期间，他是一名秘密特工。战后，他恢复了中断的旅行，并于 1928 年在法国南部的费拉角购买了一栋别墅，成为他的永久住所。 ​ 他作为小说家的声誉主要取决于四本书：《人类的束缚》（1915 年），这是一部半自传体作品，讲述了一位年轻的医学生走向成熟的痛苦过程;《月亮与六便士》（The Moon and Sixpence，1919年），以保罗·高更（Paul Gauguin）的生平为背景，描绘了一位非传统艺术家的作品;蛋糕和啤酒 （1930），一位著名小说家的故事，被认为包含托马斯·哈代和休·沃波尔的漫画;以及*《剃刀的边缘》（1944* 年），讲述了一位年轻的美国退伍军人寻求令人满意的生活方式的故事。毛姆的戏剧，主要是爱德华时代的社会喜剧，很快就过时了，但他的短篇小说越来越受欢迎。许多人描绘了欧洲人在陌生环境中的冲突，这些冲突激起了强烈的情感，而毛姆在处理情节方面的技巧，以居伊·德·莫泊桑的方式，以经济和悬念而著称。在《总结》（1938年）和《作家的笔记本》（1949年）中，毛姆将他的生活哲学解释为一种无神论和对人类天生善良和智慧程度的怀疑;正是这一点使他的作品具有严厉的愤世嫉俗。** 09-01一些句子： 牛奶是好东西，尤其是在它里面加上了几滴白兰地，就更好喝了，可母牛却巴不得让人快点把它挤掉。憋胀的乳头是很不舒服的。 苦难、不幸却往往使人变得心胸狭小，具有报复心理。 目前是看完了主人公思特里克兰德离开其家庭的部分，“我”接下来将会遇见主人公。由于时间有限，这里就先不对上面的句子和文章作分析，后面有时间再写吧。]]></content>
    
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>观书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自制作简易扫雷]]></title>
    <url>%2F2024%2F08%2F01%2F02%2F</url>
    
      <content type="text"><![CDATA[基于Borland C3.1开发的简单扫雷preface: 暑假让我弟学这个爆烂的C，让他自己学学C语言，编出个扫雷的基本功能就可以，没想到，编写了大概有一周的时间，才画好了界面？所以昨天一晚上，加上今天一上午，下午一点时间，便自己用爆烂的C （凭借着死去的C课设记忆）编出了一个堪称能玩的扫雷代码。当然，考虑到我弟的水平，只用了一个main.c文件，和祖传的鼠标库，就完成了这个简单的游戏。下面分享一下，当然功能还不够完善，而且思路不是特别好，（用的一维数组，大意了）。有很多可以简化改进之处，但是好歹能跑，也几乎没有任何的bug 游戏界面如下： 代码如下：（这里鼠标库就不放了，源码可以直接到C课设拯救计划里面找，还要下一个BC3.1，然后就能畅玩扫雷了！） main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;#include&quot;mouse.h&quot;void drawbackground(void);void bomb(int bombxy[10]);int checkbomb(int bombxy[10]);void inputbox(int(*temp)[4]);int checkifin(int now, int box[10]);void showbomb(int out[10], int box[81][4]);int showshuzi(int i, int out[10], int box[81][4]);void setzhanai(int box[81][4], int cankao[81]);void clearzero(int i, int out[10], int box[81][4]);//0void judgeifwin(int box[81][4]);void main(void)&#123; int *a ; int i,j; int out[10]; int gd=VGA;//graphdriver int gm=VGAHI;//graphmode int box[81][4];//储存81个格子的坐标，左上和右下。 initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 mouseinit(); *a = 1; while (1) &#123; int all; int saveclick[81] = &#123;-1&#125;; int cankao[81] = &#123; 0&#125;; if (*a != 1) &#123; break; &#125; if (*a == 1) &#123; drawbackground(); bomb(out); inputbox(box); setfillstyle(1, WHITE); bar(420, 350,601,409); *a = 2; &#125; MouseX = 640;//防止鼠标留痕，挡住扫雷界面；因为不加就会 MouseY = 0; while (1) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); setzhanai(box, cankao); judgeifwin(box); for (i = 0; i &lt; 81; i++) &#123; if (mouse_press(box[i][0], box[i][1], box[i][2], box[i][3]) == 1) &#123; if (checkifin(i,out) == 0)//点击的区域不是雷 &#123; clrmous(MouseX, MouseY); setfillstyle(1, LIGHTGRAY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); clearzero(i, out, box); &#125; else if (checkifin(i,out) == 1)//game over &#123; showbomb(out, box); outtextxy(420, 350, &quot;GAME OVER&quot;); while (1) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); if (mouse_press(418, 41, 600, 103) == 1) &#123; break;//退出游戏 &#125; if (mouse_press(422, 237, 630, 297) == 1) &#123; *a = 1; clrmous(MouseX, MouseY); break;//再来一局游戏 &#125; &#125; &#125; &#125; &#125; if (mouse_press(418, 41, 600, 103) == 1) &#123; break;//退出游戏 &#125; if (mouse_press(422, 237, 630, 297) == 1) &#123; *a=1; clrmous(MouseX, MouseY); break;//再来一局游戏 &#125; &#125; &#125; delay(100);//程序结束运行 closegraph();&#125;void judgeifwin(int box[81][4])&#123; int i; int count = 0; for (i = 0; i &lt; 81; i++) &#123; if (getpixel(box[i][0]+5, box[i][1]+5 ) == DARKGRAY) &#123; count++; &#125; &#125; if (count == 10) &#123; outtextxy(420, 350, &quot;YOU WIN!&quot;); &#125;&#125;void clearzero(int i, int out[10], int box[81][4])//0&#123; int judge; int j; int a[8]; a[0] = i - 10; a[1] = i - 9; a[2] = i - 8; a[3] = i - 1; a[4] = i + 1; a[5] = i + 8; a[6] = i + 9; a[7] = i + 10; judge = showshuzi(i, out, box); if (judge == 0) &#123; if (box[i][0] &gt; 40 &amp;&amp; box[i][1] &gt; 120 + 40 &amp;&amp; box[i][2] &lt; 360 - 40 &amp;&amp; box[i][3] &lt; 480 - 40)//周围有八个格子 &#123; for (j = 0; j &lt; 8; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if (i == 0) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[4], out, box); showshuzi(a[6], out, box); showshuzi(a[7], out, box); &#125; else if (i == 8) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[3], out, box); showshuzi(a[5], out, box); showshuzi(a[6], out, box); &#125; else if (i == 72) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[1], out, box); showshuzi(a[2], out, box); showshuzi(a[4], out, box); &#125; else if (i == 80) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[0], out, box); showshuzi(a[1], out, box); showshuzi(a[3], out, box); &#125; else if (i &gt; 0 &amp;&amp; i &lt; 9) &#123; for (j = 3; j &lt; 8; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if (i &gt; 72 &amp;&amp; i &lt; 81) &#123; for (j = 0; j &lt; 5; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if ((i / 9) &gt; 0 &amp;&amp; (i / 9) &lt; 8 &amp;&amp; ((i % 9) == 0)) &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 0 || j == 3 || j == 5) &#123; ; &#125; else &#123; showshuzi(a[j], out, box); &#125; &#125; &#125; else &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 2 || j == 4 || j == 7) &#123; ; &#125; else &#123; showshuzi(a[j], out, box); &#125; &#125; &#125; &#125;&#125;int showshuzi(int i,int out[10],int box[81][4])//显示第i-1个方块的数字&#123; int ji; int j; int a[8]; char buffer[10]; ji = 0; a[0] = i - 10; a[1] = i - 9; a[2] = i - 8; a[3] = i - 1; a[4] = i + 1; a[5] = i + 8; a[6] = i + 9; a[7] = i + 10; if (box[i][0] &gt; 40 &amp;&amp; box[i][1] &gt; 120 + 40 &amp;&amp; box[i][2] &lt; 360 - 40 &amp;&amp; box[i][3] &lt; 480 - 40)//周围有八个格子 &#123; for (j = 0; j &lt; 8; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if (i == 0) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[4], out) == 1) &#123; ji++; &#125; if (checkifin(a[6], out) == 1) &#123; ji++; &#125; if (checkifin(a[7], out) == 1) &#123; ji++; &#125; &#125; else if (i == 8) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[3], out) == 1) &#123; ji++; &#125; if (checkifin(a[5], out) == 1) &#123; ji++; &#125; if (checkifin(a[6], out) == 1) &#123; ji++; &#125; &#125; else if (i == 72) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[1], out) == 1) &#123; ji++; &#125; if (checkifin(a[2], out) == 1) &#123; ji++; &#125; if (checkifin(a[4], out) == 1) &#123; ji++; &#125; &#125; else if (i == 80) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[1], out) == 1) &#123; ji++; &#125; if (checkifin(a[0], out) == 1) &#123; ji++; &#125; if (checkifin(a[3], out) == 1) &#123; ji++; &#125; &#125; else if (i &gt; 0 &amp;&amp; i &lt; 9) &#123; for (j = 3; j &lt; 8; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if (i &gt; 72 &amp;&amp; i &lt; 81) &#123; for (j = 0; j &lt; 5; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if ((i/9)&gt;0&amp;&amp;(i/9)&lt;8&amp;&amp;((i%9)==0)) &#123; for (j = 0; j &lt; 8; j++) &#123; if(j==0||j==3||j==5) &#123; ; &#125; else if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 2 || j == 4 || j == 7) &#123; ; &#125; else if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; //ji代表周围有多少个雷； itoa(ji, buffer, 10); if (ji != 0) &#123; setfillstyle(1, LIGHTGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); setcolor(BLUE); outtextxy(box[i][0]+10, box[i][1]+10, buffer); return 1; &#125; else &#123; setfillstyle(1, LIGHTGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); &#125; return 0;&#125;int checkifin(int now, int box[10])&#123; int i; for (i = 0; i &lt; 10; i++) &#123; if (now == box[i]) &#123; return 1; &#125; &#125; return 0;&#125;void setzhanai(int box[81][4],int cankao[81])&#123; int i; for (i = 0; i &lt; 81; i++) &#123; if (mouse_press(box[i][0], box[i][1], box[i][2], box[i][3]) == 3)//右键点击 &#123; if (cankao[i] == 0&amp;&amp; (getpixel(box[i][0]+10, box[i][1]+10) == DARKGRAY))// &#123; setfillstyle(1, GREEN); clrmous(MouseX, MouseY); bar(box[i][0]+10, box[i][1]+10, box[i][2]-10, box[i][3]-10); cankao[i] = 1; delay(200); &#125; else if (cankao[i] == 1&amp;&amp;(getpixel(box[i][0]+10,box[i][1]+10) == DARKGRAY)|| (getpixel(box[i][0] + 10, box[i][1] + 10)==GREEN)) &#123; setfillstyle(1, DARKGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); cankao[i] = 0; delay(200); &#125; &#125; &#125;&#125;void showbomb(int out[10], int box[81][4])&#123; int i; for (i = 0; i &lt; 10; i++) &#123; setfillstyle(1, RED); clrmous(MouseX, MouseY); bar(box[out[i]][0], box[out[i]][1], box[out[i]][2], box[out[i]][3] ); &#125;&#125;void inputbox(int(*temp)[4])&#123; int i, j; for (j = 0; j &lt; 9;j++)//i确定列数，j确定行数。 &#123; for (i = 0; i &lt; 9; i++) &#123; temp[i + 9 * j][0] = 1 + 40 * i; temp[i + 9 * j][1] = 1 + 120 + 40 * j; temp[i + 9 * j][2] = 40 + 40 * i - 1; temp[i + 9 * j][3] = 40 + 120 + 40 * j - 1;; &#125; &#125;&#125;void bomb(int bombxy[10])//利用返回指针，或者直接传入数组更好；&#123; int i; //总共分成81份； srand(time(NULL)); for (i = 0; i &lt; 10; i++) &#123; bombxy[i] = rand() % 81 + 1;//生成1-81的随机数 &#125; checkbomb(bombxy); &#125;int checkbomb(int bombxy[10])&#123; int i, j; for (i = 0; i &lt; 10; i++) &#123; for (j = i+1; j &lt; 10; j++) &#123; if (bombxy[i] == bombxy[j]) &#123; bombxy[i] = rand() % 81 + 1; i = -1;//重新检查 break; &#125; &#125; &#125; return 0;&#125;void drawbackground(void)&#123; int i; setbkcolor(WHITE); setcolor(GREEN); settextstyle(1, HORIZ_DIR, 2);//HOR...表示横向显示，第二个1表是字体大小。1为小，0默认。2，3..大 outtextxy(432, 60, &quot;exit the game&quot;); outtextxy(437, 256, &quot;restart the game&quot;); rectangle(418, 41, 600, 103); rectangle(422, 237, 630, 297); //============== setfillstyle(1, DARKGRAY); bar(0, 120, 360, 480); setfillstyle(1, YELLOW); bar(0, 0, 360, 120); setcolor(GREEN); rectangle(25, 40, 100, 80); rectangle(150, 40, 220, 80); rectangle(345-75, 40, 345, 80); setcolor(RED); rectangle(0, 120, 360, 480); for (i = 0; i &lt; 10; i++)//画十次 &#123; line(0, 120 + 40 * i, 360, 120 + 40 * i); &#125; for (i = 0; i &lt; 10; i++)//画十次 &#123; line(40 * i, 120, 40 * i, 480); &#125;&#125; 其实代码量也不多，有蛮多有点重复，工作量也就大概400行右吧。个人认为编程这种东西，我们不是主攻的（计算机专业啥的），刚开始学学思路就差不多。谁还死记函数什么啊？我编的时候都经常问gpt，或者借鉴之前写的代码。~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 就这样吧，是时候和祖传的鼠标库说再见了。愿世上再无C语言 ​ ——8.1.2024]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C课设拯救计划]]></title>
    <url>%2F2024%2F03%2F14%2F00%2F</url>
    
      <content type="text"><![CDATA[C课设拯救计划 前言：为什么要专门耗费时间来写这么一个东西呢？如果你有幸考入了华中柯基大学，又在填志愿的时候阴差阳错的选择了人工智能或者自动化专业，那么你就马上会听闻只存在于传说中的C课设。不仅仅是用了一种已经消失数十年的编译器: 爆烂的C（Borland C3.1，又简称为BC）。不仅其自身使用起来十分的麻烦，令人恼火，而且你几乎找不到任何什么学习BC编程的途径。虽然有学长学姐代代相传的帮忙，但这种事是学院默许的，亦可以说是学院支持的。故，从中也难以学到什么。所以对于大部分而言，结果往往是到deadline的时候，抄写，篡改前人留下来的代码，或者求助选同样题目的同学…… 所以，特此写一份较为详细的拯救计划。 BC下载链接点击下载爆烂的C BC最基本的用法 首先，不会真的有人会用BC这种东西来编写C课设吧？就其作用而言，不建议给自己找痛苦。 先上BC的图片（建议在电脑上食用，手机可能排版会出问题） 建立工程：意思就是把你写的代码变成一个.exe文件。如何建立？点击Project 有个open，直接输入新建的pgi(？)的名字（就是把那个*.pgi改成 1.pgi等等），这样就可以add 你自己编写的.c文件了。全部添加进去后，点Run，success就行，最终编写完成，就点Compile （?）。 其他：其他的东西自己慢慢摸索，差不多就能搞懂了。BC我目前用过的东西有: Edit中的 复制粘贴，主要是修改错误时会用BC直接修改（一些简单的问题）。注意在BC中修改后一定要点File中的save（BC没编译成功不会自动保存）。还有一个就是Window中的Output，可以查看文本窗口的输出，但基本没用（基本都是图形化窗口，用不到） 关于环境配置，其实没什么，所谓环境配置，就是一个简单的设置Options中的Output，和什么什么的。这些东西自己看看就会慢慢理解的。而且，群里都有配置好了的BC，直接用就行。也可以找我要。至于什么纯净的BC，就是没有学长学姐的工程。但大部分你只要把他们写的东西删掉就行了（除非有人自己改BC）。 你用别的编译器写的汉字，在BC中是无法显示的，原因是汉字编码方式的不同，具体可参考https://www.bilibili.com/video/BV1BT421a7N6/?spm_id_from=333.999.0.0。 自此，我相信你已经学会了使用BC建立工程。虽然你可能还不会编写。 如果还是不会使用BC，可以去看看别人怎么用的。 头文件的编写(三月16日更新) 头文件编写还是有固定的套路的，一般你自己直接复制粘贴就行。 这里介绍通用的模板： 123456#ifndef _COMMON_H_ // 这里的意思是if not define #define _COMMON_H_ //则define; common.h,是你自己命名的头文件名字，注意文件后缀//这里就是函数声明，和一些struct的引用，或者define a 1;什么什么的void hanshu();#endif 那么这个的原理就是条件编译，其目的在于水代码 防止头文件重复包含（？。有兴趣自己检索就行。 当然一般而言我们还会编写一个总头文件，一般命名为common.h; 你可以发现它就是如同这样 1234567891011121314151617181920212223242526272829303132333435363738#ifndef _COMMON_H_#define _COMMON_H_/*----------------------------包含所有的头文件，以后引用头文件只需要 include &quot;common.h&quot;；更加方便，代码简洁----------------------------*/#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//上面是BC自带的头文件，下面为自己编写的//----必备#include&quot;mouse.h&quot;//鼠标库#include&quot;hz.h&quot;//汉字库//--界面#include &quot;welcome.h&quot;//开屏动画#include &quot;mainpage.h&quot;//主界面#include &quot;mainfunc.h&quot;//农田界面#include &quot;history.h&quot;//历史记录界面#include &quot;usehelp.h&quot;//系统说明界面//---func:功能文件#include &quot;move.h&quot;//配合鼠标使用的鼠标move函数#include &quot;showtime.h&quot;//显示时间函数#include &quot;shuju.h&quot;//数据库#endif 当然，这是我编写的尚未完成品。注意自己编写的 头文件最好用”” ，爆烂的C自带的用&lt;&gt;，具体原因有兴趣自己查找。 那么关于头文件的全部暂且就到这里了。当然你建立工程的时候如果把头文件不需要手动添加。 拜拜了~ 贴图的工厂化实现（已完善） 怎么贴图？很简单。爆烂的C可以用祖传的代码，批量化贴图。你根本不需要理解，你只需要CTRL C, CTRL V。n张图片便已经贴上去了。 废话不多说，直接上代码。这是一个使用例子。(? 123bmp_convert(&quot;1.bmp&quot;, &quot;1.dbm&quot;);open_display();show_dbm(100,100, &quot;1.dbm&quot;, 0); 其中，你只需要操作的部分如下： 将1.bmp改成你要贴的图片的名字。不要告诉我你不知道文件后缀是什么。 当然还有所有的1. 其中show_dbm(100，100，…..)，前两个是贴图的位置，左上角坐标。 注意，这种只能贴bmp，而且还要用到ps修改。具体有祖传文件教学。这里我就不提供下载方式了。因为我日后会以图文形式补充，想必大家都能在救助群里找到。 就是这么多了。当然，要#include .h文件。笑 注意，你的贴图文件放在source文件夹内，即和你的.c文件放一起。 为防止还没有人不会，上代码（？？？） 1234567891011121314151617181920212223？#include &lt;stdio.h&gt;#include &lt;graphic.h&gt;#include &lt;image.h&gt;void main()&#123;int gd=VGA;//graphdriverint gm=VGAHI;//graphmodeinitgraph(&amp;gd,&amp;gm,&quot;C: \\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 bmp_convert(&quot;1.bmp&quot;, &quot;1.dbm&quot;); open_display(); show_dbm(100,100, &quot;1.dbm&quot;, 0); bmp_convert(&quot;2.bmp&quot;, &quot;2.dbm&quot;); open_display(); show_dbm(300, 200, &quot;2.dbm&quot;, 0);getch();//鼠标按键后退出closegraph();delay(100)&#125; 虽然不知道有没有问题，但还是暂且认为该代码有问题吧（doge） 附件：贴图祖传代码下载（已经修改，完美适配VGA模式 即640X480下的贴图） 点击下载 1234567891011if(ImageW==0||ImageH==0||ImageW&gt;641||ImageH&gt;481)/////注意注意！！根据实际修改/&#123; printf(&quot;The image is too large!Please input image below 640*480.&quot;); fclose(fbmp); return 1;&#125;if((fdbm=fopen(dbm,&quot;wb&quot;))==NULL)&#123; printf(&quot;Creat \&quot;%s\&quot; error!&quot;,dbm); return 1;&#125; 上述的头文件和.c文件经过了修改，至于.c文件，我们无需看懂原理。上面是.c文件大约40-50行部分代码。这里的Imagew 和ImangHI 要根据实际值修改。否则就会出现 The image is too… 然后贴图失败。。 *这里的贴图的重要一点就是对 图片的处理， 首先要下个VS PS， 然后根据文件中的食用方法来便可。 当然其中有些东西不必在意。如：调用 show_dbm(int x,int y,char dbm,int nowpage)即可在在(x,y)输出图片(x 需为 8 的倍数)，char * dbm 处填入的 dbm 文件地址。 这里的X并不需要为8的倍数。当然，也许只是我们没有理解其原因。但是只要能贴上图就行。 贴图的工厂化实现就是这样了。请低调使用，勿宣传（.jpg） —4.21.2024 报告的借鉴以及验收过程 在4月的27日，也是极其幸运的过了C课设。原因主要是抽到了好的验收老师。喜提A-。也是上演了一出抽卡现场。验收其实报告几乎不看（所以用的全局变量也是根本没看，当然据说这个看老师，有老师似乎喜欢看？？），所以没必要过于精细。代码分配部分，要把.c谁写的都写明。 报告直接借鉴即可食用。 验收过程实际上也很简单。就是要把你的CODE文件夹，复制到机房电脑的C盘（不是桌面）上，然后找到C盘中的Borlandc&#x2F;bin&#x2F;bc.exe。打开那个BC，然后自己改下路径即可。实际上手后十分简单。路径就是文件路径。所以我们在编写的过程中，最好用相对路径。比如文件的打开啥的。 老师是听我们讲了我们的程序功能。因为设计了梯田，被认为是相对一个创新的点，所以老师就简单的要我们加个功能。就是让无人机高度在农药喷洒时也显示，也就是一个调用函数的问题。当然，还要调调参数，总之十分简单。但也有老师很考验心态和能力。只能说，验收就是看抽卡。文件操作必须要掌握。验收时许多老师都重视，甚至要你改登录注册的代码。（而许多人是直接照搬的…） 就说这么多吧，愿世上再无C课设 –5.5 报告下载 英文输入法 输入法是登陆注册界面必不可少的。那么这里直接提供代码，来源不明。具体如何使用请看编写的原作者（未知）的注释。 这里的输入法明显要和文件操作结合起来比较方便。或者数组之类。但还是用文件操作更好。 这里面呢，就两个函数，对应两种输入法。可视与不可视。调用即可。建议登录注册不必太过高级。基本功能实现即可，因为要么老师根本不看，要么老师要你加这里的功能。比如忘记密码、让输入的密码可视什么的。（而这些都容易实现（所以就有人故意不把程序搞完美，预判老师会要求加的功能… 源文件下载 那么就说这么多吧。虽然更新速度慢，但不是还早着吗？-5.19 编程的开始​ 水了这么久，终于来到了激动人心的编程环节。其实主要是因为不知道该水什么了）那么为了节省一些时间，所以编程开始的讲解主要就是按照 我们那一组编写的代码的顺序来，毕竟，与其自己盲目的学这学那，不如完整的看一遍往届的代码。当然我自己尝试过，不过由于看不懂，所以收获不多。但还是收获良多。（比如时间显示就是看往届代码，贴图实现一开始也是看着抄写的）当然由于种种原因，不开放源代码，毕竟是个人劳动成果，白嫖有害身心健康，可通过邮件询问获取） ——5.23 思路历程&emsp;为什么C课设选题时选到了这道题目？ 答：C课设选题，其实就是开一个大会，许多班的人坐在一个大教室。然后出题老师会分别讲题目的要求（当然，我是一点没听，大多数人也是），然后呢，不知道什么时候，班长就突然说来选题，其实就是在一张打印好的纸上，有题目的序号，填写你和你的队友的名字，学号。而且因为我们班是30个人，有15道题目，所以题目不能重复，就靠抢？（除非你们班班长很公平，想到了用抽签的方式决定选题的先后顺序。） 所以这里建议选题的时候，坐的离班长近一点。最好坐旁边。 我当时连队友都没找，听到说选题开始，才问谁还没组队。结果发现，所有人都早早组好了队伍（当然除了队友（他也是比较内向吧，与班里的人没交流。于是乎，一坨人为了选题乱挤。所以到我选题的时候，已经是最后了。幸而找到一道22级的题目，也就是这道题。于是乎，便莫名其妙的选好了题目。 &emsp;总结： 开那个选题大会时，坐班长旁边比较好。 选题靠抢的话一定不要顾及什么面子啥的，直接乱挤，先到先得。不要有所谓的高尚，因为别人可不会管你，当你选到了一个痛苦的题目而无从下手时。。。。 队友尽量提前找好，而且尽量找负责的吧，行动力强。拖到deadline赶C课设，或者只有你一个人急，抑或是你一个人做了一堆事。。没必要，本来就是团队合作。 这个选题序号代表了验收的顺序，所以如果选的靠前（1-5的样子）那么就是第一天晚上验收。太靠后（10-15）就是最后一天了。所以选中间比较好。我选的是8。。因为第一天必有zcj，开局必有下马威吗，所以挂的可能性蛮大的，到后面也能有经验，你能问老师的验收风格，比如是加啥啥功能。最后验收就有点痛苦了。毕竟早死早超生。 还有聪明的人直接随便搞，挂科。如果不想保研确实可以如此。C课设重修只要程序能运行就过，所以可以借鉴代码。当还是别吧，当作锻炼自己的机会。 多问问往届学长，如果是往届的题目。不是的话自求多福。 程序没必要太过注重细节。比如什么精美啥的。老师看重的思路（我的就是因为那个梯田贴图让老师赞赏了），拿我的作为例子，两种农田，小农田的地形，农作物种类。。。（都是学长建议的。连夜加的。但梯田，高度显示是自己想到的。但是预验收时，学长也说到了许多没考虑到的点，比如多架无人机，无人机电量，无人机扫描农田（就是说，不是哪里有病就喷农药到哪里），无人机喷农药到一半就返航…… 这些确实我基本没考虑，但万幸最后过了。现在看来还是验收老师好。 思路目前就这么多了，再见&#x2F; ——6.14.2024 后补经过我的询问，也是终于找到了课设选题的文件： 2023级C语言课程设计 课程设计共同要求： 1． 用C语言编程实现，编译环境采用BC3.1，掌握C语言编写较复杂程序的一些基本技巧； 2． 要求在图形化界面下操作，界面要友好，不提倡使用贴图，贴图软件实现的功能必须控制在总代码量的5%以内； 3． 注意程序的结构，必须采用工程化的思想来组织程序； 4． 要求画流程图（没有流程图的不给评分）； 5． 两人一组，每班最多只出现一个三人组，小组个人代码和实现功能分工合理，每人程序不得少于1000行（登录、注册、开机欢迎动画界面、程序结束动画代码不计入）； 6． 每组提供一份报告，报告内容应包含数据结构设计、程序流程图、程序功能介绍、源代码等，并注明每人的工作量； 7． 原则上，不得使用全局变量； 8． 注意程序的可读性和可维护性； 评分标准 软件系统需求分析、系统分析与设计报告 15% 编程工作量 10% 人机界面及接口 10% 软件功能、软件结构、编码规范 30% 排错与调试技巧 25% 团队协作 10% 技术难度附加分 （0-10分） 特别提醒：出现下列情况，不予通过。 （1）个人有效代码量不足1000行； （2）被2个老师认定代码抄袭的； （3）不按指定时间进行验收的 （4）所选题目核心功能不能稳定运行的； l 参考文献 王士元. C高级实用程序设计. 北京: 清华大学出版社. 1996 周纯杰，刘正林等. 标准C语言程序及应用. 武汉: 华中科技大学出版社. 2005 周纯杰，何顶新等. 程序设计教程—用C&#x2F;C++语言编程. 北京: 机械工业出版社, 2016 姚远. 高级C语言程序设计技巧与实例. 北京: 机械工业出版社, 1995 陈清华, 朱红. C语言课程设计. 南京: 东南大学出版社, 2003 潭浩强. C语言程序设计. 北京: 清华大学出版社, 2000 等等…… 指导教师：周纯杰，何顶新，左峥嵘，高常鑫，汪国有，彭刚，周凯波，陈忠 C语言课程设计可选题目 简历辅助设计系统 主要功能说明：实现一个简历辅助设计系统。支持模板制作与模板选择；支持内容选择（比如，学习经历、实践经历等）；支持导入文本后自动排版；支持文本修改和简历修改。 武汉欢乐谷旅游模拟系统 主要功能说明：为武汉欢乐谷设计并实现一个旅游模拟系统。支持地图查看和列表查看两种方式查看项目；支持在线门票相关业务、特殊项目在线预约、预约提醒、路线推荐等。 3.小区物业管理app模拟 主要功能说明：完成一款典型小区物业管理app的各项功能仿真模拟。比如，华润物业的朝昔app。 夺岛军演游戏 主要功能说明：模拟攻占岛屿军演作战系统，场景自主设定，兵力申请与调派，后勤物资补给等功能。 ​ 5.智能家居app模拟 主要功能说明：完成包括空调、空气净化器、扫地机器人、冰箱、监控设备等至少5种联网设备的管理功能，具备家用设备的接入、设备启动、状态检测与显示，设备记录数据的分析等功能。 火星家园建设规划系统 主要功能说明：模拟火星宜居家园部署规划、进行就地取材，建设人类家园生活设施，并提供演练展示。 林果自动采摘系统模拟 主要功能说明：根据果园面积进行采摘路径规划、模拟智能农机进行采摘作业、对采摘林果进行统计、并运输林果到集中站进行储存、盘点等功能。 农田无人机喷洒农药模拟系统 主要功能说明：利用无人机进行农作物生长监测，针对不同病害进行农药配制，对农药喷洒路径进行规划，模拟无人机喷洒过程等功能。 家庭看护机器人模拟仿真系统 主要功能说明：根据家庭成员的需求，陪伴机器人进行家庭服务，包括人机交互、端茶倒水、炒菜做饭、开窗关窗、浇花扫地、健康监测、突发状况报警。 10.酒店服务机器人模拟仿真系统 主要功能说明：某酒店多服务机器人的服务全过程模拟，包括根据酒店的订单分配以及机器人送餐、送水、送快递等服务的全过程。 人工智能学院大楼智慧建造系统 主要功能说明： 实现场地平整、地基建设、楼房建设、外墙装饰的施工过程管理功能，包括图形化模拟显示、施工建材调度、施工进度管控等模块。 家用婴童陪伴神器 主要功能说明：能识别婴童的状态（翻身、睡着、睡醒、口鼻被捂、呼吸频率、跟踪爬行过程）、电子围栏越过预警、典型过程抓拍形成成长相册。 学院５０年院庆组织过程模拟 主要功能说明： 模拟学院５０周年的庆典的全过程，包括院友的接待、组织、院庆当天活动的全过程。 学生选课模拟系统 主要功能说明： 参考HUB系统功能，以菜单方式模拟选课，包括后台课程管理和前端选课全过程，具有课程信息浏览、选课信息查询等功能。 东湖水质无人艇检测系统 主要功能说明： 模拟无人艇进行东湖水质检测的全过程，包括采集标本的无人艇航迹规划、水质态势分析及预测、治理措施及建议。 仿windows资源管理器系统 主要功能说明： 实现windows资源管理器的主要功能。 模拟BC的汉化文本编辑器 主要功能说明： 模拟BC的编辑器，界面需要汉字显示，至少包括BC编辑器的文件和编辑的相关功能。 无人驾驶汽车中控仪表系统模拟 主要功能说明： 具有无人驾驶汽车中控仪表系统主要功能的模拟。 19． 图书馆信息管理系统模拟 主要功能：参考学校图书馆，模拟图书馆的主要核心功能。 FIFA世界杯2022淘汰赛模拟系统 主要功能说明： 模拟FIFA世界杯2022淘汰赛全过程。包括各场比赛的集锦及技术统计、颁奖仪式、十佳进球模拟等功能。 源代码逐文件分析当然，我和我队友的代码基本完全独立，这样做十分有必要，尤其是你和队友不熟或者不能总是在同一个地方编写代码时。分工明确非常重要，否则到了ddl，你会十分的痛苦。而且，验收老师也基本有这个要求。一个人编写一个文件，最好互不干涉。 我编写的部分其实主要的框架都是由我一人编写，因为队友实在难以沟通，但这样的好处是我自己对于整个程序的流程十分清楚，免去了必须看懂队友代码的麻烦。所以变成了队友必须看我的代码才能编写。下面列举出文件分析。 commom.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef _COMMON_H_#define _COMMON_H_/*----------------------------包含所有的头文件，以后引用头文件只需要 include &quot;common.h&quot;；更加方便，代码简洁----------------------------*/#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//上面是BC自带的头文件，下面为自己编写的//这里的头文件直接复制粘贴即可，不需要管太多。 //----必备，这里主要是往届祖传文件#include&quot;mouse.h&quot;//鼠标库#include&quot;hz.h&quot;//汉字库#include &quot;IMAGE.h&quot;//贴图 //--界面#include &quot;welcome.h&quot;//开屏动画#include &quot;mainpage.h&quot;//主界面#include &quot;mainfunc.h&quot;//农田界面#include &quot;elsetian.h&quot;//另一个农田界面#include &quot;usehelp.h&quot;//系统说明界面#include &quot;growlook.h&quot;//生长检测动画#include &quot;outcome.h&quot;//大农田的结果查看界面//---func:功能文件#include &quot;move.h&quot;//配合鼠标使用的鼠标move函数#include &quot;showtime.h&quot;//显示时间函数#include &quot;shuju.h&quot;//数据库#include &quot;drzhiwu.h&quot;#include &quot;abdrone.h&quot;#include&quot;illness.h&quot;#include &quot;recover.h&quot; //这下面的都是队友编写的。#include &quot;pensa.h&quot;#include &quot;pensadh.h&quot;#include &quot;pssj.h&quot;#include &quot;zpjm.h&quot;#endif 为了方便，我的所有的解释会全放到代码里面。 设置common.h其实是我看了几个往届代码从而发现的一个共性。作用经过检验发现是：把所有编写的.h文件放到这个.h文件中，以后编写.c文件只要#include &quot;common.h&quot;就可以了。免去了各种麻烦。当然，如果你想水代码可以不这样做，但是实在毫无必要。 这里其实含金量不大。头文件编写上面已经说过，因此就不再赘述了。可以发现，我们的编写其实并不规范，只是按照个人习惯罢了。比如头文件的命名，都是为了自己理解方便。当然我又不是码农，而且英语也不太好，所以基本用中文，英文，啥的。 还有一个建议：写代码的时候多写写注释，方便自己和队友看懂。 welcome123456#ifndef _WELCOM_H_#define _WELCOM_H_int welc(int *a);//函数声明#endif 12345678910111213141516171819202122232425262728293031323334/*----------------------------------------欢迎界面----------------------------------------*/#include &quot;common.h&quot;int welc(int *a)//欢迎页 &#123; if (*a == 1) &#123; setbkcolor(WHITE);//background color setcolor(GREEN);//边界color setfillstyle(1, GREEN);// puthz(40, 150, &quot;农田无人机喷洒农药系统&quot;, 32, 50, GREEN); puthz(100, 250, &quot;你最好的选择！&quot;, 32, 50, GREEN); *a = 0; &#125; ////-------------加载动画 setfillstyle(1, RED); bar(110, 300, 530, 380); puthz(125, 322, &quot;加载中&quot;, 32, 50, YELLOW); setfillstyle(1, YELLOW); bar(265, 320, 305, 360); delay(400); bar(315, 320, 355, 360); delay(400); bar(365, 320, 405, 360); delay(400); bar(415, 320, 455, 360); delay(400); bar(465, 320, 505, 360); delay(400);//这里就是实现了一个动画的过程，原理十分简单。。。。。。 return 1;&#125; 这里为了方便，直接把.c和.h文件放到一个标题中了。毕竟在算代码量的时候也会剔除头文件，而且似乎那个课程报告里也不用？但我加了。可以看到，头文件编写就只要Ctrl c + Ctrl v 就可以了。 我应该先讲讲main.c文件的，但晚了。 *这里的*a有什么用呢？其实就是我在调用函数的时候是 welc(&amp;a)，而a在main.c那里赋值了初始值1。这样welc函数就运行了一次，之后在函数内部 a&#x3D;0，所以这样之后就不再调用。实现了调用一次的作用。这个还是要先看main.c了解总体框架。 main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;common.h&quot;//程序控制台：负责页面跳转。//实现各个函数的跳转，调用void main(void)&#123; int a1 = 1; int a2 = 1; int a3 = 1; int a4 = 1; int a5 = 1; int a6 = 1; int a7 = 1; int a8 = 1; int a9 = 1; int a10 = 1; int i, j; int page;//页面值 //初始化VGA模式 int gd=VGA;//graphdriver int gm=VGAHI;//graphmode initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 page=0;//初始化为0； mouseinit();//这里是祖传代码里面的，初始化鼠标，就是生成一个鼠标。 while (1) &#123; switch (page) &#123; case 0: page = moveint(welc, &amp;a1);//欢迎界面，return：welc中的1//可参考 move.c。 break; case 1: page = moveint(hello, &amp;a2);//主界面，return各种数字。 for (i = 0; i &lt; 5; i++) &#123; nongyao[i] = 0; &#125;//这里是队友后面加的，修bug。不用管 break; case 2: page = moveint1(mainfunc, &amp;a3,diannian_bitmap,dianbai_bitmap,dianmian_bitmap);//大农田界面。简单农田。 nongyao[5] = 0; //这里本质就是调用了mainfunc这个函数，后面这一坨是当时没想好，懒得改了。 break; case 3: page = moveint( elsetian, &amp;a4);//另一个奇怪的农田。进阶农田， nongyao[5] = 1;//队友加的，修bug，农药配置那的，这里是直接用了全局变量 break; case 4: page = moveint(usepage, &amp;a5);//系统说明界面，主要介绍了本系统的使用方法 break; case 5: page = moveint(elseoutcome, &amp;a6);//小农田的结果查看界面。。 break; case 6: page = moveint(outcome, &amp;a7);//查看大农田，说明农作物具体的生长状况，， break; case 7: page = moveint2(zhuzhan, &amp;a8, nongyao); break; case 8: page = moveint2(zpjiemian, &amp;a9, nongyao);//装配农药 break; case 9: page = moveint3(psdonghua, &amp;a10, nongyao, diannian_bitmap, dianbai_bitmap, dianmian_bitmap, rount, &amp;amtjudge);//喷洒动画 break; case -1://-1是点了 退出 框框；直接关闭BC break; default :break; &#125; if (page==-1) break; &#125; delay(1000);//程序结束运行 closegraph();&#125; 这里总体就是用了switch page模式。调用的函数代表不同的界面，函数通过改变返回值来实现界面的跳转。这里的moveint什么的是一个我编写的中转的函数，功能就是防止鼠标留痕啥的。具体后面会说到。 这里只需要学到这个界面跳转的基本框架即可。 这次更新就到这里吧。bye~ ——6.28 函数介绍（1）setbkcolor即：set background color,设置背景颜色十分通俗易懂。用法：就是setbkcolor( ); 括号里面加颜色的英文大写。但是颜色也是有种类的，并不是可以随心所欲的调色。颜色具体有如下： 12345678910111213141516#define BLACK//黑色 0#define BLUE//蓝色 0xAA0000#define GREEN //绿色 0x00AA00#define CYAN //青绿 0xAAAA00#define RED //红色 0x0000AA#define MAGENTA //紫红 0xAA00AA#define BROWN //棕色 0x0055AA#define LIGHTGRAY//浅灰 0xAAAAAA#define DARKGRAY //深灰 0x555555#define LIGHTBLUE //淡蓝 0xFF5555#define LIGHTGREEN //浅绿 0x55FF55#define LIGHTCYAN//浅青 0xFFFF55#define LIGHTRED //浅红 0x5555FF#define LIGHTMAGENTA//浅紫 0xFF55FF#define YELLOW //黄色 0x55FFFF#define WHITE //白色 0xFFFFFF setcolor也就是设置颜色，主要是边框的颜色，setcolor(GREEN); 之后你用的各种绘图函数所绘制出来的图形，点，线的边框颜色就是绿色。就像画图这个软件一样。bar, rectangle, line, putpixel. 其颜色与上面的表一致。 setfillstyle设置填充颜色。setfillstyle所设置的填充颜色只对于一些特定的函数有用。比如bar.bar与rectangle的区别是，前者含义是画实心矩形，后者不是。这也就意味这，setfillstyle之后，bar的边框颜色还是由setcolor决定的，但内部的颜色是setfillstyle的颜色。rectangle内部颜色还是背景色。 用法：setfillstyle( 1, GREEN);第二个参数是要填充的颜色，第一个参数代表了填充的方式。具体见下表 12345678910111213EMPTy_FILL 0 用背景色填充区域(空填)SOLID_FILL 1 用实填充色填充(实填)LINE_FILL 2 ----填充LTSLASH_FILL 3 ///填充SLASH_FILL 4 ///用粗线填充BKSLASH_FILL 5 用粗线填充LTBKSLASH_FILL 6 填充HATCH_FILL 7 网格线填充xHATCH_FILL 8 斜网格线填充INTEREAVE_FILL 9 间隔点填充WIDE_DOT_FILL 10 大间隔点填充CLOSE_DOT_FILL 11 小间隔点填充USER_FILL 12 用户定义图样填充 正确性我并没有确定，一般而言，在使用bc过程中，我只用到了setfillstyle(1, );其中数字和英文是等效的。其实如果聪明的话，你也许已经想到，可以用数字代表颜色，这样可以用一个数组把颜色给储存起来，从而实现颜色的改变。当然我本人是没有尝试过的。 bar用法: bar(a,b ,c,d); 四个参数分别代表左上角和右下角的坐标x，y。十分简单。只需要注意界面的坐标系是怎么建的即可。这个要看图形化的模式，也就是下面的initgraph中会讲到的。意义为画实心矩形。颜色由setcolor和setfillstyle决定。 delay十分简单，就是delay( 1000); 数字代表毫秒。一般的用途是防止鼠标的连续点击（就是说点一次但实际效果是多次），还有界面跳转时用用防止跳转频繁导致bc崩。加上总没事。 initgraph和closegraph图形化界面必用。只需要main函数里用一次就行。用法如下： 12345678int gd=VGA;//graphdriver int gm=VGAHI;//graphmode initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径//省略。。。。。closegraph(); 这里就是直接复制粘贴即可。唯一要注意的就是initgraph中的“ ”这里的文件路径要根据bgi文件夹的路径来。所以验收的时候就要注意了，最好把你的文件放到那个C盘里。具体验收的流程我以后记得会补充。 原理可以自行上网搜索。 ——7.17 usehelp1234567891011121314151617181920212223242526272829303132333435363738#include &quot;common.h&quot;/*========================用户说明界面简单的操作说明书=========================*/int usepage(int* a5)&#123; if (*a5 == 1) &#123; cleardevice(); setbkcolor(WHITE);//background color setcolor(RED);//边界color setfillstyle(1, RED);//意思：设置绿色的填充模式为1（完全填充） rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); puthz(250,10, &quot;系统说明&quot;, 32, 30,GREEN); setcolor(GREEN);//边界color rectangle(10, 50, 635, 470); puthz(10+5, 50+5, &quot;该系统模拟了两个不同的农田，代表了两种不同的用户。平坝田地势平坦，一览无余，适用于种植大户，设置了小麦与玉米间种。小农田地势多样、具有障碍物，植物多种分布不匀杂乱。操作流程：首先进入农田，点击生长检测，此时无人机运行开始检测。结束后，可以在结果查看界面查看农作物的患病情况，并根据需要，选择配置相应的农药。农药装配到无人机后，无人机会自动进行最优路径规划，并进行农药喷洒。&quot;, 32, 30, GREEN); *a5 = 0; &#125; showbiankuang(0, 0, 80, 40);//showbiankuang是自己编写的一个函数，作用为鼠标移动到那里会标亮矩形边框提示。实际意义不大，因为验收老师不会关注这个。但闲的时候可以直接套用。 showbiankuang(600, 0, 640, 40); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a5 = 1;//注意这里要把a5还原。 return 1;// &#125; return 4;&#125; 为了方便和效率，没有特殊列出，头文件只有源文件里面的函数声明。所以这里的usehelp.h就略去了。这里巧妙的一点就是函数传入了a5这个参数，这样使得if（a5&#x3D;&#x3D;1）这里面的代码只调用一次，能够很好的防止各种bug，界面更加稳定。我这里所有的界面跳转都用到了这个基本的思想。 move12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;common.h&quot;/*-------------- 解决了鼠标的闪动问题， 解决了鼠标被 图像遮挡的问题--------------*///适用于 int类型函数。可参考 welcome.h中的使用int moveint(int (*hanshu)(int*), int* a)&#123; int b; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; b= hanshu(a);//顺序有严格要求，不能颠倒，否则出问题 if (*a != -10)//注意只能if，不能while,而且，这里的*a!=-10是为了消除warning &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return b;&#125;int moveint1(int (*hanshu)(int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49]), int* a, unsigned char b[384][49], unsigned char c[192][49], unsigned char d[192][49])//这个不用看，这么复杂是因为当时不知道文件操作怎么用。。&#123; int bbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbb = hanshu(a,b,c,d); if (*a!=-10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbb;&#125;void showbiankuang(int x1, int y1, int x2, int y2)//用于显使得鼠标在 矩形中显示边框&#123;//矩形的内部颜色都是白色 if (mouse_press( x1, y1, x2, y2)==2|| mouse_press(x1, y1, x2, y2) == 1) &#123;//鼠标在框内，而且不处于左键点击状态。其实也可以不这么写。 setcolor(BLUE); rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1);//内部标亮为蓝色 &#125; else &#123; setcolor(WHITE); rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1);//覆盖标亮 &#125;&#125; 这里总共就三个函数，第一个和第二个的原理一模一样，只不过是能调用的函数类型不一样。moveint这个函数就是智能调用函数形式为 int hanshu(int *a);这种定义类型的。同理你可以根据实际情况改成，比如movevoid(void (*hanshu)(int ),int *a)。这个原理就是把函数作为参数传递。唯一作用就是解决历代流传下来的界面跳转时的鼠标留痕问题。 showtime12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;common.h&quot;#include &quot;shuju.h&quot;#include &quot;showtime.h&quot;/*-----------------------------------------------------展示时间，具体时间可以自行修改，显示的坐标也可以。注意这里实现了时间每秒刷新一次。------------------------------------------------------*/void displayCurrentTime(void)&#123; int currenttime = 1;//设定现在时间,初始化。 int pasttime = 0;//参考时间 //////////////////////////////// time_t timep; struct tm* p; char timeString[20]; // 获取当前时间的秒数 time(&amp;timep); // 转换为协调世界时的时间结构体 p = localtime(&amp;timep); //这一段是通用代码，就是直接复制即可，就是把时间的信息放到了timep这个结构里面 ////////////////////////////// currenttime = p-&gt;tm_sec;//赋值 getshijian1(&amp;pasttime);//实现一段时间内（1s）pasttime=currenttime. //get...这个函数就是把文件里面的数字传给pasttime，相当于赋值。。 if (pasttime != currenttime)//利用这个实现每过一秒中就刷新一个，具体自己理解） &#123; clearTimeArea();// 清除时间显示区域 pasttime = currenttime; setshijian1(pasttime);//把文件里面的数字改成pattime的数字 &#125; // 在窗口中显示转换后的时间信息 setcolor(LIGHTGREEN);//outtextxy的颜色 settextstyle(1, HORIZ_DIR, 1);//HOR...表示横向显示，第二个1表是字体大小。1为小，0默认。2，3..大 outtextxy(10, 10, &quot;Local Time&quot;); settextstyle(1, HORIZ_DIR, 1); sprintf(timeString, &quot;%d-%02d-%02d- %02d:%02d:%02d&quot;,//图形化下的数据显示函数。sprintf将这些储存到timestring字符串中 p-&gt;tm_year + 1900, p-&gt;tm_mon + 1, p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);//这里要加1900和1的原因感兴趣自己可以去查。 outtextxy(10, 30, timeString);//显示字符串&#125;/*-----------------------------------------------------用一个实心矩形（注意改背景色），遮挡。并不断刷新，实现部分cleardevice()的效果。 c=bioskey(0); //读取键盘输入内容------------------------------------------------------*/void clearTimeArea(void) &#123; setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(10, 30, 300, 55); // 清除时间显示区域&#125; &emsp;这里实现了一个时钟的显示吧，意义不大，主要是让界面看起来更丰富一点。clearTimeArea就是用一个矩形覆盖上一秒的数字，然后重新outtexty，这样就实现了时间的更新。但是要实现每秒更新一次时间，就要引入pasttime了。否则实际情况是clearTimeArea一直在执行，导致时钟一直在闪烁。原理用到了文件操作。但其实，我一开始是直接用结构（struct）然后直接全局变量。。在shuju.h中你也会见到全局变量的用法。 这个的原理还是比较简单的。但仍然存在的bug是鼠标放到时钟显示的地方会被遮挡，这个小细节还没想到如果优化，但其实意义不大，老师不会注重这些与选题无关的细节，就比如室友还加了买门票提醒出现小红点功能，碰到cj还不是直接挂？管你做的多细节？只要有一些核心的东西没到点就是寄。 mainpage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;common.h&quot;/*-----------------------------------------------------主界面的编写，实现不同功能界面的跳转可以一览本程序的功能。------------------------------------------------------*/int hello(int* a2)&#123; //绘图,只画一次,绘制主界面 if (*a2 == 1) &#123; int i = -1; clrmous(MouseX, MouseY); cleardevice(); setbkcolor(WHITE);//background color setcolor(RED); setfillstyle(1,RED ); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//右上角画 退出 setcolor(GREEN); puthz(80, 60, &quot;无人机喷洒农药系统&quot;, 32, 50, GREEN); line(80, 100, 520, 100);//画标题 rectangle(220, 120, 420, 200); rectangle(220, 240, 420, 320); rectangle(220, 360, 420, 440); puthz(230, 140, &quot;进入平坝田&quot;, 32, 38, GREEN); puthz(230, 260, &quot;进入小农田&quot;, 32, 38, GREEN); puthz(230, 380, &quot;系统说明&quot;, 32, 50, GREEN); //画三个框框，代表三种功能。 *a2 = 0; setshijian1(i);//初始化 time.dat文件 &#125;//else--------------------------------------------------- displayCurrentTime();//左上角显示时间 showbiankuang(220,120,420,200);//用于显使得鼠标在 矩形中显示边框 showbiankuang(220, 240, 420, 320); showbiankuang(220, 360, 420, 440); showbiankuang( 600 ,0 ,640 ,40 );//------------------------------------------------------- //界面的跳转 if( mouse_press(600,0,640,40) == 1) &#123; *a2 = 1;//使得函数参数重置，为了能够实现返回界面 return -1;//关闭BC。 &#125; else if (mouse_press(220,120,420,200) == 1) &#123; *a2 = 1; return 2;//进入大农田 &#125; else if (mouse_press(220, 240, 420, 320)== 1) &#123; *a2 = 1; return 3;//小农田 &#125; else if (mouse_press(220, 360, 420, 440) == 1) &#123; *a2=1; return 4 ;//系统说明 &#125; return 1; &#125; 此界面就是初始界面了。十分简单。绘图部分完全不用看，界面跳转也是一个通用模板了。 drzhiwu123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 #include&quot;common.h&quot;/*========================================functions: 画植物，包括小麦，玉米，棉花。=========================================*///=============// 画棉花，透视图//==============void mianhua(int x, int y)//x,y为其的左上角坐标。20*35&#123; setcolor(GREEN); setfillstyle(SOLID_FILL, GREEN); bar(x + 10, y + 15, x + 12, y + 35); line(x + 7, y + 14, x + 10, y + 17); line(x + 10, y + 17, x + 16, y + 14); ellipse(x+18, y+17,10, 360, 2, 4);//画椭圆函数 ellipse(x + 5, y +16 , 20, 360, 3, 4); floodfill(x + 5, y + 16, GREEN); floodfill(x + 18, y + 17, GREEN); line(x+10, y+15, x+10, y+9); line(x+11, y+15, x+11, y+9); line(x+10, y+9, x+3, y+7); line(x+3, y+7, x+9, y+5); line(x+9, y+5, x+6, y+1); line(x+6, y+1, x+10, y+2); line(x+10, y+2, x+12, y+5); line(x+12, y+5, x+15, y+1); line(x+15, y+1, x+16, y+5); line(x+16, y+5, x+19, y+6); line(x+19, y+6, x+19, y+9); line(x+19, y+9, x+13, y+10); line(x+13, y+10, x+13, y+13); line(x+13, y+13, x+11, y+10); floodfill(x + 9, y + 3, GREEN); setcolor(WHITE); line(x+10, y+9, 6+x, y+8); line(x+11,y+ 9, 10+x, 4+y); line(11+x, y+9, x+15, y+2); line(x+12, y+8, x+14, y+7);&#125;//=============// 画玉米，透视图//==============void yumi(int x, int y) //xy为左上角35*35&#123; setcolor(GREEN); setfillstyle(SOLID_FILL, GREEN); bar(x + 12, y + 3, x + 16, y + 35); arc(x+14, y+4, 0, 180, 2); floodfill(x + 13, y + 3, GREEN); line(x + 12 , y +4 , x +5 , y +4 ); line(x +5 , y + 4, x +2 , y +10 ); line(x +2 , y +10 , x +6 , y +8 ); line(x + 6, y +8 , x +12 , y +7 ); line(x + 12, y +18 , x +9 , y + 17); line(x + 9, y + 17, x +7 , y + 28); line(x +7 , y +28 , x +12 , y + 22); line(x + 16, y +24 , x + 21, y +20 ); line(x + 21, y + 20, x +27 , y +25 ); line(x + 27, y +25 , x +23 , y +17 ); line(x +23 , y +17 , x + 16, y + 20); floodfill(x + 20, y + 19, GREEN); floodfill(x + 10, y + 20, GREEN); floodfill(x + 5, y + 7, GREEN); line(x + 16, y +17 , x + 20, y +15 ); line(x +20 , y +15 , x +20 , y +4 ); line(x + 20, y +4 , x +16 , y +12 ); floodfill(x + 19, y + 19, GREEN); line(x + 16, y + 13, x + 20, y + 6); line(x +12 , y +10 , x + 7, y +8 ); line(x + 7, y + 8, x +12 , y + 12); line(x + 7, y +8 , x +6 , y +10 ); line(x + 6, y + 10, x +12 , y + 17); line(x + 6, y +10 , x +12 , y +12 ); setfillstyle(SOLID_FILL, YELLOW); floodfill(x + 10, y + 12, GREEN); floodfill(x + 18, y + 12, GREEN);&#125;//=======//小麦块//=======void xiaomaikuai(int x, int y)&#123; xiaomai(x, y); xiaomai(x+5, y); xiaomai(x-5, y);&#125;//画小麦透视图,,,其大小为 20*19.void xiaomai(int x, int y)&#123; x = x +10;//修正小麦坐标 //xy是最顶点 setcolor(GREEN); putpixel(x, y, GREEN); line(x, y, x, y + 19); line(x, y + 6, x + 5, y + 6 - 5); line(x, y + 6, x - 5, y + 6 - 5); line(x, y + 12, x - 5, y + 6); line(x, y + 12, x + 5, y + 6 );&#125;//画小麦俯视图void fxiaomai(int x, int y)//xy是最左边的点//25*25&#123; setcolor(GREEN); line(x + 2, y + 10 + 6 + 4 + 3, x + 6, y + 2 + 6 + 4 + 3); line(x + 2, y + 6 + 6 + 4 + 3, x + 10, y + 6 + 6 + 4 + 3); line(x + 6, y + 12 + 6 + 4 + 3, x + 3, y + 3 + 6 + 4 + 3); line(x + 10, y + 9 + 6 + 4 + 3, x + 7, y + 12 + 6 + 4 + 3); line(x + 11, y + 10 + 6 + 4 + 3, x + 8, y + 7 + 6 + 4 + 3); line(x + 13, y + 10 + 6 + 3, x + 6 + 12, y + 2 + 6 + 3 + 3); line(x + 2 + 12, y + 6 + 6 + 3, x + 10 + 12, y + 6 + 6 + 3 + 3); line(x + 6 + 12, y + 12 + 5 + 4, x + 3 + 12, y + 3 + 6 + 3 + 3); line(x + 10 + 12, y + 9 + 6 + 3, x + 7 + 12, y + 12 + 4); line(x + 11 + 12, y + 10 + 3 + 3, x + 8 + 12, y + 7 + 4 + 3); line(x + 6 + 10, y + 12, x + 8 + 10, y + 12 + 2); line(x + 6 + 10, y + 12, x + 6 - 2 + 10, y + 12 + 2); line(x + 6 + 10, y + 12, x + 6 + 10, y + 12 - 4); line(x + 6 + 10, y + 12, x + 6 - 2 + 10, y + 12 - 4); line(x + 4, y + 2, x + 8, y + 10); line(x + 8, y + 6, x + 8, y + 2); line(x + 8, y + 10, x + 12, y + 2); line(x + 4, y + 10, x + 8, y + 18); line(x + 8, y + 14, x + 8, y + 10); line(x + 8, y + 18, x + 12, y + 10); line(x + 8, y + 2, x + 16, y + 10); line(x + 16, y + 6, x + 16, y + 2); line(x + 16, y + 10, x + 24, y + 2); line(x + 8, y + 10, x + 16, y + 18); line(x + 16, y + 14, x + 16, y + 10); line(x + 16, y + 18, x + 24, y + 10);&#125;//=============// 画玉米，俯视图//==============void fyumi(int x, int y)&#123; setcolor(GREEN); circle(x + 12, y + 12, 2); line(x + 12, y + 10, x + 20, y + 2); line(x + 20, y + 2, x + 16, y + 9); line(x + 16, y + 9, x + 13, y + 11); line(x + 14, y + 9, x + 20, y + 13); line(x + 20, y + 13, x + 13, y + 13); putpixel(x + 13, y + 13, GREEN); putpixel(x + 13, y + 14, GREEN); putpixel(x + 14, y + 14, GREEN); putpixel(x + 14, y + 15, GREEN); putpixel(x + 15, y + 15, GREEN); putpixel(x + 15, y + 16, GREEN); putpixel(x + 14, y + 17, GREEN); putpixel(x + 15, y + 17, GREEN); putpixel(x + 16, y + 17, GREEN); putpixel(x + 17, y + 17, GREEN); putpixel(x + 18, y + 17, GREEN); line(x + 18, y + 17, x + 20, y + 23); line(x + 20, y + 23, x + 13, y + 20); line(x + 13, y + 20, x + 12, y + 15); line(x + 11, y + 11, x + 2, y + 10); line(x + 2, y + 10, x + 2, y + 12); line(x + 2, y + 12, x + 5, y + 13); line(x + 5, y + 13, x + 11, y + 14); line(x + 7, y + 14, x + 3, y + 21); line(x + 3, y + 21, x + 12, y + 18); line(x + 5, y + 10, x + 13, y + 7); setfillstyle(SOLID_FILL, GREEN); floodfill(x + 12, y + 12, GREEN); // 遇到边界颜色停止 setfillstyle(SOLID_FILL, YELLOW); floodfill(x + 15, y + 18, GREEN);&#125; 完全没有技术含量，仅仅是画图而已。 那今天的更新就到这里吧，大概不久就要去练科三了，时间也变的紧张起来。考驾照无非就是67个人围着一辆车子，一个人10多min，一天下来基本在太阳底下站。。。早七晚六不用说。大二上学期更没时间，课表全满，双休也有课，每天早八晚九了。。。 abdrone123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &quot;common.h&quot;/*===========================================无人机所有函数，包括运动，画图=============================================*///俯视图 的无人机//用于大农田void drfdrone(int x, int y)//xy是左上角坐标&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); //circle(x + 12, y + 12, 4); fillellipse(x + 12, y + 12, 4, 4); rectangle(x + 8, y + 9, x + 15, y + 15);// floodfill(x + 12, y + 12, DARKGRAY); line(x + 5, y + 4, x + 9, y + 8); line(x + 3, y + 4, x + 9, y + 9); line(x + 3, y + 5, x + 8, y + 10); line(x + 9, y + 1, x + 1, y + 9); line(x + 8, y + 1, x + 0, y + 9); line(x + 7, y + 1, x + 0, y + 8); line(x + 15, y + 8, x + 19, y + 4); line(x + 15, y + 9, x + 20, y + 4); line(x + 15, y + 10, x + 20, y + 5); line(x + 15, y + 0, x + 24, y + 9); line(x + 16, y + 0, x + 24, y + 8); line(x + 14, y + 1, x + 23, y + 9); line(x + 16, y + 15, x + 21, y + 20); line(x + 15, y + 15, x + 20, y + 20); line(x + 14, y + 16, x + 20, y + 21); line(x + 24, y + 15, x + 15, y + 24); line(x + 24, y + 16, x + 16, y + 24); line(x + 24, y + 14, x + 14, y + 24); line(x + 9, y + 15, x + 3, y + 21); line(x + 8, y + 15, x + 3, y + 20); line(x + 9, y + 16, x + 4, y + 21); line(x + 0, y + 15, x + 9, y + 24); line(x + 0, y + 16, x + 8, y + 24); line(x + 0, y + 14, x + 10, y + 24);&#125;//==================================================//动画实现代码。建议自己理解。。。。。详细调用在growlook.c里面的大农田里面有。//原理大概就是视觉停留（？，void move11(int* x, int* y, int* buffer1)&#123; for (; *x &lt; 620 - 25; *x = *x + 2)//运动到了最左端。。 &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1);//保存image到buffer drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT);//恢复图像 &#125;&#125;void move12(int* x, int* y, int* buffer1, int* judge)&#123; for (; *y &lt; *judge + 25; (*y)++) &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(10); putimage(*x, *y, buffer1, COPY_PUT); &#125; *judge = *y;&#125;void move13(int* x, int* y, int* buffer1)&#123; for (; *x &gt; 20; *x = *x - 2) &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); &#125;&#125;//=============================================//无人机透视图，用于小农田void drtdrone(int xx, int y)//xy是左上角坐标 75*44&#123; int x; x = xx - 25; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(0 + x, 4 + y, 24 + x, 5 + y); bar(49 + x, 4 + y, 73 + x, 5 + y); bar(x + 4, y + 6, x + 5, y + 10); bar(x + 6, y + 9, x + 20, y + 10); bar(x + 19, y + 6, x + 20, y + 10); bar(x + 53, y + 6, x + 54, y + 10); bar(x + 54, y + 10, x + 69, y + 9); bar(x + 68, y + 6, x + 69, y + 9); bar(x + 7, y + 11, x + 9, y + 14); bar(x + 16, y + 11, x + 18, y + 13); bar(x + 8, y + 16, x + 22, y + 17); bar(x + 55, y + 11, x + 57, y + 13); bar(x + 64, y + 14, x + 66, y + 11); bar(x + 51, y + 16, x + 65, y + 17); bar(x + 24, y + 11, x + 49, y + 13); bar(x + 21, y + 20, x + 51, y + 22); bar(x + 23, y + 24, x + 50, y + 25); line(x + 11, y + 18, x + 13, y + 18); line(x + 60, y + 18, x + 62, y + 18); line(x + 9, y + 15, x + 23, y + 15); line(x + 50, y + 15, x + 64, y + 15); line(x + 10, y + 14, x + 17, y + 14); line(x + 10, y + 13, x + 15, y + 13); line(x + 10, y + 12, x + 10, y + 14); line(x + 15, y + 12, x + 15, y + 13); line(x + 57, y + 14, x + 63, y + 14); line(x + 58, y + 13, x + 63, y + 13); line(x + 58, y + 12, x + 58, y + 13); line(x + 63, y + 12, x + 63, y + 13); line(x + 23, y + 12, x + 23, y + 14); line(x + 50, y + 12, x + 50, y + 14); line(x + 8, y + 2, x + 10, y + 0); line(x + 8, y + 3, x + 11, y + 0); line(x + 14, y + 0, x + 16, y + 2); line(x + 13, y + 0, x + 16, y + 3); line(x + 12, y + 0, x + 9, y + 3); line(x + 13, y + 1, x + 15, y + 3); line(x + 12, y + 1, x + 10, y + 3); line(x + 12, y + 1, x + 14, y + 3); line(x + 21, y + 18, x + 21, y + 19); line(x + 20, y + 18, x + 20, y + 21); line(x + 52, y + 18, x + 52, y + 21); line(x + 53, y + 18, x + 53, y + 20); line(x + 23, y + 23, x + 25, y + 23); line(x + 48, y + 23, x + 50, y + 23); line(x + 57, y + 2, x + 59, y + 0); line(x + 57, y + 3, x + 60, y + 0); line(x + 58, y + 3, x + 61, y + 0); line(x + 62, y + 0, x + 59, y + 3); line(x + 63, y + 0, x + 65, y + 2); line(x + 63, y + 1, x + 65, y + 3); line(x + 62, y + 1, x + 64, y + 3); line(x + 62, y + 2, x + 63, y + 2); line(x + 23, y + 26, x + 23, y + 32); line(x + 24, y + 26, x + 24, y + 30); line(x + 22, y + 32, x + 22, y + 42); line(x + 21, y + 32, x + 21, y + 42); line(x + 20, y + 37, x + 20, y + 41); line(x + 21, y + 41, x + 25, y + 41); line(x + 21, y + 42, x + 24, y + 42); line(x + 49, y + 26, x + 53, y + 37); line(x + 49, y + 27, x + 53, y + 38); line(x + 51, y + 34, x + 51, y + 42); line(x + 48, y + 41, x + 53, y + 41); line(x + 49, y + 42, x + 52, y + 42); line(x + 53, y + 37, x + 53, y + 41); line(x + 51, y + 34, x + 51, y + 42); line(x + 52, y + 42, x + 52, y + 34); bar(x + 41, y + 28, x + 43, y + 36); bar(x + 41, y + 26, x + 42, y + 36); line(x + 38, y + 36, x + 43, y + 36); line(x + 31, y + 26, x + 29, y + 30); line(x + 32, y + 26, x + 29, y + 31); line(x + 34, y + 36, x + 30, y + 36); line(x + 30, y + 36, x + 30, y + 27); line(x + 29, y + 30, x + 29, y + 35); setcolor(LIGHTGRAY); setfillstyle(1, LIGHTGRAY); floodfill(x + 12, y + 3, DARKGRAY); floodfill(x + 61, y + 3, DARKGRAY); floodfill(x + 13, y + 12, DARKGRAY); floodfill(x + 60, y + 11, DARKGRAY); line(x +26 , y +23 , x +47 , y + 23); bar(x +6 , y + 6, x +18 , y + 8); bar(x +55 , y +6, x +67 , y +8 ); bar(x + 24, y +14 , x + 49, y +19 ); line(x +23 , y + 16, x +23 , y + 19); line(x +50 , y + 16, x +50 , y + 19); setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(x +26 , y + 17, x + 27, y +18 ); bar(x + 29, y + 17, x + 30, y + 18);&#125; 这个文件就是画无人机（两种形式），写了一段实现简单动画平移的函数，目前关于如何实现斜线运动我那时就没想到，之后也就没想了（只想到了循线这种）。比较简单，不需要多看。。 shuju.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &quot;shuju.h&quot;#include &quot;common.h&quot;//==============================================================//控制时间间隔。原理请配合showtime.c使用//这里和时间那里有关，其实可以直接搞个全局变量就OK，//但当时怕被发现，换成了文件操作，当时也是刚刚学这东西，所以就当练练手了void setshijian1(int cankaotime)//这个函数的作用就是把传进的 cankaotime这个东西写入到time.dat文件//中（这种文件都能直接用记事本打开好像，还是比较方便检查错误的）&#123; FILE* filePointer1; filePointer1 = fopen(&quot;data//time.dat&quot;, &quot;w&quot;); //具体用法建议问chatgpt或者上网搜 if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; fprintf(filePointer1, &quot;%d\n&quot;, cankaotime);//设置使得time.dat 储存cankaotime的数字 fclose(filePointer1);&#125;//上面那一串都是直接复制粘贴的，原理我不太懂。。套路就是这样吧，那里的if那一大段要不要其实无所谓了，我后面//自己编写的时候也基本没加，但加上还是好的，便于检查内存分配的问题。void getshijian1(int *cankaotime)&#123; FILE* filePointer1; filePointer1 = fopen(&quot;data//time.dat&quot;, &quot;r&quot;); if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; fscanf(filePointer1, &quot;%d&quot;, cankaotime);//设置使得cankaotime获得time.dat 储存的数字，注意这里用了指针。。 fclose(filePointer1); //fscanf用&amp;,fprintf不用&amp;&#125;//这里只需要掌握fscanf和fprintf的用法就行，靠这两个函数就能基本实现储存和读取数据了。//====================================================//这一堆都是偷偷藏起来的全局变量，后面想改，但时间不够，而且难度高，所以索性摆烂了，全都是大农田用的，因为//大农田搞了个植物自愈，自愈不完全，病情加深的功能，虽然验收老师并没有感到十分的赞赏。。。。。。无用功吧属//实是。unsigned char dianmian_bitmap[192][49];//这三个就是储存点的坐标，就是植物生病会随机出现颜色点，点的//坐标就储存到了这个数组里面，现在想来就是纯纯折磨自己。搞了个点的随机显示。如果你仔细观察大农田就会发现了unsigned char dianbai_bitmap[192][49];unsigned char diannian_bitmap[384][49];//，棉铃虫，白粉病，黏虫。//下面这三个是储存生病植物的坐标，用了全局变量，当然可以用文件操作（小农田就是这样，但要重写实在太麻烦dbfxy bai = &#123; 0 &#125;;//小麦地得白粉病 的坐标。 注意当x，y均为0时，表示该区域不得病。dbfxy mian = &#123; 0 &#125;;//得棉铃虫病的坐标。 注意当x，y均为0时，表示该区域不得病。niang nian = &#123; 0 &#125;;//黏虫的坐标，左上角坐标， 注意当x，y均为0时，表示该区域不得病。//下面三个是队友写的全局变量。。看不太懂int nongyao[6];//氟铃胺，甲胺磷，氯氰菊酯，甲维盐，菌酯, nongyao[6]用于判断大小农田 0:大 1：小int rount[386][2];//储存需要喷洒农药的植物坐标int amtjudge;//判断需要喷洒的植物的棵数//=================================================================================//获得所有植物的坐标，把植物坐标传入到 plantPostions里面。void getxtxiao(int plantPositions3[][2])//小农田的代码，就是把植物坐标传入文件xt是小田的意思&#123;//小麦 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtxiao.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 104; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;void getxtyumi(int plantPositions3[][2])&#123;//玉米 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtyumi.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 68; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;void getxtmianhua(int plantPositions3[][2])&#123;//棉花 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtmianhua.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 68; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;//=================================================//下面的三个文件对文件进行初始化定义。//这个函数就是起到初始化文件的作用，就是重新生成一般xtyumi.dat等三个文件（储存了植物坐标），清空记录的作用吧。void setxtzhiwu(int plantPositions1[][2], int plantPositions2[][2], int plantPositions3[][2])&#123; int j; FILE* filePointer1; // 文件指针 FILE* filePointer2; FILE* filePointer3; filePointer1 = fopen(&quot;data//xtyumi.dat&quot;, &quot;w&quot;); // 以写入模式打开文件 filePointer2 = fopen(&quot;data//xtmianhua.dat&quot;, &quot;w&quot;); filePointer3 = fopen(&quot;data//xtxiao.dat&quot;, &quot;w&quot;); if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; if (filePointer2 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; if (filePointer3 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; for (j = 0; j &lt; 68; j++) &#123; fprintf(filePointer1, &quot;%d %d\n&quot;, plantPositions1[j][0], plantPositions1[j][1]); &#125; for (j = 0; j &lt; 68; j++) &#123; fprintf(filePointer2, &quot;%d %d\n&quot;, plantPositions2[j][0], plantPositions2[j][1]); &#125; for (j = 0; j &lt; 104; j++) &#123; fprintf(filePointer3, &quot;%d %d\n&quot;, plantPositions3[j][0], plantPositions3[j][1]); &#125; fclose(filePointer1); fclose(filePointer2); fclose(filePointer3);&#125;//下面是大农田里用到的//就是清空全局变量的值，全部归零，防止退出到主界面时，上一次的检测结果影响。void zero(void)//重置储存。。&#123; int i, j; for (i = 0, j = 192; i &lt; 192, j &lt; 384; i++, j++) &#123; bai.bfzuobiao[i][0] = 0; bai.bfzuobiao[i][1] = 0; mian.bfzuobiao[i][0] = 0; mian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][0] = 0; &#125;&#125;//下面这两个函数都是gpt生成的，当时出现了内存爆炸的问题，心里也很慌，gpt说位图能减少内存使用，所以//阴差阳错之下就用到了这东西，反正我看不懂，但还是会用的。具体使用好像是在illness.c和recover.c里面// 设置位图中的某个像素值，具体原理我当时也没去了解，过了C课设之后更不学了。。void setshu(unsigned char bitmap[49], int x, int value)&#123; if (value) &#123; bitmap[x / 8] |= (1 &lt;&lt; (x % 8)); // 设置为 1 &#125; else &#123; bitmap[x / 8] &amp;= ~(1 &lt;&lt; (x % 8)); // 设置为 0 &#125;&#125;// 获取位图中的某个像素值int getshu(unsigned char bitmap[49], int x)&#123; return (bitmap[x / 8] &gt;&gt; (x % 8)) &amp; 1;&#125; shuju.h12345678910111213141516171819202122232425262728293031323334353637383940#ifndef _SHUJU_H#define _SHUJU_H/*--------------作为数据库，实现一次定义--------------*/typedef struct&#123; int bfzuobiao[384][2];//&#125; niang; //储存黏虫的坐标信息；typedef struct&#123; int bfzuobiao[192][2];//&#125; dbfxy;//储存小麦的白粉病信息以及玉米的棉铃虫信息//引用全局变量，extern dbfxy bai;extern dbfxy mian;extern niang nian;extern unsigned char dianmian_bitmap[192][49];//位图，储存颜色点的信息extern unsigned char dianbai_bitmap[192][49];extern unsigned char diannian_bitmap[384][49];//初始化位图和获取位图的0，1.void setshu(unsigned char bitmap[49], int x, int value);int getshu(unsigned char bitmap[49], int x);extern int nongyao[6];//氟铃胺，甲胺磷，氯氰菊酯，甲维盐，菌酯, nongyao[5]用于判断大小农田 0:大 1：小extern int rount[386][2];//储存需要喷洒农药的植物坐标extern int amtjudge;//判断需要喷洒的植物的棵数//初始化小农田里的各种植物坐标。以及从文件中获取各个植物的坐标到数组中void setxtzhiwu(int plantPositions1[][2], int plantPositions2[][2], int plantPositions3[][2]);void getxtmianhua(int plantPositions3[][2]);void getxtyumi(int plantPositions3[][2]);void getxtxiao(int plantPositions3[][2]);//=====================//time.dat //function:控制时间间隔，每隔一秒刷新void setshijian1(int cankaotime);void getshijian1(int* cankaotime);//=====================void zero(void);//重置大农田的患病植物坐标储存#endif 这两个文件基本涉及到了所有的文件操作的相关函数（我是指我编的程序里面用到的），对于看懂整个代码有很大作用。比较复杂，因为是后面边写便堆砌上去的。毕竟文件操作都是差不多距离验收一个月前加上去的。虽然我们用到的文件操作仅仅限于储存数组，但毫无争议的是，还是要学更多，毕竟画图没有什么含金量，你也可以发现，其实整个程序抛弃画图，我现在看来，C课设编写的程序也就那样。。。详细解释看新加的注释 ​ ——7.28 mainfunc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include &quot;common.h&quot;/*===========================================实现了分工，其中准备喷洒会进入另外一个新界面。绘制了农田和植物的基本样子。=============================================*/int mainfunc(int* a3, unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49])&#123;//大农田的绘制 int i; srand(time(NULL)); //================================ //这里是绘制大农田界面 if (*a3 == 1) &#123; cleardevice(); clrmous(MouseX, MouseY); setbkcolor(WHITE);//background color drawBackground();//画通用背景 farmfield();//绘制农田 *a3 = 0; &#125; //=========================== if (*a3 ==- 1)//实现界面跳转后，返回改界面的重新绘图 &#123; cleardevice(); clrmous(MouseX, MouseY); setbkcolor(WHITE);//background color drawBackground(); farmfield(); for (i = 0; i &lt; 192; i++)//小麦区域的发病率 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1],diannian[i]); &#125; &#125; for (i=192; i &lt; 384; i++)//玉米区域的发病率 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1],diannian[i]); &#125; &#125; for (i = 0; i&lt; 192; i++)//玉米区域的发病率. &#123; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; mianling(mian.bfzuobiao[i][0], mian.bfzuobiao[i][1],dianmian[i]); &#125; &#125; for (i = 0;i &lt; 192; i++) &#123; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; baifen(bai.bfzuobiao[i][0], bai.bfzuobiao[i][1],dianbai[i]); &#125; &#125; *a3 = 2; &#125; //上面这一段是重新绘图，因为结果查看后要返回到大农田界面，所以要这样 //====================ELSE //鼠标显示边框 showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(100, 5, 100 + 140, 50); //===================下面是界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; zero();//重置病虫坐标 delay(100); return 1;//返回前一个界面 &#125; else if (mouse_press(100, 5,240, 50) == 1)//连续点击生长检测 &#123; *a3 = 2; clrmous(MouseX, MouseY); grow();//无人机动画的实现 recover();//再次点击生长检测，部分区域恢复 //显示三种病 showbaifen(dianbai); shownianchong(diannian); showmianling(dianmian); &#125; if (*a3 == 2 || *a3 == -1)//这里实现了必须先点击一次生长检测，才能点击结果查看和准备喷洒的功能 &#123; if (mouse_press(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50) == 1) &#123; *a3 = -1; delay(100); return 6;//结果查看部分 &#125; else if (mouse_press(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50) == 1) &#123; *a3 = -1; delay(100); return 7;//准备喷洒部分 &#125; showbiankuang(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); showbiankuang(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); &#125; return 2;&#125;//绘制通用背景void drawBackground(void)&#123; setcolor(RED);//边界color setfillstyle(1, GREEN);//意思：设置绿色的填充模式为1（完全填充） rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, GREEN); bar(100, 5, 100 + 140, 50); bar(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); bar(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); puthz(100 + 10, 5 + 5, &quot;生长检测&quot;, 32, 30, WHITE); puthz(100 + 140 + 30 + 10, 5 + 5, &quot;结果查看&quot;, 32, 30, WHITE); puthz(100 + 140 + 140 + 30 + 30 + 10, 5 + 5, &quot;准备喷洒&quot;, 32, 30, WHITE);&#125;//绘制农田 void farmfield(void)&#123; int x = 0, y = 0; int j; int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;; setfillstyle(1, BROWN); setcolor(BROWN); bar(20, 60+5, 640-20, 480-15);//边框，即农田大小 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域, &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j]) &#123; j++; fxiaomai(x, y); &#125; &#125; for (y = 0; y &lt;= 300; y = y + 100)//玉米的绘制 &#123; for (x = 20; x &lt;= 620 - 25; x = x + 25) &#123; fyumi(x, 65+50 + y); fyumi(x, 65 +25+50 + y); &#125; &#125;&#125; 这一个文件是实现了大农田的农田绘制和植物的生长检测功能（包括无人机动画，病虫害显示）这段代码个人认为有用的包括那个 必须得先点击一个按键，之后便可点击其他。也许你有其他的方法，但我暂时还没思路。 illness.h123456789101112131415161718192021222324252627#ifndef _ILLNESS_H_#define _ILLNESS_H_//大农田显示void showbaifen(unsigned char abc[192][49]);void baifen(int x, int y, unsigned char abc[49]);void ifbaifen(unsigned char abc[49]);void nianchong(int x, int y, unsigned char aaa[49]);//画黏虫void ifnianchong(unsigned char aaa[49]);//随机点列void shownianchong(unsigned char aaa[384][49]);void ifmianling(unsigned char aaa[49]);//随机显示void mianling(int x, int y, unsigned char aaa[49]);void showmianling(unsigned char aaa[192][49]);int randill(int j);//控制不同的病的不同的发病率。就是使得一种病，每次检测时，的发病率不同//小农田显示void showxtbaifen(void);void xtbaifen(int x, int y, FILE* filePointer5);//画出白粉病，适用于俯视图。25*25大小void showxtnianchong(void);void xtnianchong(int x, int y, FILE* filePointer5);//画出白粉病，适用于俯视图。25*25大小void xtymmian(int x, int y, FILE* filePointer5);void showxtymmian(void);void showxtymnian(void);void xtymnian(int x, int y, FILE* filePointer5);void showxtmhmian(void);void xtmhmian(int x, int y, FILE* filePointer5);void showxtmhxiu(void);void xtmhxiu(int x, int y, FILE* filePointer5);#endif illness.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965#include &quot;common.h&quot;/*==========================植物患病的概率===========================*/int randill(int k)//这里j代表系数,注意0，1，2，3.&#123;//随机显示 点 int judge; int i, j; int a[4][60] = //这一堆控制的是显示点数量的比例啥的，没什么大用。。。建议不用看 &#123; //棉铃虫对于玉米的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40,40,40,40,5,5,5,5,7,7,7,7,7,8,8,8,8,10,10,10,10,11,11,11,12,13,13,14,14,14,14,14,15,15,16,17,18,19,20,20,20,20,20,20 &#125;, //黏虫对于小麦的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40, 40,40,40,40,5,5,5,6,6,6,6,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,12,12,12,13,14,14,15,16,17,18,19,20,21,22,22,22,22,22 &#125;, //黏虫对于玉米的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40, 40,40,40,40,5,5,6,6,6,6,7,7,7,9,9,9,10,10,10,11,11,11,12,12,12,13,13,13,13,13,14,14,15,16,16,17,18,19,20,21,22,22,22,22 &#125;, //白粉对于小麦的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40,40,40,40,5,5,5,5,5,5,7,7,7,7,7,8,8,8,8,10,10,10,10,11,11,11,12,13,13,14,14,14,14,14,16,17,18,19,20,20,20,20,20,20 &#125;, &#125;; int b[4][60] = &#123; 0 &#125;; judge = rand() % 8; if (judge != 0)//有8分之一的概率全部是正常 &#123; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 60; j++) &#123; b[i][j] = a[i][j]; &#125; &#125; &#125; else &#123; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 60; j++) &#123; b[i][j] = 999; &#125; &#125; &#125; i = rand() % 60; return b[k][i];&#125;/*==========================显示棉铃虫，大农田===========================*/void showmianling(unsigned char aaa[192][49])//棉铃虫。感染玉米和棉花。&#123;// int aaa[49] = &#123; 0 &#125;;// int temp; int judge = 0; int j; int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//控制y的加的数，使其跳过小麦区域。 int x; int y; int i; x = 0; y = 0; i = 0; temp = randill(0);//控制发病率的调整比例 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域的发病率 &#123; j = -1; for (y = 65 + 50; y &lt; 465; y = y + jia2[j])//3行 &#123; ifmianling(aaa[i]);//控制点的形成 j++; judge = rand() % temp; if (judge == 0)// &#123; mianling(x, y,aaa[i]); mian.bfzuobiao[i][0] = x; mian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;/*==========================显示棉铃虫点列===========================*/void mianling(int x, int y, unsigned char aaa[49])//&#123; int i; int j; int jjj; int mlxy[49][2] = &#123; //蓝色点所有可能的位置...49个点 &#123; 7 , 3 &#125;, &#123; 19 , 1 &#125;, &#123; 20 ,1 &#125;, &#123; 6 , 5 &#125;, &#123; 9, 5 &#125;, &#123; 18 , 4&#125;, &#123; 18 , 5&#125;, &#123; 11 , 6 &#125;, &#123; 14 , 6 &#125;, &#123; 5 ,7 &#125;, &#123; 2 , 8 &#125;, &#123; 7 ,8 &#125;, &#123; 13 ,7 &#125;, &#123; 17 , 7 &#125;, &#123; 22 ,7 &#125;, &#123; 19 , 8 &#125;, &#123; 20 , 8 &#125;, &#123; 6 , 10 &#125;, &#123; 4 , 11 &#125;, &#123; 1 ,13 &#125;, &#123; 3 , 16 &#125;, &#123; 1 ,17 &#125;, &#123; 1 , 18 &#125;, &#123; 2 , 18 &#125;, &#123; 7 , 19 &#125;, &#123; 7 , 20 &#125;, &#123; 5 ,23 &#125;, &#123; 7 , 23 &#125;, &#123; 10 , 12 &#125;, &#123; 10 , 13 &#125;, &#123; 9 , 17 &#125;, &#123; 11 , 15 &#125;, &#123; 12 , 14 &#125;, &#123; 19 , 12 &#125;, &#123; 22 , 12 &#125;, &#123; 22 ,13 &#125;, &#123; 22 , 15 &#125;, &#123; 18 , 15 &#125;, &#123; 19 , 16 &#125;, &#123; 13 , 17 &#125;, &#123; 15 , 16 &#125;, &#123; 15 , 19 &#125;, &#123; 16 , 19 &#125;, &#123; 14 , 21 &#125;, &#123; 15 , 23 &#125;, &#123; 16 , 22 &#125;, &#123; 17 , 24&#125;, &#123; 19 , 21 &#125;, &#123; 21 , 23 &#125;, &#125;; for (i = 0; i &lt; 49; i++) &#123; mlxy[i][0] = mlxy[i][0] + x; mlxy[i][1] = mlxy[i][1] + y; &#125; for (j = 0; j &lt; 49; j++) &#123; jjj = getshu(aaa, j); if ( jjj== 1) &#123; setcolor(BLUE); putpixel(mlxy[j][0], mlxy[j][1], BLUE); &#125; &#125;&#125;/*==========================使得能够随机显示棉铃虫点列===========================*/void ifmianling(unsigned char aaa[49])//随机显示&#123; int judge[49]; int i; for (i = 0; i &lt; 49; i++) &#123; judge[i] = rand() % 2;//显示的概率为 1/2.. if (judge[i] == 1) &#123; setshu(aaa, i, 0);//不显示 &#125; else &#123; setshu(aaa, i, 1);//显示 &#125; &#125;&#125;void shownianchong(unsigned char aaa[384][49])//黏虫。两者均患&#123; int judge = 0; int j; int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;; int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;; int x; int y; int i; int temp1, temp2; temp1 = randill(1); temp2 = randill(2); x = 0; y = 0; i = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域的发病率 &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j]) &#123; ifnianchong(aaa[i]); j++; judge = rand() % temp1;// if (judge == 0)// &#123; nianchong(x, y,aaa[i]); nian.bfzuobiao[i][0] = x; nian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125; i = 192;//就是说，nian.bfzuobiao[i][],第1--192个是小麦区域的得了黏虫病的坐标，第193-384个是玉米的 //注意， 进行了农药喷洒后，请注意把对应的坐标 重新赋值为0 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域的发病率 &#123; j = -1; for (y = 65+50; y &lt; 465; y = y + jia2[j])//3行 &#123; ifnianchong(aaa[i]); j++; judge = rand() % temp2;// 1/4的发病率 if (judge == 0)// &#123; nianchong(x, y,aaa[i]); nian.bfzuobiao[i][0] = x; nian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;void nianchong(int x, int y, unsigned char aaa[49])//&#123; int i; int j; int jjj; int ncxy[43][2] = &#123; //洋红色点所有可能的位置...43个点 &#123; 1 , 2 &#125;, &#123; 1 , 5 &#125;, &#123; 3 , 3 &#125;, &#123; 2 ,20 &#125;, &#123; 2 , 22 &#125;, &#123; 4 , 20 &#125;, &#123; 6 , 13 &#125;, &#123; 6 , 14 &#125;, &#123; 6 , 16 &#125;, &#123; 7 , 14 &#125;, &#123; 10 , 9 &#125;, &#123; 10 , 11 &#125;, &#123; 11 , 10 &#125;, &#123; 13 ,11 &#125;, &#123; 15 , 9 &#125;, &#123; 16 , 10 &#125;, &#123; 16 , 11 &#125;, &#123; 17 , 10 &#125;, &#123; 18 , 9 &#125;, &#123; 11 , 18 &#125;, &#123; 11 ,19 &#125;, &#123; 11 , 20 &#125;, &#123; 10 ,19 &#125;, &#123; 10 , 21 &#125;, &#123; 17 , 17&#125;, &#123; 16 , 18 &#125;, &#123; 17 , 18 &#125;, &#123; 18 , 18 &#125;, &#123; 22 ,17 &#125;, &#123; 22 , 19 &#125;, &#123; 21 , 18 &#125;, &#123; 21 , 19 &#125;, &#123; 21 , 20 &#125;, &#123; 11 , 2 &#125;, &#123; 13 , 2 &#125;, &#123; 13 , 3 &#125;, &#123; 15 , 3 &#125;, &#123; 16 , 2 &#125;, &#123; 20 , 3&#125;, &#123; 20 , 4 &#125;, &#123; 21 , 5 &#125;, &#123; 22 , 3 &#125;, &#123; 22 , 4 &#125; &#125;; for (i = 0; i &lt; 43; i++) &#123; ncxy[i][0] = ncxy[i][0] + x; ncxy[i][1] = ncxy[i][1] + y; &#125; for (j = 0; j &lt; 43; j++) &#123; jjj = getshu(aaa, j); if (jjj == 1) &#123; setcolor(YELLOW); putpixel(ncxy[j][0], ncxy[j][1], YELLOW); &#125; &#125;&#125;void ifnianchong(unsigned char aaa[49])//随机显示&#123; int judge[43]; int i; for (i = 0; i &lt; 43; i++) &#123; judge[i] = rand() % 2;//显示的概率为 1/2. if (judge[i] == 1) &#123; setshu(aaa, i, 0);//不显示 &#125; else &#123; setshu(aaa, i, 1);//显示 &#125; &#125;&#125;void showbaifen(unsigned char abc[192][49])//白粉病的发病率&#123; int judge = 0; int j; int jia[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//控制y的加的数，使其跳过玉米区域。 int x; int y; int i; int temp; temp = randill(3); x = 0; y = 0; i = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//96*2片区域,,这是24列 &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia[j])//6行 &#123; ifbaifen(abc[i]); j++; judge = rand() % temp; if (judge == 0)// 1/4的概率得病 &#123; baifen(x, y,abc[i]); bai.bfzuobiao[i][0] = x;////储存区域生病的坐标； bai.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;void baifen(int x, int y, unsigned char abc[49])//画出白粉病，适用于俯视图。25*25大小&#123; int i; int j; int jjj; int bfxy[34][2] = &#123; //白色点所有可能的位置 &#123;5, 5&#125;, &#123; 7, 4&#125;, &#123; 9, 5&#125;, &#123; 7, 9&#125;, &#123; 4, 9&#125;, &#123; 4, 14&#125;, &#123; 3, 14&#125;, &#123; 8, 18&#125;, &#123; 8, 19&#125;, &#123; 9, 14&#125;, &#123; 13, 5&#125;, &#123; 13, 6&#125;, &#123; 13, 7&#125;, &#123; 13, 8&#125;, &#123; 13, 14&#125;, &#123; 14, 14&#125;, &#123; 14, 17&#125;, &#123; 14, 20&#125;, &#123; 18, 21&#125;, &#123; 19, 15&#125;, &#123; 20, 11&#125;, &#123; 16, 6&#125;, &#123; 17, 6&#125;, &#123; 18, 3&#125;, &#123; 5, 1 &#125;, &#123; 21 , 1 &#125;, &#123; 21 , 23 &#125;, &#123; 5 ,22 &#125;, &#123; 10 ,22 &#125;, &#123; 1 , 13 &#125;, &#123; 1 , 18 &#125;, &#123; 3 , 11 &#125;, &#123;22 , 9 &#125;, &#123; 23 , 19&#125;//34个点 &#125;; for (i = 0; i &lt; 34; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 34; j++) &#123; jjj = getshu(abc, j); if (jjj == 1) &#123; setcolor(WHITE); putpixel(bfxy[j][0], bfxy[j][1], WHITE); &#125; &#125;&#125;void ifbaifen(unsigned char abc[49])//使得白粉病 设置白点的随机显示&#123; int judge[34]; int i; for (i = 0; i &lt; 34; i++) &#123; judge[i] = rand() % 3;//显示的概率为 2/3.。。 if (judge[i] == 1) &#123; setshu(abc, i, 0);//不显示 &#125; else &#123; setshu(abc, i, 1); &#125; &#125; &#125;//============================================================================================================//============================================================================================================//下面为小农田void showxtbaifen(void)//小农田显示白粉病&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[104][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(3); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;w&quot;); getxtxiao(plantPositions3);//使得小麦坐标到了plantpositions3 for (x = 0; x &lt; 104; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtbaifen(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // fclose(filePointer5); // 关闭文件&#125;void xtbaifen(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[31][2] = &#123; //白色点所有可能的位置 31 &#123; 1 , 2 &#125;, &#123; 2 , 6 &#125;, &#123; 2 , 10 &#125;, &#123; 2 , 13 &#125;, &#123; 1 , 15 &#125;, &#123; 3 , 8 &#125;, &#123; 3 , 18 &#125;, &#123; 4 , 12 &#125;, &#123; 5 , 4 &#125;, &#123; 5 , 8 &#125;, &#123; 5 , 14 &#125;, &#123; 5 , 16 &#125;, &#123; 5 , 17 &#125;, &#123; 7 , 9 &#125;, &#123; 10 , 2 &#125;, &#123; 10 , 3 &#125;, &#123; 10 , 8 &#125;, &#123; 10 , 13 &#125;, &#123; 10 , 17 &#125;, &#123; 12 , 8 &#125;, &#123; 12 , 10 &#125;, &#123; 14 , 6 &#125;, &#123; 14 , 13 &#125;, &#123; 15 , 2 &#125;, &#123; 15 , 16 &#125;, &#123; 18 , 3 &#125;, &#123; 17 , 8 &#125;, &#123; 17 , 13 &#125;, &#123; 18 , 11 &#125;, &#123; 19 , 11 &#125;, &#123; 19 , 17 &#125; &#125;; int ttemp; for (i = 0; i &lt; 31; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 31; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(WHITE); putpixel(bfxy[j][0], bfxy[j][1], WHITE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125; &#125;void showxtnianchong(void)//小农田&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[104][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(3); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;w&quot;); // 以读取模式打开文件 filePointer5 = fopen(&quot;data//xmncdian.dat&quot;, &quot;w&quot;); // 以读取模式打开文件 getxtxiao(plantPositions3);//使得小麦坐标到了plantpositions3 for (x = 0; x &lt; 104; x++)// &#123; judge = rand() % temp; if (judge == 0) &#123; xtnianchong(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // 关闭文件 fclose(filePointer5); &#125;void xtnianchong(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[27][2] = &#123; //黄色点所有可能的位置 27 &#123; 4, 1 &#125;, &#123; 1 , 4 &#125;, &#123; 1 , 8 &#125;, &#123; 1 , 12 &#125;, &#123; 2 , 16 &#125;, &#123; 3 , 15 &#125;, &#123; 7 , 3 &#125;, &#123; 7 , 7 &#125;, &#123; 5 , 11 &#125;, &#123; 7 , 13 &#125;, &#123; 7 , 16 &#125;, &#123; 8 , 16 &#125;, &#123; 7 , 18 &#125;, &#123; 9 , 6 &#125;, &#123; 10 , 6 &#125;, &#123; 9 , 11 &#125;, &#123; 12 , 4 &#125;, &#123; 12 , 15 &#125;, &#123; 12 , 18 &#125;, &#123; 13, 12 &#125;, &#123; 15 , 8 &#125;, &#123; 15 , 10 &#125;, &#123; 17 , 2 &#125;, &#123; 17 , 6 &#125;, &#123; 16, 18 &#125;, &#123; 17 , 18 &#125;, &#123; 18 , 15 &#125; &#125;; int ttemp; for (i = 0; i &lt; 27; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 27; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(YELLOW); putpixel(bfxy[j][0], bfxy[j][1], YELLOW); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtymmian(void)//小农田玉米的棉虫病坐标&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(2); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtymmian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//ymmldian.dat&quot;, &quot;w&quot;); getxtyumi(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtymmian(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // 关闭文件 fclose(filePointer5); // 关闭文件&#125;void xtymmian(int x, int y,FILE* filePointer5)//画出&#123; int i; int j; int bfxy[27][2] = &#123; //蓝色点所有可能的位置 27 &#123; 5 , 6 &#125;, &#123; 5 , 8 &#125;, &#123; 8 , 6 &#125;, &#123; 10 ,5 &#125;, &#123; 12 , 6 &#125;, &#123; 14 , 5 &#125;, &#123; 15 , 7 &#125;, &#123; 14 , 9 &#125;, &#123; 13 , 12 &#125;, &#123; 13 , 14 &#125;, &#123; 10 , 19 &#125;, &#123; 11 , 20 &#125;, &#123; 9 , 23 &#125;, &#123; 14 , 18 &#125;, &#123; 14 , 23 &#125;, &#123; 14 , 26 &#125;, &#123; 13 , 29 &#125;, &#123; 13 , 34 &#125;, &#123; 16 , 29 &#125;, &#123; 16 , 34 &#125;, &#123; 17 , 11 &#125;, &#123; 17 , 22 &#125;, &#123; 19 , 20 &#125;, &#123; 21 , 19 &#125;, &#123; 23 , 18 &#125;, &#123; 24 , 21 &#125;, &#123; 25 , 23 &#125; &#125;; int ttemp; for (i = 0; i &lt; 27; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 27; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(BLUE); putpixel(bfxy[j][0], bfxy[j][1], BLUE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtymnian(void)&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(2); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//ymncdian.dat&quot;, &quot;w&quot;); getxtyumi(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtymnian(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtymnian(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[26][2] = &#123; //蓝色点所有可能的位置 26 &#123; 3 , 10 &#125;, &#123; 4 , 7 &#125;, &#123; 6 , 4 &#125;, &#123; 6 , 6 &#125;, &#123; 8 , 8 &#125;, &#123; 11 , 5 &#125;, &#123; 10, 6 &#125;, &#123; 14 , 3 &#125;, &#123; 16 , 5 &#125;, &#123; 13 , 8 &#125;, &#123; 12 , 10 &#125;, &#123; 24 , 19 &#125;, &#123; 23 , 20 &#125;, &#123; 26 , 24 &#125;, &#123; 16 , 20 &#125;, &#123; 17 , 20 &#125;, &#123; 14 , 20 &#125;, &#123; 9 , 21 &#125;, &#123; 9 , 26 &#125;, &#123; 13 , 25 &#125;, &#123; 15 , 27 &#125;, &#123; 15 , 32 &#125;, &#123; 13 , 31 &#125;, &#123; 14 , 21 &#125;, &#123; 15 , 23 &#125;, &#123; 11 , 21 &#125; &#125;; int ttemp; for (i = 0; i &lt; 26; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 26; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(YELLOW); putpixel(bfxy[j][0], bfxy[j][1], YELLOW); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtmhmian(void)//小农田 棉花的棉铃虫病坐标&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(1); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//mhmldian.dat&quot;, &quot;w&quot;); getxtmianhua(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtmhmian(plantPositions3[i][0], plantPositions3[i][1],filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtmhmian(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[33][2] = &#123; // 33 &#123; 9 , 2 &#125;, &#123; 9 , 5 &#125;, &#123; 8 , 6 &#125;, &#123; 11 , 3 &#125;, &#123; 12 , 6 &#125;, &#123; 11 , 9 &#125;, &#123; 5 , 12 &#125;, &#123; 4 , 14 &#125;, &#123; 6 , 15 &#125;, &#123; 9 , 15 &#125;, &#123; 5 , 18 &#125;, &#123; 11 , 16 &#125;, &#123; 12 , 13 &#125;, &#123; 13 , 20 &#125;, &#123; 12 , 23 &#125;, &#123; 11 , 25 &#125;, &#123; 13 , 25 &#125;, &#123; 12 , 27 &#125;, &#123; 12 , 29 &#125;, &#123; 16 , 2 &#125;, &#123; 16 , 4 &#125;, &#123; 14 , 5 &#125;, &#123; 15 , 8 &#125;, &#123; 13 , 9 &#125;, &#123; 13 , 11 &#125;, &#123; 17 , 6 &#125;, &#123; 19 , 6 &#125;, &#123; 20 , 8 &#125;, &#123; 19 , 12 &#125;, &#123; 18 , 15 &#125;, &#123; 20 , 15 &#125;, &#123; 19 , 18 &#125;, &#123; 21 , 18 &#125; &#125;; int ttemp; for (i = 0; i &lt; 33; i++) &#123; bfxy[i][0] = bfxy[i][0] + x-1; bfxy[i][1] = bfxy[i][1] + y+1; &#125; for (j = 0; j &lt; 33; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(BLUE); putpixel(bfxy[j][0], bfxy[j][1], BLUE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtmhxiu(void)&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(1); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;w&quot;); getxtmianhua(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtmhxiu(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtmhxiu(int x, int y, FILE* filePointer5)//&#123; int i; int j; int bfxy[35][2] = &#123; //洋红色点所有可能的位置 35 &#123; 8 , 0 &#125;, &#123; 6 , 5 &#125;, &#123; 5 , 6 &#125;, &#123; 4 , 16 &#125;, &#123; 6 , 13 &#125;, &#123; 8 , 14 &#125;, &#123; 7 , 17 &#125;, &#123; 11 , 1 &#125;, &#123; 10 , 2 &#125;, &#123; 10 , 8 &#125;, &#123; 10 , 7 &#125;, &#123; 11 , 12 &#125;, &#123; 11 , 15 &#125;, &#123; 11 , 18 &#125;, &#123; 11 , 20 &#125;, &#123; 11 , 22 &#125;, &#123; 11 , 31 &#125;, &#123; 12 , 32 &#125;, &#123; 12 , 10 &#125;, &#123; 13 , 15 &#125;, &#123; 13 , 16 &#125;, &#123; 13 , 18 &#125;, &#123; 13 , 22 &#125;, &#123; 13 , 30 &#125;, &#123; 14 , 10 &#125;, &#123; 16 , 9 &#125;, &#123; 18 , 4 &#125;, &#123; 18 , 8 &#125;, &#123; 20 , 6 &#125;, &#123; 17 , 13 &#125;, &#123; 18 , 17 &#125;, &#123; 19 , 14 &#125;, &#123; 19 , 16 &#125;, &#123; 21 , 14 &#125;, &#123; 21 , 17 &#125; &#125;; int ttemp; for (i = 0; i &lt; 35; i++) &#123; bfxy[i][0] = bfxy[i][0] + x-1; bfxy[i][1] = bfxy[i][1] + y+1; &#125; for (j = 0; j &lt; 35; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(LIGHTRED); putpixel(bfxy[j][0], bfxy[j][1], LIGHTRED); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125; 其实这里有很多重复的代码和东西，一个农田只看一种植物的一种病就可以了。。其他都是复制粘贴的，说实话。建议不用细看，因为颜色点的随机显示，老师根本不注重，而且不会细看。。。现在让我自己看，我也看不懂 。 recover123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;common.h&quot;//===========================//大农田里面的部分植物自愈//===========================void recover(void)//完全随机重新刷新；；&#123; int j;//跳过区域用 int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//跳过玉米区域。 int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//跳过小麦区域。 int x, y;//循环 int i = 0;//调用患病植株坐标 int ii;//同上 int judge = 0;//恢复比例的分子 int temp1, temp2;//自愈比例分母 temp1 = randrecover(0);//小麦自愈比例 temp2 = randrecover(1);//玉米自愈比例 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域, &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j])// &#123; j++; judge = rand() % temp1;// if (judge == 0)// &#123; setcolor(BROWN); setfillstyle(1, BROWN); bar(x, y, x + 25, y + 25);//矩形覆盖原生病植物。再画健康植物 fxiaomai(x, y); nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][1] = 0; bai.bfzuobiao[i][0] = 0; bai.bfzuobiao[i][1] = 0;//使其为0；表示其恢复健康。 i++; &#125; else i++; &#125; &#125; i = 192; ii = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域 &#123; j = -1; for (y = 65 + 50; y &lt; 465; y = y + jia2[j])// &#123; j++; judge = rand() % temp2;// if (judge == 0)// &#123; setcolor(BROWN); setfillstyle(1, BROWN); bar(x, y, x + 25, y + 25); fyumi(x,y); mian.bfzuobiao[ii][0] = 0; mian.bfzuobiao[ii][1] = 0;//使其为0，表示健康 nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][1] = 0;// i++; ii++; &#125; else &#123; i++;//表示仍然患病，跳过 ii++; &#125; &#125; &#125;&#125;int randrecover(int k)//恢复比例分配&#123; int i; int a[2][10] = &#123; &#123;1,1,2,2,2,2, 2,3,3,4&#125;,//小麦 &#123;1,1,2,2,2,2, 2,3,3,4&#125;//玉米的 &#125;; i = rand() % 10; return a[k][i];&#125; 这里的生病、自愈都是完全用随机数搞的，但实际上验收老师就看了一两遍无人机扫描结果，所以根本没有用。。。 elsetian123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577#include &quot;common.h&quot;// 画植物，均为左上角坐标。void drawPlants(void)&#123; // 绘制固定位置的植物 int i; //玉米的坐标30*35 int plantPositions1[][2] =//直接穷举法列举出植物坐标 &#123; //梯田那部分。11个 &#123;100,100&#125;, &#123; 3 , 92 &#125;, &#123; 73 , 89 &#125;, &#123; 46 , 171 &#125;, &#123; 138 , 213 &#125;, &#123; 99 , 154 &#125;, &#123; 120 , 151 &#125;, &#123; 9 , 120 &#125;, &#123; 65 , 140 &#125;, &#123; 158 , 156 &#125;, &#123; 89 , 199 &#125;,//最右上角一块 5 &#123; 501 , 238 &#125;, &#123; 598 , 265 &#125;, &#123; 598 , 227 &#125;, &#123; 574 , 144 &#125;, &#123; 544 ,132 &#125;,// 第三块 18 &#123; 350 , 95 &#125;, &#123; 356 , 132 &#125;, &#123; 366 , 168 &#125;, &#123; 379 , 204 &#125;, &#123; 392 , 243&#125;, &#123; 469 , 100&#125;, &#123; 470 , 139 &#125;, &#123; 470 , 215 &#125;, &#123; 470 , 175 &#125;, &#123; 470 , 254 &#125;, &#123; 473 , 294 &#125;, &#123; 416 , 265 &#125;, &#123; 447 , 291 &#125;, &#123; 405 , 197 &#125;, &#123; 416 , 231 &#125;, &#123; 445 , 254 &#125;, &#123; 438 , 220 &#125;, &#123; 452 , 191 &#125;, // 最上面区域 6个 &#123; 0,256 &#125;, &#123; 31 , 283 &#125;, &#123; 66 , 291 &#125;, &#123; 149 , 281 &#125;, &#123; 120 , 289 &#125;, &#123; 94 , 293 &#125;, &#123; 105 , 330 &#125;, &#123; 108 , 367 &#125;, &#123; 118 , 437 &#125;, &#123; 111 , 402 &#125;, &#123; 55 , 326 &#125;, &#123; 69 , 421 &#125;, &#123; 67 , 358 &#125;, &#123; 177 , 321 &#125;, &#123; 181 , 349 &#125;, &#123; 188, 414 &#125;, &#123; 195 , 380 &#125;, &#123; 207 , 329 &#125;, &#123; 212 , 365 &#125;, &#123; 212, 411 &#125;, &#123; 232 , 330 &#125;, &#123; 236 , 366 &#125;, &#123; 236 , 443 &#125;, &#123; 236 , 405 &#125;, &#123; 608 , 380 &#125;, &#123; 592 , 411 &#125;, &#123; 611 , 442 &#125;, &#123; 328 , 443 &#125;, &#123; 371 , 406 &#125;, &#123; 376 , 369 &#125;, &#123; 379 , 332 &#125;, &#123; 337 , 406 &#125;, &#123; 337 , 369 &#125;, &#123; 346 , 332 &#125; &#125;; //棉花的20*35 int plantPositions2[][2] = &#123; //梯田那部分。12个 &#123; 31 , 89 &#125;, &#123; 53 , 85 &#125;, &#123; 123 , 111 &#125;, &#123; 75 , 182 &#125;, &#123; 115 , 193 &#125;, &#123; 165 , 198 &#125;, &#123; 147 , 136 &#125;, &#123; 45 , 117 &#125;, &#123; 28 , 145 &#125;, &#123; 90 , 123 &#125;, &#123; 141 , 176 &#125;, &#123; 502 , 90 &#125;, &#123; 502 , 305 &#125;, &#123; 502 , 129 &#125;, &#123; 502 , 157 &#125;, &#123; 502 , 199 &#125;, &#123; 502 , 278 &#125;, &#123; 530 , 315 &#125;, &#123; 605 , 305 &#125;, &#123; 582 , 308 &#125;, &#123; 556 , 311 &#125;, &#123; 521 , 103 &#125;, &#123; 585 , 123 &#125;, &#123; 605 , 129 &#125;, //中间 23 &#123; 283 , 87 &#125;, &#123; 304 , 87 &#125;, &#123; 284, 128 &#125;, &#123; 271 , 153 &#125;, &#123; 306 , 125 &#125;, &#123; 316 , 156 &#125;, &#123; 259 , 181 &#125;, &#123; 249 , 218&#125;, &#123; 326, 194 &#125;, &#123; 283 , 181 &#125;, &#123; 305 , 188 &#125;, &#123; 279 , 222 &#125;, &#123; 305 , 227 &#125;, &#123; 335 , 228 &#125;, &#123; 364 , 271 &#125;, &#123; 340, 284 &#125;, &#123; 317, 290 &#125;, &#123; 296 , 293 &#125;, &#123; 443 , 155 &#125;, &#123; 416, 148 &#125;, &#123; 427 , 177&#125;, &#123; 320 , 252 &#125;, &#123; 264 , 331 &#125;, &#123; 265 , 369 &#125;, &#123; 264 , 443 &#125;, &#123; 264, 406 &#125;, &#123; 286 , 331 &#125;, &#123; 287 , 369 &#125;, &#123; 286 , 406 &#125;, &#123; 285 , 443 &#125;, &#123; 314 , 332 &#125;, &#123; 309 , 443 &#125;, &#123; 310 , 405 &#125;, &#123; 308 , 368 &#125;, &#123; 583 , 365 &#125;, &#123; 517 , 406 &#125;, &#123; 493 , 439 &#125;, &#123; 517 , 442 &#125;, &#123; 574 , 440 &#125;, &#123; 547 , 442 &#125;, &#123; 538 , 403 &#125;, &#123; 565 , 403 &#125;, &#123; 550 , 366 &#125;, &#123; 360 , 443 &#125; &#125;; //小麦占地.20*19 总共104个 int plantPositions3[][2] = &#123; //最右上角一块 &#123; 607 , 166 &#125;, &#123; 609 , 189 &#125;, &#123; 604 , 210 &#125;, &#123; 525 , 144 &#125;, &#123; 532 , 167 &#125;, &#123; 524 , 189 &#125;, &#123; 544 , 189 &#125;, &#123; 562 , 189 &#125;, &#123; 586 , 183&#125;, &#123; 556 , 170 &#125;, &#123; 526 , 212 &#125;, &#123; 548 , 212 &#125;, &#123; 569 , 212 &#125;, &#123; 584 , 204 &#125;, &#123; 534 , 237 &#125;, &#123; 559 , 236 &#125;, &#123; 532 , 265 &#125;, &#123; 527 , 290 &#125;, &#123; 555 , 285 &#125;, &#123; 579 , 283 &#125;, &#123; 553 , 259 &#125;, &#123; 576 , 262 &#125;, &#123; 581 , 240 &#125;, // 中间 &#123; 260 , 104 &#125;, &#123; 257 , 128 &#125;, &#123; 249 , 153 &#125;, &#123; 242 , 178 &#125;, &#123; 234 , 202 &#125;, &#123; 227 , 226 &#125;, &#123; 220 , 250 &#125;, &#123; 213 , 274 &#125;, &#123; 230 , 275 &#125;, &#123; 230 , 299&#125;, &#123; 327 , 104 &#125;, &#123; 330 , 128 &#125;, &#123; 336 , 151 &#125;, &#123; 344 , 174 &#125;, &#123; 351 , 198 &#125;, &#123; 357 , 222 &#125;, &#123; 364 , 247 &#125;, //第三块 8 &#123; 385 , 106 &#125;, &#123; 410 , 108 &#125;, &#123; 434 , 108 &#125;, &#123; 389 , 133 &#125;, &#123; 415 , 134 &#125;, &#123; 445 , 135 &#125;, &#123; 393, 161 &#125;, // 整个上区域 20 &#123;231 , 107 &#125;, &#123; 228 , 130 &#125;, &#123; 222 , 152 &#125;, &#123; 215 , 173 &#125;, &#123; 207 , 197 &#125;, &#123; 200 , 223 &#125;, &#123; 190 , 249 &#125;, &#123; 182 , 271 &#125;, &#123; 194 , 288 &#125;, &#123; 204 , 108 &#125;, &#123; 176 , 108 &#125;, &#123; 150 , 107 &#125;, &#123; 169 , 132 &#125;, &#123; 196 , 132 &#125;, &#123; 188 , 154 &#125;, &#123; 192 , 176 &#125;, &#123; 33 , 261 &#125;, &#123; 59 , 272 &#125;, &#123; 83 , 275 &#125;, &#123; 2 , 235 &#125;, //所有下方区域 32 &#123; 131 , 330 &#125;, &#123; 133 , 353 &#125;, &#123; 137, 377 &#125;, &#123; 142 , 401 &#125;, &#123; 146 , 425 &#125;, &#123; 146 , 450 &#125;, &#123; 157 , 331 &#125;, &#123; 159 , 353 &#125;, &#123; 162 , 378 &#125;, &#123; 167 , 402 &#125;, &#123; 170 , 425&#125;, &#123; 168 , 455 &#125;, &#123; 10 , 342 &#125;, &#123; 22 , 365 &#125;, &#123; 29 , 392 &#125;, &#123; 21 , 437 &#125;, &#123; 28 , 415 &#125;, &#123; 36 , 337 &#125;, &#123; 47 , 361 &#125;, &#123; 53 , 387 &#125;, &#123; 54 , 411 &#125;, &#123; 52 , 434 &#125;, &#123; 465 , 378 &#125;, &#123; 470 , 406 &#125;, &#123; 469 , 432 &#125;, &#123; 469 , 456 &#125;, &#123; 443 , 391 &#125;, &#123; 445 , 415 &#125;, &#123; 443 , 444 &#125;, &#123; 420 , 412&#125;, &#123; 419 , 447 &#125;, &#123; 393 , 455 &#125;, &#123; 88 , 341 &#125;, &#123;90,384 &#125;, &#123;72 ,399 &#125;, &#123;93 ,413 &#125;, &#123; 97,437 &#125; &#125;; for (i = 0; i &lt; sizeof(plantPositions1) / sizeof(plantPositions1[0]); i++)//画植物 &#123; yumi(plantPositions1[i][0], plantPositions1[i][1]); &#125; for (i = 0; i &lt; sizeof(plantPositions2) / sizeof(plantPositions2[0]); i++)// &#123; mianhua(plantPositions2[i][0], plantPositions2[i][1]); &#125; for (i = 0; i &lt; sizeof(plantPositions3) / sizeof(plantPositions3[0]); i++) &#123; xiaomaikuai(plantPositions3[i][0], plantPositions3[i][1]); &#125; setxtzhiwu(plantPositions1, plantPositions2, plantPositions3);//记录植物的坐标&#125;//============================================================//小农田主界面int elsetian(int* a5)&#123; srand(time(NULL)); if (*a5 == 1)//绘图 &#123; cleardevice(); clrmous(MouseX, MouseY); drawBackground(); //梯田 bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 *a5 = 0; &#125; //============= //恢复农田 if (*a5 == -1) &#123; cleardevice(); clrmous(MouseX, MouseY); drawBackground(); bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 binghai(); *a5 = 2; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(100, 5, 100 + 140, 50); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a5 = 1; return 1;//返回前一个界面 &#125; else if (mouse_press(100, 5, 240, 50) == 1) &#123; delay(100); clrmous(MouseX, MouseY); grow();//无人机动画的实现 if (*a5 == 2 || *a5 == -1) &#123; delay(200); cleardevice(); clrmous(MouseX, MouseY); drawBackground(); bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 &#125; showxtbaifen(); showxtnianchong(); showxtymmian(); showxtymnian(); showxtmhxiu(); showxtmhmian(); *a5 = 2; &#125; if (*a5 == 2 || *a5 == -1) &#123; showbiankuang(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); showbiankuang(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); if (mouse_press(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50) == 1) &#123; *a5 = -1; delay(100); return 5;//结果查看部分 &#125; else if (mouse_press(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50) == 1) &#123; *a5 = -1; delay(100); return 7;//准备喷洒部分 &#125; &#125; return 3;&#125;// 画稻草人void drawScarecrow(int x, int y)&#123; setcolor(BROWN); setfillstyle(SOLID_FILL, YELLOW); fillellipse(x, y, 10, 10); setfillstyle(SOLID_FILL, DARKGRAY); fillellipse(x, y - 5, 15, 5); setfillstyle(SOLID_FILL, BLACK); fillellipse(x - 3, y + 2, 2, 2); fillellipse(x + 3, y + 2, 2, 2); setfillstyle(SOLID_FILL, YELLOW); bar(x - 5, y + 10, x + 5, y + 60); bar(x - 20, y + 10, x - 5, y + 15); bar(x + 5, y + 10, x + 20, y + 15); bar(x - 2, y + 60, x + 2, y + 80);&#125;void drawdxg(int x, int y)//电线杆&#123; setcolor(LIGHTGRAY); setfillstyle(SOLID_FILL, LIGHTGRAY); bar(14 + x, y, 18 + x, 83 + y); line(x + 0, y +26 , x +25 , y +18 ); line(x +25 , y +18 , x +25 , y +21 ); line(x + 25, y + 21, x +0 , y +29 ); line(x + 0, y +29 , x +0 , y +26 ); floodfill(x+8, y+25, LIGHTGRAY); floodfill(x+21,y+ 20, LIGHTGRAY); line(x + 3, y +6 , x + 27, y + 13); line(x + 27, y +13 , x +27 , y +17 ); line(x + 27, y +17 , x +1 , y +9 ); line(x + 1, y +9 , x + 2, y + 6); line(x + 2, y +6 , x + 3, y + 6); floodfill(x + 10, y + 9, LIGHTGRAY); floodfill(x + 20, y + 13, LIGHTGRAY);&#125;// 画不规则形状的农田void tian(void)&#123; int points1[] = &#123; 150,480,130,335, 285,480 - 130,405,335,400,430,500,370,640,405,640,480 &#125;;//最下面中间的 int points2[] = &#123; 400,280,500,360, 640,340,640,116,200,116,200,280 &#125;;//上面的 setcolor(BROWN); setfillstyle(1, BROWN); arc(-62, 420, 0, 360, 90); arc(70, 560, 0, 360, 105); line(140, 480, 125, 335); line(125, 335, 0, 352); floodfill(100, 420, BROWN);//左下角的 fillpoly(8, points1);//多边形绘制 fillpoly(6, points2);//多边形绘制 line(0, 280, 210, 280); ellipse(100, 280, 180, 360, 100, 50);//椭圆 floodfill(100, 290, BROWN); line(0 + 200, 280, 210 + 200 - 10, 280); ellipse(100 + 200, 280, 180, 360, 100, 50);//椭圆 floodfill(100 + 200, 290, BROWN); line(150, 280 + 20 + 10, 280, 300 + 10); floodfill(200, 290, BROWN); line(400, 280, 500, 360); line(500, 360, 640, 340); line(640, 340, 640, 116); line(110, 116, 640, 116); line(200, 116, 200, 280); line(200, 280, 400, 280); line(400, 280, 500, 360); line(500, 360, 640, 340); line(640, 340, 640, 116); line(110, 116, 640, 116); line(200, 116, 200, 280); line(200, 280, 400, 280); setfillstyle(1, BLUE); floodfill(630, 350, BROWN); floodfill(10, 400, BROWN); floodfill(100, 470, BROWN); setcolor(WHITE); line(208, 280, 258, 116); line(400, 280 + 1, 350, 116); line(500, 360 - 1, 500, 116); setfillstyle(1, GREEN); setcolor(GREEN); line(0, 98, 640, 98);//分割线 line(630, 116, 640, 116); line(640, 116, 640, 340); line(640, 340, 630, 342); line(630, 342, 630, 116); floodfill(632, 120, GREEN);&#125;void binghai(void)//画病害&#123; int row; FILE* filePointer1; FILE* filePointer2; FILE* filePointer3; FILE* filePointer4; FILE* filePointer5; FILE* filePointer6; int a22[68 * 35][2] = &#123; 0 &#125;; int a11[103 * 31][2] = &#123; 0 &#125;; filePointer1 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 103 * 31; row++) &#123; fscanf(filePointer1, &quot;%d %d&quot;, &amp;a11[row][0], &amp;a11[row][1]); &#125; fclose(filePointer1); for (row = 0; row &lt; 103 * 31; row++)// &#123; setcolor(WHITE); putpixel(a11[row][0], a11[row][1], WHITE); &#125; for (row = 0; row &lt; 103 * 31; row++) &#123; a11[row][0] = 0; a11[row][1] = 0; &#125; filePointer2 = fopen(&quot;data//xmncdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 103 * 31; row++) &#123; fscanf(filePointer2, &quot;%d %d&quot;, &amp;a11[row][0], &amp;a11[row][1]); &#125; for (row = 0; row &lt; 103 * 31; row++) &#123; setcolor(YELLOW); putpixel(a11[row][0], a11[row][1], YELLOW); &#125; fclose(filePointer2); filePointer3 = fopen(&quot;data//ymncdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(YELLOW); putpixel(a22[row][0], a22[row][1], YELLOW); &#125; fclose(filePointer3); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer4 = fopen(&quot;data//ymmldian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer4, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(BLUE); putpixel(a22[row][0], a22[row][1], BLUE); &#125; fclose(filePointer4); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer5 = fopen(&quot;data//mhmldian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer5, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(BLUE); putpixel(a22[row][0], a22[row][1], BLUE); &#125; fclose(filePointer5); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer6 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer6, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(LIGHTRED); putpixel(a22[row][0], a22[row][1], LIGHTRED); &#125; fclose(filePointer6);&#125; 类似大农田，实现的功能类似。加了个显示高度的功能。好累啊，自己看吧 outcome.h1234567891011121314#ifndef _OUTCOME_H_#define _OUTCOME_H_//=大农田的 结果查看int outcome(int* a3);//核心void draw111(void);//普通绘图void xiaomaioutcome(void);//小麦结果void yumioutcome(void);//玉米结果//=====================================int elseoutcome(int* a3);void draw222(void);void elseyumioutcome(void);void elsexiaomaioutcome(void);void elsemianhuaoutcome(void);#endif outcome.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731#include&quot;common.h&quot;/*=========================大农田小麦结果查看===========================*/void xiaomaioutcome(void)&#123; int y2, y3, y4; int i; double yt; char string[20]; yt = 0; y2 = 0; y3 = 0; y4 = 0; draw111(); setcolor(GREEN); line(64, 419, 563, 419); line(556-5, 406, 563, 419); line(563, 419, 556-5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总小麦面积比例&quot;, 16, 15, GREEN); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419-150, 65, 419 - 150); outtextxy(15, 419 - 150-9, &quot;50%&quot;); line(63, 419-75, 65, 419 - 75); outtextxy(15, 419 - 75-9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225-9, &quot;75%&quot;); line(84, 418, 84, 420); line(84+70, 418, 84+70, 420); puthz(84+20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84+70+30, 418, 84+70+30, 420); line(84 + 70 + 30+70, 418,84 + 70 + 30+70, 420); puthz(84+70+30+5, 430, &quot;患白粉病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70+30, 418, 84 + 70 + 30 + 70+30, 420); line(84 + 70 + 30 + 70 + 30+70, 418, 84 + 70 + 30 + 70+70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30+5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70+30, 418, 84 + 70 + 30 + 70 +30+ 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70+70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 +70+ 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 192; i++) &#123; if (bai.bfzuobiao[i][0] == 0 &amp;&amp; bai.bfzuobiao[i][1] == 0&amp;&amp; nian.bfzuobiao[i][0] == 0 &amp;&amp; nian.bfzuobiao[i][1]==0) &#123; yt+=1; &#125; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; y2++; &#125; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; y3++; &#125; if(bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0&amp;&amp; nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; y4++; &#125; &#125; setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 192, 84 + 70, 419); sprintf(string, &quot;%.lf/192&quot;, yt); outtextxy(84, 419 - (yt * 300) / 192-20, string); bar(84 + 100 + 70,419 - (y2 * 300) / 192, 84 + 100, 419 ); sprintf(string, &quot;%d/192&quot;, y2); outtextxy(84 + 100 , 419 - (y2 * 300) / 192-20, string); bar( 84 + 270, 419 - (y3 * 300) / 192, 84 + 200, 419); sprintf(string, &quot;%d/192&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 192-20, string); bar(84 +370, 419 - (y4 * 300) / 192,84 + 300, 419 ); sprintf(string, &quot;%d/192&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 192-20, string); if (yt &gt;= 192 - 8) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 15) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 25) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 35) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 60) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================大农田结果查看===========================*/int outcome(int* a3)&#123; if (*a3 == 1) &#123; cleardevice(); draw111(); *a3 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(311 - 25, 3, 421, 37); showbiankuang(442, 3, 546 + 25, 37); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; delay(100); return 2;//返回前一个界面 &#125; else if (mouse_press(311 - 25, 3, 421, 35) == 1&amp;&amp;( *a3==0 || *a3== 3)) &#123; *a3 = 2; cleardevice(); delay(100); xiaomaioutcome(); //小麦的 &#125; else if (mouse_press(442, 3, 546 + 25, 35) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2)) &#123; *a3 = 3; cleardevice(); delay(100); yumioutcome(); //玉米的 &#125; return 6;&#125;/*=========================小农田结果查看===========================*/int elseoutcome(int* a3)&#123; if (*a3 == 1) &#123; cleardevice(); draw222(); *a3 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(197, 3, 325, 37); showbiankuang(329, 3, 455, 37); showbiankuang(461, 3, 586, 37); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; delay(100); return 3;//返回前一个界面 &#125; else if (mouse_press(197, 3, 325, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 3 || *a3 == 4)) &#123; *a3 = 2; cleardevice(); delay(100); elsexiaomaioutcome(); //小麦的 &#125; else if (mouse_press(329, 3, 455, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2 || *a3 == 4)) &#123; *a3 = 3; cleardevice(); delay(100); elseyumioutcome(); //玉米的 &#125; else if (mouse_press(461, 3, 586, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2 || *a3 == 3)) &#123; *a3 = 4; cleardevice(); delay(100); elsemianhuaoutcome(); //棉花的 &#125; return 5;&#125;/*=========================小农田小麦结果查看===========================*/void elsexiaomaioutcome(void)&#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2] ; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 filePointer12 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); //坐标轴绘制 setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总小麦面积比例&quot;, 16, 15, GREEN); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;患白粉病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); //统计植物病虫害情况。 for (i = 0; i &lt; 103; i++) &#123; int a, b; a=fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]) ; b=fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]) ; if (a==2) &#123; y2++; &#125; if ( b== 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt;y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 103 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); //坐标轴。柱形图 setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 103, 84 + 70, 419); sprintf(string, &quot;%.lf/103&quot;, yt); outtextxy(84, 419 - (yt * 300) / 103 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 103, 84 + 100, 419); sprintf(string, &quot;%d/103&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 103 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/103&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 103 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/103&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 103 - 20, string); //显示总体评价 if (yt &gt;= 103 - 7) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 13) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 20) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 30) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 50) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================小农田玉米结果查看===========================*/void elseyumioutcome(void) &#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2]; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtymnian.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 filePointer12 = fopen(&quot;data//xtymmian.dat&quot;, &quot;r&quot;); yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;玉米生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总玉米株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 68; i++) &#123; int a, b; a = fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]); b = fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]); if (a == 2) &#123; y2++; &#125; if (b == 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt; y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 68 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 68, 84 + 70, 419); sprintf(string, &quot;%.lf/68&quot;, yt); outtextxy(84, 419 - (yt * 300) / 68 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 68, 84 + 100, 419); sprintf(string, &quot;%d/68&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 68 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/68&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 68 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/68&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 68 - 20, string); if (yt &gt;= 68 -5) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 10) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 14) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 20) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 40) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================小农田棉花结果查看===========================*/void elsemianhuaoutcome(void)&#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2]; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;r&quot;); filePointer12 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;r&quot;); yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;棉花生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总棉花株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;患上锈病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 68; i++) &#123; int a, b; a = fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]); b = fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]); if (a == 2) &#123; y2++; &#125; if (b == 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt; y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 68 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 68, 84 + 70, 419); sprintf(string, &quot;%.lf/68&quot;, yt); outtextxy(84, 419 - (yt * 300) / 68 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 68, 84 + 100, 419); sprintf(string, &quot;%d/68&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 68 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/68&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 68 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/68&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 68 - 20, string); if (yt &gt;= 68 - 5) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 9) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68- 15) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 25) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 34) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================绘制大农田普适背景===========================*/void draw111(void)&#123; setbkcolor(WHITE); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); line(0, 40, 640, 40); setfillstyle(1, WHITE); bar(90, 1, 140, 22); setcolor(GREEN); puthz(90 + 2, 1 + 2, &quot;白粉病&quot;, 16, 15, GREEN); setfillstyle(1, BLUE); bar(145, 1, 195, 22); puthz(145 + 2, 1 + 2, &quot;棉铃虫&quot;, 16, 15, GREEN); setfillstyle(1, YELLOW); bar(200, 1, 250, 22); puthz(200 + 2, 1 + 2, &quot;黏虫病&quot;, 16, 15, GREEN); setfillstyle(1, GREEN); bar(311 - 25, 3, 421, 37); bar(442, 3, 546 + 25, 37); puthz(311 - 25 + 2, 3, &quot;小麦情况&quot;, 32, 30, WHITE); puthz(442 + 2, 3, &quot;玉米情况&quot;, 32, 30, WHITE);&#125;/*=========================绘制小农田普适背景===========================*/void draw222(void)&#123; setbkcolor(WHITE); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); line(0, 40, 640, 40); setfillstyle(1, WHITE); bar(90, 0, 140, 19); setcolor(GREEN); puthz(90 + 2, 0 + 2, &quot;白粉病&quot;, 16, 15, GREEN); setfillstyle(1, BLUE); bar(145, 0, 195, 19); puthz(145 + 2, 0 + 2, &quot;棉铃虫&quot;, 16, 15, GREEN); setfillstyle(1, YELLOW); bar(90, 19, 140, 38); puthz(90 + 2, 19 + 2, &quot;黏虫病&quot;, 16, 15, GREEN); setfillstyle(1, LIGHTRED); bar(145, 19, 195, 38); puthz(145 + 2, 19 + 2, &quot;锈病&quot;, 16, 15, GREEN); setfillstyle(1, GREEN); bar(197, 3, 325, 37); bar(329, 3, 455, 37); bar(461, 3, 586, 37); puthz(197 + 2, 3, &quot;小麦情况&quot;, 32, 30, WHITE); puthz(329 + 2, 3, &quot;玉米情况&quot;, 32, 30, WHITE); puthz(461 + 2, 3, &quot;棉花情况&quot;, 32, 30, WHITE);&#125;/*=========================大农田玉米结果查看===========================*/void yumioutcome(void)&#123; int y2, y3, y4; int i; double y1; char string[20]; int j; y1 = 0; y2 = 0; y3 = 0; y4 = 0; draw111(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;玉米生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占玉米总株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); //统计各个植物的患病情况 for (i = 0, j = 192; i &lt; 192, j &lt; 384; i++, j++) &#123; if (mian.bfzuobiao[i][0] == 0 &amp;&amp; mian.bfzuobiao[i][1] == 0 &amp;&amp; nian.bfzuobiao[j][0] == 0 &amp;&amp; nian.bfzuobiao[j][1] == 0) &#123; y1 += 1;//无病 &#125; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; y2++; &#125; if (nian.bfzuobiao[j][0] != 0 &amp;&amp; nian.bfzuobiao[j][1] != 0) &#123; y3++; &#125; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0 &amp;&amp; nian.bfzuobiao[j][0] != 0 &amp;&amp; nian.bfzuobiao[j][1] != 0) &#123; y4++;//二者均患 &#125; &#125; //绘制坐标轴，以及显示柱形图 setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (y1 * 300) / 192, 84 + 70, 419); sprintf(string, &quot;%.lf/192&quot;, y1); outtextxy(84, 419 - (y1 * 300) / 192 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 192, 84 + 100, 419); sprintf(string, &quot;%d/192&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 192 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 192, 84 + 200, 419); sprintf(string, &quot;%d/192&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 192 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 192, 84 + 300, 419); sprintf(string, &quot;%d/192&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 192 - 20, string); //显示生长状态 if (y1 &gt;= 192 - 8)//8 &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 15)//15 &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 25)//25 &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 35)//35 &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 60)//60 &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN); &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN); &#125;&#125; 看起来很复杂，其实很简单，就是一个画柱形图的功能。。。。 好累，你自己看吧 growlook无人机动画核心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551#include &quot;common.h&quot;/*===========================================生长检测部分1。这里仅仅只是实现了动画效果。如，无人机的动画，植物范围的变色，不同的颜色代表了不同的病虫害。具体数据要到结果查看部分。=============================================*/void grow(void)//将两个农田的无人机运动合为一体化&#123; if (getpixel(20, 65) == BROWN)//根据这个判断两个农田.这个是平地农田 &#123; dronemove1(); &#125; else// (getpixel(20,65) == WHITE) //这个是小农田 &#123; dronemove2(); &#125;&#125;//小农田无人机动画void move21(int points[][2], int num_points, int x, int y, int* buffer)&#123; int i; int barrier[2][2] = &#123; 0 &#125;;//障碍物 int barrier1[2][2] = &#123; 0 &#125;; int barrier2[2][2] = &#123; 0 &#125;; int xiao[103][2]; int yu[68][2]; int mian[68][2]; getxtxiao(xiao); getxtyumi(yu); getxtmianhua(mian); barrier[0][0] = 249; barrier[0][1] = 239; barrier[1][0] = 278; barrier[1][1] = 324; barrier1[0][0] = 480; barrier1[0][1] = 326 - 10; barrier1[1][0] = 519; barrier1[1][1] = 415 ; barrier2[0][0] = 549; barrier2[0][1] = 49; barrier2[1][0] = 589; barrier2[1][1] = 141; srand(time(NULL)); // 初始化随机种子 for (i = 0; i &lt; num_points; i++) &#123; int target_x = points[i][0]; // 获取当前目标点的x坐标 int target_y = points[i][1]; // 获取当前目标点的y坐标 int j; int dx = 0; int dy = 0; int xxx = 2; int yyy = 2; int judge; int xmax, ymax, xmin, ymin; int randx[400] = &#123; 0 &#125;; int randy[400] = &#123; 0 &#125;; int randfuzhi; int rand_numbers[400] = &#123; 0 &#125;; // 数组用于存储生成的随机数 int canshu1; int canshu2; int judgee; int movebar[2][2] = &#123; 0 &#125;; if ((target_x - x) &gt;= 0)//判断目标点 &#123; xxx = 0; &#125; else if ((target_x - x) &lt; 0) &#123; xxx = 1; &#125; if ((target_y - y) &gt;= 0) &#123; yyy = 0; &#125; else if ((target_y - y) &lt; 0) &#123; yyy = 1; &#125; if (abs(target_x - x) &gt;= abs(target_y - y)) &#123; for (randfuzhi = 0; randfuzhi &lt; abs((target_x - x) / 2); randfuzhi++) &#123; randx[randfuzhi] = 2;//控制速度 ====================================== randy[randfuzhi] = 0; &#125; for (randfuzhi = 0; randfuzhi &lt; abs((target_y - y) / 2); randfuzhi++) &#123; while (1) &#123; judgee = 1; canshu1 = rand() % (abs(target_y - y) / 2) + 1; for (j = 0; j &lt; randfuzhi; j++) &#123; if (rand_numbers[j] == canshu1) &#123; judgee = 0; &#125; &#125; if (judgee == 1) &#123; break; &#125; &#125; rand_numbers[randfuzhi] = canshu1; // 将生成的随机数标记为已使用 randy[canshu1 - 1] = 2; &#125; &#125; else if (abs(target_x - x) &lt; abs(target_y - y)) &#123; for (randfuzhi = 0; randfuzhi &lt; abs((target_y - y) / 2); randfuzhi++) &#123; randx[randfuzhi] = 0;//控制速度 ====================================== randy[randfuzhi] = 2; &#125; for (randfuzhi = 0; randfuzhi &lt; abs((target_x - x) / 2); randfuzhi++) &#123; while (1) &#123; judgee = 1; canshu2 = rand() % (abs(target_x - x) / 2) + 1; for (j = 0; j &lt; randfuzhi; j++) &#123; if (rand_numbers[j] == canshu2) &#123; judgee = 0; &#125; &#125; if (judgee == 1) &#123; break; &#125; &#125; rand_numbers[randfuzhi] = canshu2; // 将生成的随机数标记为已使用 randx[canshu2 - 1] = 2; randx[randfuzhi] = 2; &#125; &#125; while (x != target_x || y != target_y) &#123; int jj = 0; int aa, bb, cc, dd; judge = rand() % 2; movebar[0][0] = x - 25; movebar[0][1] = y - 44; movebar[1][0] = x + 50; movebar[1][1] = y; if (abs(target_x - x) &lt; 10 || abs(target_y - y) &lt; 10) &#123; if (x != target_x)// &#123; if (judge == 0) &#123; dx = 1; dy = 0; &#125; &#125; if (y != target_y)// &#123; if (judge == 1) &#123; dx = 0; dy = 1; &#125; &#125; &#125; else &#123; dx = randx[jj]; dy = randy[jj]; jj++; &#125; if (x != target_x &amp;&amp; y == target_y &amp;&amp; abs(target_x - x) &lt; 10) &#123; dx = 1; dy = 0; &#125; else if (x != target_x &amp;&amp; y == target_y &amp;&amp; abs(target_x - x) &gt;= 10) &#123; dx = 2; dy = 0; &#125; if (y != target_y &amp;&amp; x == target_x &amp;&amp; abs(target_y - y) &lt; 10) &#123; dx = 0; dy = 1; &#125; else if (y != target_y &amp;&amp; x == target_x &amp;&amp; abs(target_y - y) &gt;= 10) &#123; dx = 0; dy = 2; &#125; aa = skipthing(barrier, movebar, &amp;dx, &amp;dy); bb = skipthing(barrier1, movebar, &amp;dx, &amp;dy); cc = skipthing(barrier2, movebar, &amp;dx, &amp;dy); if (aa == 1 &amp;&amp; bb == 1 &amp;&amp; cc == 1) &#123; if ((target_x - x) &gt;= 0) &#123; xxx = 0; &#125; else if ((target_x - x) &lt; 0) &#123; xxx = 1; &#125; if ((target_y - y) &gt;= 0) &#123; yyy = 0; &#125; else if ((target_y - y) &lt; 0) &#123; yyy = 1; &#125; &#125; xmax = (x + 50) &gt; 639 ? 639 : (x + 50); ymax = (y + 0) &gt; 479 ? 479 : (y + 0); xmin = (x - 25) &lt; 0 ? 0 : (x - 25); ymin = (y - 44) &lt; 20 ? 0 : (y - 44); showheight(x, y, xiao, yu, mian); getimage(xmin, ymin, xmax, ymax, buffer); drtdrone(x, y - 44); //无人机速度控制 delay(15);//15 if (abs(x - target_x) &lt; 2 &amp;&amp; abs(y - target_y) &lt; 2) &#123; delay(50);//100 &#125; putimage(xmin, ymin, buffer, COPY_PUT); if (xxx == 0) &#123; x += dx; // 更新x坐标 &#125; else if (xxx == 1) &#123; x -= dx; // 更新x坐标 &#125; if (yyy == 0) &#123; y += dy; // 更新y坐标 &#125; else if (yyy == 1) &#123; y -= dy; // 更新y坐标 &#125; &#125; &#125;&#125;int skipthing(int barrier[][2], int movebar[][2], int* dx, int* dy)&#123; //barrier 储存的是障碍物坐标，movebar 是无人机坐标。dx,dy是运动的 值。targetxy是终点坐标。 if (barrier[0][0] - 5 &lt;= movebar[1][0] &amp;&amp; barrier[1][0] - 5 &gt;= movebar[0][0] &amp;&amp; barrier[0][1] + 5 &lt;= movebar[1][1] &amp;&amp; barrier[1][1] + 5 &gt;= movebar[0][1] )//障碍物与无人机 相交：：：判断两矩形是否相交。，这里扩充了障碍物，边界+10 &#123; if (abs(movebar[0][1] - barrier[1][1]) &lt; 4)//无人机 上边与 障碍物下边 相交 &#123;//无人机从 上方碰见障碍物 *dy = 0;// 1; *dx = 1; &#125; else if (abs(movebar[1][1] - barrier[0][1]) &lt; 4)//无人机 下边与 障碍物上边 相交 &#123;//无人机从 下方碰见障碍物 *dy = 0;// 1; *dx = 1; &#125; else if (abs(movebar[0][0] - barrier[1][0]) &lt; 4)//无人机 左边与 障碍物右边 相交 &#123;//无人机从 右方碰见障碍物 *dx = 0;// 1; *dy = -1; &#125; else if (abs(movebar[1][0] - barrier[0][0]) &lt; 4)//无人机 右边与 障碍物左边 相交 &#123;//无人机从 左方碰见障碍物 *dx = 0; // -1; *dy = 1; &#125; return 0; &#125; return 1;&#125;void dronemove2(void)&#123; void* buffer1 = malloc(imagesize(0, 0, 75, 44));//定义缓存区 int x1, y1; int a[239][2]; int i, j, k; int temp[2]; int quyu[12] = &#123; 77,110,137,157,185,219,265,316,355,384,417,480 &#125;;//将农田分成11区域，有12个分界线无人机扫描11次 int count[11] = &#123; 0 &#125;;//计算每个区域有多少植物 int ii[11] = &#123; 0 &#125;; int barrier[2][2] = &#123; 0 &#125;; int barrier1[2][2] = &#123; 0 &#125;; int barrier2[2][2] = &#123; 0 &#125;; getxtxiao(a); getxtyumi(&amp;a[103]); getxtmianhua(&amp;a[171]); barrier[0][0] = 249; barrier[0][1] = 239; barrier[1][0] = 278; barrier[1][1] = 324; barrier1[0][0] = 480; barrier1[0][1] = 326 - 10; barrier1[1][0] = 519; barrier1[1][1] = 415 - 10; barrier2[0][0] = 549; barrier2[0][1] = 49; barrier2[1][0] = 589; barrier2[1][1] = 141; paipai(a, barrier2); paipai(a, barrier1); paipai(a, barrier); for (i = 0; i &lt; 238; i++) &#123; for (j = i + 1; j &lt; 239; j++) &#123; if (a[i][1] &gt; a[j][1]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; for (i = 0; i &lt; 239; i++) &#123; for (k = 0; k &lt; 11; k++) &#123; if (a[i][1] &gt;= quyu[k] &amp;&amp; a[i][1] &lt; quyu[k + 1])//判断植物在第几区域内部 &#123; count[k]++; &#125; &#125; &#125; for (i = 1; i &lt; 11; i++) &#123; for (j = 0; j &lt; i; j++) &#123; ii[i] += count[j]; &#125; &#125; ii[0] = 0; i = 0; for (k = 0; k &lt; 11; k++) &#123; if ((k % 2) == 0)//向右移动，x小的 在前 &#123; for (i = ii[k]; i &lt; ii[k] + count[k] - 1; i++) &#123; for (j = i + 1; j &lt; ii[k] + count[k]; j++) &#123; if (a[i][0] &gt; a[j][0]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; &#125; else &#123; for (i = ii[k]; i &lt; ii[k] + count[k] - 1; i++) &#123; for (j = i + 1; j &lt; ii[k] + count[k]; j++) &#123; if (a[i][0] &lt; a[j][0]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; &#125; &#125; x1 = 0;//初始化无人机坐标 y1 = 60; move21(a, 239, x1, y1, buffer1); free(buffer1); setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(100, 56, 250, 88); // 清除时间显示区域 delay(100);&#125;void paipai(int a[][2], int barrier2[][2])//排序&#123; int i; for (i = 0; i &lt; 238; i++) &#123; if (a[i][0] &gt;= barrier2[0][0] - 52 &amp;&amp; a[i][0] &lt;= barrier2[1][0] + 26 &amp;&amp; a[i][1] &gt;= barrier2[0][1] &amp;&amp; a[i][1] &lt;= barrier2[1][1] + 46) &#123; if (a[i][0] &lt;= ((barrier2[1][0] + barrier2[0][1]) / 2)) &#123; a[i][0] = barrier2[1][0] - 53; a[i][1] = barrier2[0][1]; &#125; else &#123; a[i][0] = barrier2[1][0] + 27; a[i][1] = barrier2[1][1]; &#125; &#125; &#125;&#125;//大农田的无人机运动void dronemove1(void)&#123; //-======================================================== void* buffer1 = malloc(imagesize(0, 0, 25, 25)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int* judge = malloc(sizeof(int)); int i; *x1 = 0; *judge = 65; *y1 = 65; //==================================== //整个运动的实现 for (i = 0; i &lt; 7; i++) &#123; move11(x1, y1, buffer1); move12(x1, y1, buffer1, judge); move13(x1, y1, buffer1); move12(x1, y1, buffer1, judge); //这三个运动为一个循环。。。 &#125; move11(x1, y1, buffer1); move12(x1, y1, buffer1, judge); for (; *x1 &gt; 0; *x1 = *x1 - 2)//运动到了最左端。。 &#123; getimage(*x1, *y1, *x1 + 25, *y1 + 25, buffer1);//保存image到buffer drfdrone(*x1, *y1); delay(8); putimage(*x1, *y1, buffer1, COPY_PUT);//恢复图像 &#125; for (; *y1 &gt; 65; *y1 = *y1 - 1)//运动到了最左端。。 &#123; getimage(*x1, *y1, *x1 + 25, *y1 + 25, buffer1);//保存image到buffer drfdrone(*x1, *y1); delay(5); putimage(*x1, *y1, buffer1, COPY_PUT);//恢复图像 &#125; free(buffer1); free(x1); free(y1); free(judge); delay(100);&#125;void showheight(int x, int y, int xiao[][2], int yu[][2], int mian[][2])//显示无人机高度&#123; char string[20]; int high = 0; int i; int judge = 0; int randshu; if (x &gt; 1 &amp;&amp; x &lt; 203 &amp;&amp; y &lt; 278 &amp;&amp; y&gt;76)//梯田区域 &#123; for (i = 0; i &lt; 103; i++) &#123; if (abs(x - xiao[i][0]) &lt; 4 &amp;&amp; abs(y - xiao[i][1]) &lt; 4) &#123; high = rand() % 30 + 150 + 300; judge = 1; &#125; &#125; for (i = 0; i &lt; 68; i++) &#123; if (abs(x - yu[i][0]) &lt; 4 &amp;&amp; abs(y - yu[i][1]) &lt; 4) &#123; high = rand() % 50 + 330 + 300; judge = 1; &#125; if (abs(x - mian[i][0]) &lt; 4 &amp;&amp; abs(y - mian[i][1]) &lt; 4) &#123; high = rand() % 50 + 210 + 300; judge = 1; &#125; &#125; &#125; else &#123; for (i = 0; i &lt; 103; i++) &#123; if (abs(x - xiao[i][0]) &lt; 4 &amp;&amp; abs(y - xiao[i][1]) &lt; 4) &#123; high = rand() % 30 + 150; judge = 1; &#125; &#125; for (i = 0; i &lt; 68; i++) &#123; if (abs(x - yu[i][0]) &lt; 4 &amp;&amp; abs(y - yu[i][1]) &lt; 4) &#123; high = rand() % 50 + 330; judge = 1; &#125; if (abs(x - mian[i][0]) &lt; 4 &amp;&amp; abs(y - mian[i][1]) &lt; 4) &#123; high = rand() % 50 + 210; judge = 1; &#125; &#125; &#125; if (judge == 0) &#123; randshu = rand() % 100; if (randshu == 1) &#123; if (getpixel(x, y) == BLUE) &#123; high = rand() % 40 + 300; &#125; else if (x &gt; 1 &amp;&amp; x &lt; 203 &amp;&amp; y &lt; 278 &amp;&amp; y&gt;76)//梯田区域 &#123; high = rand() % 40 + 100+300; &#125; else if (high &lt; 150) &#123; high = rand() % 40 + 200; &#125; &#125; else high = 0; &#125; if (high &gt;= 150) &#123; setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(177, 56, 230, 88); // 清除高度 setcolor(GREEN); settextstyle(1, HORIZ_DIR, 1); sprintf(string, &quot;height: %d cm&quot;, high); outtextxy(107, 57, string);//显示字符串 &#125;&#125; 这段代码小农田的不用细看，因为这个避障和斜线运动功能确实很难做，所以当时也是乱凑，凑出来了个半成品。。。。显示高度可以看看。自己看吧，打算一口气结束这个C课设拯救计划了。太累了了了了了 队友写的反正我当时没看多久，也没看懂，现在更加不想看了，有兴趣可以自己分析。 zpjm.h1234567891011121314151617181920212223#ifndef _ZPJM_H_#define _ZPJM_H_int zpjiemian(int* a9, int nongyao[6]);void chejian(void);//绘画车间图像void nongdu(int judge);//浓度显示void jizhan(void);//无人机基站图像void xiangzi(int x, int y , int num,int judge2);//农药储存箱图像void drcar(int x, int y,int judge1);//小车void nydrone(int x, int y ,int judge4);//车间内无人机图像void fushitu(int x, int y);//小农田农药无人机图void suofangtu(int x, int y , int judge4);//大农田农药无人机缩放图void zpdh(int judge3);//农药装配动画void moveps0(int judge1, int* x, int* y, int* buffer2);//向左特殊运动void moveps1(int judge1, int* x, int* y, int* buffer2);//向右特殊运动void moveps2(int judge1, int* x, int* y, int* buffer2);//向右进一区void moveps3(int judge1, int* x, int* y, int* buffer2);//向上进一区void moveps4(int judge1, int* x, int* y, int* buffer2);//向下进一区void moveps6(int judge1, int* x, int* y, int* buffer2);//向左进一区void moveps7(int judge1, int* x, int* y, int* buffer2);//向下取药void moveps8(int judge1, int* x, int* y, int* buffer2);//向上回位void moveps9(int judge1, int* x, int* y, int* buffer2);//向上装药#endif zpjm.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594 #include &quot;common.h&quot;int zpjiemian(int* a9, int nongyao[6])&#123; if (*a9 == 1) &#123; chejian(); *a9 = 0; &#125; if (*a9 == 0 || (*a9 &gt; 1 &amp;&amp; *a9 &lt; 10)) if (mouse_press(20, 95, 110, 135) == 1) &#123; if (*a9 == 0) *a9 = 2; else if (*a9 &gt; 1 &amp;&amp; *a9 &lt; 10) *a9 = *a9 + 1; nongdu(*a9); delay(400); &#125; if (*a9 &gt; 1 &amp;&amp; *a9 &lt; 11) if (mouse_press(130, 95, 220, 135) == 1) &#123; if (*a9 == 2) *a9 = 0; else if (*a9 &gt; 2 &amp;&amp; *a9 &lt; 11) *a9 = *a9 - 1; nongdu(*a9); delay(400); &#125; if (mouse_press(220, 200, 370, 300) == 1) &#123; if (nongyao[0] == 1) &#123; nongyao[0] = 2; zpdh(0); *a9 = 1; return 9; &#125; if (nongyao[0] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(420, 200, 570, 300) == 1) &#123; if (nongyao[1] == 1) &#123; nongyao[1] = 2; zpdh(1); *a9 = 1; return 9; &#125; if (nongyao[1] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(20, 350, 170, 450) == 1) &#123; if (nongyao[2] == 1) &#123; nongyao[2] = 2; zpdh(2); *a9 = 1; return 9; &#125; if (nongyao[2] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(220, 350, 370, 450) == 1) &#123; if (nongyao[3] == 1) &#123; nongyao[3] = 2; zpdh(3); *a9 = 1; return 9; &#125; if (nongyao[3] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(420, 350, 570, 450) == 1) &#123; if (nongyao[4] == 1) &#123; nongyao[4] = 2; zpdh(4); *a9 = 1; return 9; &#125; if (nongyao[4] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a9 = 1; return 7;//返回前一个界面 &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); return 8;&#125;void chejian(void)//绘画车间图像&#123; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, LIGHTGRAY); bar(20, 150, 620, 200); bar(20, 300, 620, 350); bar(170, 200, 220, 450); bar(370, 200, 420, 450); bar(570, 200, 620, 450); bar(370, 20, 420, 150); setcolor(DARKGRAY); line(370, 20, 370, 150); line(420, 20, 420, 150); line(20, 150, 370, 150); line(20, 200, 170, 200); line(420, 150, 620, 150); line(620, 150, 620, 450); line(170, 200, 170, 300); line(20, 300, 170, 300); jizhan(); xiangzi(220, 200, 0, nongyao[0]); xiangzi(420, 200, 1, nongyao[1]); xiangzi(20, 350, 2, nongyao[2]); xiangzi(220, 350, 3, nongyao[3]); xiangzi(420, 350, 4, nongyao[4]); drcar(20, 150,0); nydrone(265, 40, 0); setfillstyle(1, YELLOW); bar(20, 55, 220, 135); setfillstyle(1, RED); bar(20, 95, 220, 135); setfillstyle(1, WHITE); bar(60, 95, 70, 135); bar(45, 110, 85, 120); bar(150, 108, 200, 122); rectangle(20, 55, 220, 135); line(20, 95, 220, 95); setfillstyle(1, DARKGRAY); bar(110, 95, 130, 135); puthz(25, 60, &quot;浓度&quot;, 24, 30, GREEN); settextstyle(1, HORIZ_DIR, 2); setcolor(GREEN); outtextxy(85, 56, &quot;:&quot;); setcolor(RED); outtextxy(140, 58, &quot;%&quot;); nongdu(0);&#125;void nongdu(int judge)//浓度显示&#123; char a[3]; setcolor(RED); setfillstyle(1, YELLOW); bar(100, 58, 138, 94); if(judge==0) sprintf(a, &quot;%d&quot;, 10); if (judge == 2) sprintf(a, &quot;%d&quot;, 20); if (judge == 3) sprintf(a, &quot;%d&quot;, 30); if (judge == 4) sprintf(a, &quot;%d&quot;, 40); if (judge == 5) sprintf(a, &quot;%d&quot;, 50); if (judge == 6) sprintf(a, &quot;%d&quot;, 60); if (judge == 7) sprintf(a, &quot;%d&quot;, 70); if (judge == 8) sprintf(a, &quot;%d&quot;, 80); if (judge == 9) sprintf(a, &quot;%d&quot;, 90); if (judge == 10) sprintf(a, &quot;%d&quot;, 100); outtextxy(100, 58, a);&#125;void jizhan(void)//无人机基站图像&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(290, 45, 370, 50); bar(330, 55, 335, 80); bar(320, 80, 345, 82); setfillstyle(1, LIGHTGRAY); bar(320, 40, 345, 55); rectangle(320, 40, 345, 55);&#125;void xiangzi(int x, int y ,int num,int judge2)//农药储存箱图像&#123; setcolor(DARKGRAY); setfillstyle(1,LIGHTGRAY); bar(x, y, x + 150, y + 100); bar(x+125, y-10, x+145 , y); rectangle(x + 125, y - 10, x + 145, y); rectangle(x, y, x + 150, y + 100); line(x, y + 1, x + 150, y + 1); line(x, y + 99, x + 150, y + 99); line(x + 149, y, x + 149, y + 100); setfillstyle(1, DARKGRAY); bar(x + 125, y -10, x + 150, y - 4); if (judge2 == 1) &#123; if (num == 0) &#123; puthz(x + 5, y + 35, &quot;氯铃胺&quot;, 24, 30, DARKGRAY); &#125; else if (num == 1) &#123; puthz(x + 5, y + 35, &quot;甲胺磷&quot;, 24, 30, DARKGRAY); &#125; else if (num == 2) &#123; puthz(x + 5, y + 35, &quot;氯氰菊酯&quot;, 24, 30, DARKGRAY); &#125; else if (num == 3) &#123; puthz(x + 5, y + 35, &quot;甲维盐&quot;, 24, 30, DARKGRAY); &#125; else if (num == 4) &#123; puthz(x + 5, y + 35, &quot;菌酯&quot;, 24, 30, DARKGRAY); &#125; &#125; else &#123; line(x, y, x + 150, y + 100); line(x+150, y, x , y + 100); line(x+1, y, x + 151 ,y + 100); line(x + 151, y, x+1, y + 100); &#125;&#125;void drcar(int x, int y,int judge1)//小车&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y + 20, x + 50, y + 40); rectangle(x, y + 20, x + 50, y + 40); setfillstyle(1, DARKGRAY); bar(x + 35, y, x + 45, y + 20); bar(x, y, x + 40, y + 6); bar(x + 5, y + 35, x + 20, y + 50); bar(x + 30, y + 35, x + 45, y + 50); setfillstyle(1, WHITE); bar(x + 10, y + 40, x + 15, y + 45); bar(x + 35, y + 40, x + 40, y + 45); if (judge1 == 0) &#123; setfillstyle(1, RED); bar(x + 35, y + 25, x + 40, y + 30); rectangle(x + 35, y + 25, x + 40, y + 30); &#125; else if (judge1 == 1) &#123; setfillstyle(1, GREEN); bar(x + 35, y + 25, x + 40, y + 30); rectangle(x + 35, y + 25, x + 40, y + 30); &#125;&#125;void nydrone(int x , int y , int judge4)//车间内无人机图像&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y - 5, x + 25, y + 30); rectangle (x, y - 5, x + 25, y + 30); line(x + 5, y - 5, x + 5, y + 30); line(x + 6, y - 5, x + 6, y + 30); line(x + 20, y - 5, x + 20, y + 30); line(x + 19, y - 5, x + 19, y + 30); setfillstyle(1, DARKGRAY); bar(x - 5, y - 5, x, y); bar(x - 10, y - 10, x - 5, y - 5); bar(x + 25, y - 5, x + 30, y); bar(x + 30, y - 10, x + 35, y-5); bar(x - 5, y +25, x, y+30); bar(x - 10, y + 30, x-5, y + 35); bar(x + 25, y + 25, x + 30, y + 30); bar(x + 30, y + 30, x + 35, y + 35); bar(x - 15, y - 20, x - 10, y + 45); bar(x + 35 , y - 20, x + 40, y + 45); if (judge4 == 0) &#123; setfillstyle(1, RED); bar(x + 10,y+10 , x + 15, y+15); &#125; else if (judge4 == 1) &#123; setfillstyle(1, GREEN); bar(x + 10, y + 10, x + 15, y + 15); &#125;&#125;void fushitu(int x, int y)//小农田农药无人机图&#123; setcolor(DARKGRAY); setfillstyle(1, BLUE); bar(x+6, y, x + 14, y + 10); rectangle(x+6 , y, x + 14, y + 10); setfillstyle(1, DARKGRAY); bar(x , y, x + 20, y + 2); bar(x , y, x +2, y + 5); bar(x + 18, y, x + 20, y + 5); setfillstyle(1, LIGHTGRAY); bar(x+5, y, x + 15, y + 5); rectangle(x+5, y, x + 15, y + 5);&#125;void suofangtu(int x, int y, int judge4)//大农田农药无人机缩放图&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y - 2, x + 10, y + 12); rectangle(x, y - 2, x + 10, y + 12); line(x + 2, y - 2, x + 2, y + 12); line(x + 3, y - 2, x + 3, y + 12); line(x + 8, y - 2, x + 8, y + 12); line(x + 7, y - 2, x + 7, y + 12); setfillstyle(1, DARKGRAY); bar(x - 2, y - 2, x, y); bar(x - 4, y - 4, x - 2, y - 2); bar(x + 10, y - 2, x + 12, y); bar(x + 12, y - 4, x + 14, y - 2); bar(x - 2, y + 10, x, y + 12); bar(x - 4, y + 12, x - 2, y + 14); bar(x + 10, y + 10, x + 12, y + 12); bar(x + 12, y + 12, x + 14, y + 14); bar(x - 6, y - 8, x - 4, y + 18); bar(x + 14, y - 8, x + 16, y + 18); if (judge4 == 0) &#123; setfillstyle(1, RED); bar(x + 4, y + 4, x + 6, y + 6); &#125; else if (judge4 == 1) &#123; setfillstyle(1, GREEN); bar(x + 4, y + 4, x + 6, y + 6); &#125;&#125;void zpdh(int judge3)//农药装配动画&#123; void* buffer2 = malloc(imagesize(0, 0, 50, 50)); int* x2 = malloc(sizeof(int)); int* y2 = malloc(sizeof(int)); int i; *x2 = 20; *y2 = 150; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(20, 150, 70, 200); line(20, 150, 370, 150); line(20, 200, 170, 200); moveps1(0, x2, y2, buffer2); if (judge3 == 0) &#123; moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 1) &#123; moveps2(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps6(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 2) &#123; moveps4(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps2(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 3) &#123; moveps4(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 4) &#123; moveps4(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps6(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; drcar(20, 150, 0); free(buffer2); free(x2); free(y2); delay(100);&#125;void moveps0(int judge1, int* x, int* y, int* buffer2)//向左特殊运动&#123; for (; *x &gt;20; *x = *x - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps1(int judge1, int* x, int* y, int* buffer2)//向右特殊运动&#123; for (; *x &lt;170; *x = *x + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y,judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps2(int judge1, int* x, int* y, int* buffer2)//向右进一区&#123; int xx; xx = *x; for (; *x-xx &lt; 200; *x = *x + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps3(int judge1, int* x, int* y, int* buffer2)//向上进一区&#123; int yy; yy = *y; for (; yy - *y &lt; 150; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps4(int judge1, int* x, int* y, int* buffer2)//向下进一区&#123; int yy; yy = *y; for (; *y - yy &lt; 150; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps6(int judge1, int* x, int* y, int* buffer2)//向左进一区&#123; int xx; xx = *x; for (; xx - *x &lt; 200; *x = *x - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps7(int judge1, int* x, int* y, int* buffer2)//向下取药&#123; int yy; yy = *y; for (; *y - yy &lt; 40; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(200); drcar(*x, *y, 1); delay(200); putimage(*x, *y, buffer2, COPY_PUT);&#125;void moveps8(int judge1, int* x, int* y, int* buffer2)//向上回位&#123; int yy; yy = *y; for (; yy-*y &lt; 40; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps9(int judge1, int* x, int* y, int* buffer2)//装药，回位&#123; int yy; yy = *y; for (; yy - *y &lt; 50; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(16); putimage(*x, *y, buffer2, COPY_PUT); &#125; for (; yy - *y &lt; 105; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(200); drcar(*x, *y, 0); nydrone(265, 40, 1); delay(200); putimage(*x, *y, buffer2, COPY_PUT); for (; yy - *y &gt;50; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, 0); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; for (; yy - *y &gt;0; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, 0); delay(16); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125; pssj.h12345#ifndef _PSSJ_H#define _PSSJ_Hint moveint2(int (*hanshu)(int*, int*), int* a, int b[6]);int moveint3(int (*hanshu)(int*, int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49], int(*)[2], int*), int* a, int b[6], unsigned char c[384][49], unsigned char d[192][49], unsigned char e[192][49], int f[386][2], int* g);#endif pssj.c1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;pssj.h&quot;#include &quot;common.h&quot;int moveint2(int (*hanshu)(int*,int* ), int* a, int b[6])&#123; int bbbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbbb = hanshu(a, b); if (*a != -10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbbb;&#125;int moveint3(int (*hanshu)(int*, int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49], int(*)[2], int*), int* a, int b[6], unsigned char c[384][49], unsigned char d[192][49], unsigned char e[192][49],int f[386][2], int* g)&#123; int bbbbbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbbbbb = hanshu(a, b, c, d, e,f,g); if (*a != -10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbbbbb;&#125; pensadh.h12345678910111213141516#ifndef _PENSADH_H_#define _PENSADH_H_int psdonghua(int *a10,int nongyao[6], unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49], int rount[386][2],int* amtjudge);void ljgh(int grandjudge, int *judge, int ny0[384][2], int ny1[192][2], int ny2[192][2], int ny3[192][2], int ny4[192][2], int rount[386][2]);//路径规划void therount(int rount[386][2], int *amtjudge);//路径画面void huigui(void);//未发现病害，回归void huigui2(int i);//喷洒农药后回归void nyphoto(int x, int y);//农药图像void anima1(int rount[386][2], int* amtjudge);//大农田路径动画void anima2(int rount[386][2], int* amtjudge);//小农田路径动画int linemove1(int* x, int* y, int* buffer1);//大农田沿线段运动int linemove21(int judge1 ,int* x, int* y, int* buffer1);//小农田沿线段运动(顺时针) 21，22合并后，动画卡顿且容易把系统卡爆int linemove22(int judge1 ,int* x, int* y, int* buffer1);//小农田沿线段运动(逆时针)#endif pensadh.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737#include &quot;common.h&quot;int psdonghua(int* a10, int nongyao[6], unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49], int rount[386][2],int* amtjudge)&#123; FILE* filePointer1; FILE* filePointer2; FILE* filePointer3; FILE* filePointer4; FILE* filePointer5; FILE* filePointer6; int i,j; int grandjudge = 0, jg0=0, jg1 = 0, jg2 = 0, jg3 = 0, jg4 = 0;//granjudge:确定农药使用，jg用于贮存相应得病植株数量 int ny0[384][2] = &#123;0&#125;;//ny用于贮存坐标 int ny1[192][2] = &#123; 0 &#125;; int ny2[192][2] = &#123; 0 &#125;; int ny3[192][2] = &#123; 0 &#125;; int ny4[192][2] = &#123; 0 &#125;; if (*a10==1) &#123; rount[0][0] = 20; rount[0][1] = 465; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); bar(260, 5, 400, 50); puthz(270, 10, &quot;喷洒农药&quot;, 32, 30, WHITE); bar(100, 5, 240, 50); puthz(110, 10, &quot;路径规划&quot;, 32, 30, WHITE); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); if (nongyao[5] == 0)//大农田，已经排除了棉花用的农药，关注0，2，4 &#123; farmfield(); for (i = 0; i &lt; 192; i++)//小麦，黏虫 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1], diannian[i]); ny0[jg0][0] = nian.bfzuobiao[i][0]; ny0[jg0][1] = nian.bfzuobiao[i][1]; jg0++; &#125; &#125; for (i = 192; i &lt; 384; i++)//玉米，黏虫 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1], diannian[i]); ny2[jg2][0] = nian.bfzuobiao[i][0]; ny2[jg2][1] = nian.bfzuobiao[i][1]; jg2++; &#125; &#125; for (i = 0; i &lt; 192; i++)//玉米，棉铃虫 &#123; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; mianling(mian.bfzuobiao[i][0], mian.bfzuobiao[i][1], dianmian[i]); ny0[jg0][0] = mian.bfzuobiao[i][0]; ny0[jg0][1] = mian.bfzuobiao[i][1]; jg0++; &#125; &#125; for (i = 0; i &lt; 192; i++)//小麦，白粉病 &#123; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; baifen(bai.bfzuobiao[i][0], bai.bfzuobiao[i][1], dianbai[i]); ny4[jg4][0] = bai.bfzuobiao[i][0]; ny4[jg4][1] = bai.bfzuobiao[i][1]; jg4++; &#125; &#125; &#125; else if (nongyao[5] == 1)//小农田 &#123; bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0); tian(); bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants(); drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0); drawScarecrow(570, 61); drawScarecrow(500, 325); binghai(); filePointer1 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer1, &quot;%d %d&quot;, &amp;ny0[jg0][0], &amp;ny0[jg0][1]) != -1) jg0++; else break; &#125; fclose(filePointer1); filePointer2 = fopen(&quot;data//xtymmian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer2, &quot;%d %d&quot;, &amp;ny0[jg0][0], &amp;ny0[jg0][1]) != -1) jg0++; else break; &#125; fclose(filePointer2); filePointer3 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer3, &quot;%d %d&quot;, &amp;ny1[jg1][0], &amp;ny1[jg1][1]) != -1) jg1++; else break; &#125; fclose(filePointer3); filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer4, &quot;%d %d&quot;, &amp;ny2[jg2][0], &amp;ny2[jg2][1]) != -1) jg2++; else break; &#125; fclose(filePointer4); filePointer5 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer5, &quot;%d %d&quot;, &amp;ny3[jg3][0], &amp;ny3[jg3][1]) != -1) jg3++; else break; &#125; fclose(filePointer5); filePointer6 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer6, &quot;%d %d&quot;, &amp;ny4[jg4][0], &amp;ny4[jg4][1]) != -1) jg4++; else break; &#125; fclose(filePointer6); &#125; if (nongyao[0] == 2) &#123; if (jg0 == 0) &#123; nongyao[0] = 0; huigui(); return 7; &#125; if (jg0 &gt; 0) &#123; grandjudge = 0; *amtjudge = jg0; &#125; &#125; if (nongyao[1] == 2) &#123; if (jg1 == 0) &#123; nongyao[1] = 0; huigui(); return 7; &#125; if (jg1 &gt; 0) &#123; grandjudge = 1; *amtjudge = jg1; &#125; &#125; if (nongyao[2] == 2) &#123; if (jg2 == 0) &#123; nongyao[2] = 0; huigui(); return 7; &#125; if (jg2 &gt; 0) &#123; grandjudge = 2; *amtjudge = jg2; &#125; &#125; if (nongyao[3] == 2) &#123; if (jg3 == 0) &#123; nongyao[3] = 0; huigui(); return 7; &#125; if (jg3 &gt; 0) &#123; grandjudge = 3; *amtjudge = jg3; &#125; &#125; if (nongyao[4] == 2) &#123; if (jg4 == 0) &#123; nongyao[4] = 0; huigui(); return 7; &#125; if (jg4 &gt; 0) &#123; grandjudge = 4; *amtjudge = jg4; &#125; &#125; ljgh(grandjudge, amtjudge, ny0, ny1, ny2, ny3, ny4, rount); *a10 = 0; &#125; if (*a10 == 2) &#123; therount(rount, amtjudge); *a10 = 3; &#125; if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a10 = 1; for (i = 0; i &lt; 5; i++) &#123; if (nongyao[i] &gt; 1) &#123; nongyao[i] = 0; &#125; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); return 8;//返回农药选择界面 &#125; if (*a10 == 0) &#123; if (mouse_press(100, 5, 240, 50) == 1) &#123; *a10 = 2; &#125; showbiankuang(100, 5, 240, 50); &#125; if (*a10 == 3) &#123; if (mouse_press(260, 5, 400, 50) == 1) &#123; if (nongyao[5] == 0) &#123; clrmous(MouseX, MouseY); anima1(rount, amtjudge); *a10 = 4; &#125; else if (nongyao[5] == 1) &#123; clrmous(MouseX, MouseY); anima2(rount, amtjudge); *a10 = 5; &#125; &#125; showbiankuang(260, 5, 400, 50); &#125; if (*a10 == 4) &#123; for (i = 0; i &lt; 5; i++) if (nongyao[i] == 2) break; if (i == 0) for (j = 0; j &lt; 192; j++) &#123; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][1] = 0; mian.bfzuobiao[j][0] = 0; mian.bfzuobiao[j][1] = 0; &#125; if (i == 2) &#123; for (j =192; j &lt; 384; j++) &#123; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][1] = 0; &#125; &#125; if (i == 4) &#123; for (j = 0; j &lt; 192; j++) &#123; bai.bfzuobiao[j][0] = 0; bai.bfzuobiao[j][1] = 0; &#125; &#125; nongyao[i] = 0; *a10 = 1; huigui2(i); return 2; &#125; if(*a10==5) &#123; for (i = 0; i &lt; 5; i++) if (nongyao[i] == 2) break; if (i == 0) &#123; filePointer1 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;w&quot;); fclose(filePointer1); filePointer1 = fopen(&quot;data//xmncdian.dat&quot;, &quot;w&quot;); fclose(filePointer1); filePointer2 = fopen(&quot;data//xtymmian.dat&quot;, &quot;w&quot;); fclose(filePointer2); filePointer2 = fopen(&quot;data//ymmldian.dat&quot;, &quot;w&quot;); fclose(filePointer2); &#125; if (i == 1) &#123; filePointer3 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;w&quot;); fclose(filePointer3); filePointer3 = fopen(&quot;data//mhmldian.dat&quot;, &quot;w&quot;); fclose(filePointer3); &#125; if (i == 2) &#123; filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;w&quot;); fclose(filePointer4); filePointer4 = fopen(&quot;data//ymncdian.dat&quot;, &quot;w&quot;); fclose(filePointer4); &#125; if (i == 3) &#123; filePointer5 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;w&quot;); fclose(filePointer5); filePointer5 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;w&quot;); fclose(filePointer5); &#125; if (i == 4) &#123; filePointer6 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;w&quot;); fclose(filePointer6); filePointer6 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;w&quot;); fclose(filePointer6); &#125; nongyao[i] = 0; *a10 = 1; huigui2(i); return 3; &#125; return 9;&#125;void ljgh(int grandjudge, int *judge, int ny0[384][2], int ny1[192][2], int ny2[192][2], int ny3[192][2], int ny4[192][2],int rount[386][2])//路径规划&#123; int i = 0, j = 0, k = *judge-1,K = 1 + *judge; int len1 = 0, len2 = 0; int dist1 = 0, dist2 = 0; int temp0 = 0, temp1 = 0; if (grandjudge == 0) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny0[i][0]; rount[j][1] = ny0[i][1]; &#125; &#125; if (grandjudge == 1) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny1[i][0]; rount[j][1] = ny1[i][1]; &#125; &#125; if (grandjudge == 2) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny2[i][0]; rount[j][1] = ny2[i][1]; &#125; &#125; if (grandjudge == 3) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny3[i][0]; rount[j][1] = ny3[i][1]; &#125; &#125; if (grandjudge == 4) &#123; j = 1; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny4[i][0]; rount[j][1] = ny4[i][1]; &#125; &#125; rount[K][0] = rount[0][0]; rount[K][1] = rount[0][1]; for (i = 0; i &lt; k; i++) &#123; len1 = rount[i + 1][0] - rount[i][0]; len2 = rount[i + 1][1] - rount[i][1]; len1 = len1 / 25; len2 = len2 / 25; dist1 = len1 * len1 + len2 * len2; for (j = i + 2; j &lt; K; j++) &#123; len1 = rount[j][0] - rount[i][0]; len2 = rount[j][1] - rount[i][1]; len1 = len1 / 25; len2 = len2 / 25; dist2 = len1 * len1 + len2 * len2; if (dist2 &lt; dist1) &#123; dist1 = dist2; temp0 = rount[j][0]; temp1 = rount[j][1]; rount[j][0] = rount[i + 1][0]; rount[j][1] = rount[i + 1][1]; rount[i+1][0] = temp0; rount[i+1][1] = temp1; &#125; &#125; &#125;&#125;void therount(int rount[386][2], int * amtjudge)//路径画面&#123; int i = 0; for (i=0;i&lt;* amtjudge+1;i++) &#123; setcolor(RED); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); &#125; line(rount[*amtjudge][0], rount[*amtjudge][1], rount[0][0], rount[0][1]);&#125;void huigui(void)//回归&#123; cleardevice(); clrmous(MouseX, MouseY); puthz(150, 200, &quot;未发现相关病状&quot;, 32, 40, RED); setcolor(BLUE); rectangle(110, 300, 530, 380); puthz(125, 322, &quot;回归中&quot;, 32, 50, RED); setfillstyle(1, BLUE); bar(265, 320, 305, 360); delay(400); bar(315, 320, 355, 360); delay(400); bar(365, 320, 405, 360); delay(400); bar(415, 320, 455, 360); delay(400); bar(465, 320, 505, 360); delay(1000);&#125;void huigui2(int i)//喷洒农药后回归&#123; cleardevice(); clrmous(MouseX, MouseY); puthz(100, 150, &quot;已清除下列植物的下列病状&quot;, 32, 40, BLUE); if (i == 0) &#123; puthz(100, 250, &quot;小麦黏虫&quot;, 32, 40, RED); puthz(300, 250, &quot;玉米棉铃虫&quot;, 32, 40, RED); &#125; if (i == 1) puthz(100, 250, &quot;棉花棉铃虫&quot;, 32, 40, RED); if (i == 2) puthz(100, 250, &quot;玉米黏虫&quot;, 32, 40, RED); if (i == 3) puthz(100, 250, &quot;棉花锈病&quot;, 32, 40, RED); if (i == 4) puthz(100, 250, &quot;小麦白粉病&quot;, 32, 40, RED); setcolor(BLUE); rectangle(90, 350, 550, 430); puthz(100, 372, &quot;回归农田&quot;, 32, 50, RED); setfillstyle(1, BLUE); bar(285, 370, 325, 410); delay(400); bar(335, 370, 375, 410); delay(400); bar(385, 370, 425, 410); delay(400); bar(435, 370, 475, 410); delay(400); bar(485, 370, 525, 410); delay(1000);&#125;void nyphoto(int x, int y)//农药图像&#123; setfillstyle(1, LIGHTBLUE); bar(x, y+2, x + 3, y + 5); bar(x + 10, y + 7, x + 13, y + 10); bar(x + 20, y+3, x + 23, y + 6); bar(x, y + 10, x + 3, y + 13); bar(x + 20, y + 5, x + 23, y + 8); bar(x + 20, y+15, x + 23, y + 18); bar(x, y + 19, x + 3, y + 22); bar(x + 12, y + 22, x + 15, y + 25);&#125;void anima1(int rount[386][2], int* amtjudge)//大农田路径动画&#123; void* buffer1 = malloc(imagesize(0, 0, 22, 26)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i,k; *x1 = rount[0][0]; *y1 = rount[0][1]; for (i = 0; i &lt; *amtjudge+1; i++) &#123; setcolor(CYAN); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); do &#123; k = linemove1(x1, y1, buffer1); &#125; while (k == 1); getimage(*x1 - 6, *y1 - 8, *x1 + 16, *y1 + 18, buffer1); suofangtu(*x1, *y1, 1); delay(100); putimage(*x1 - 6, *y1 - 8, buffer1, COPY_PUT); if (i &lt; *amtjudge) nyphoto(rount[i + 1][0], rount[i + 1][1]); &#125; getimage(*x1 - 6, *y1 - 8, *x1 + 16, *y1 + 18, buffer1); suofangtu(*x1, *y1, 1); delay(500); putimage(*x1 - 6, *y1 - 8, buffer1, COPY_PUT); free(buffer1); free(x1); free(y1);&#125;void anima2(int rount[386][2], int* amtjudge)//小农田路径动画&#123; void* buffer1 = malloc(imagesize(0, 0, 20, 10)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i, k ; for (i = 0; i &lt; *amtjudge + 1; i++) &#123; *x1 = rount[i][0]; *y1 = rount[i][1]; setcolor(CYAN); rectangle(185, 443, 233, 480); rectangle(184, 444, 234, 479); rectangle(245, 225, 287, 323); rectangle(244, 226, 288, 322); rectangle(553, 43, 582, 136); rectangle(552, 44, 583, 135); rectangle(483, 307, 512, 400); rectangle(482, 308, 513, 399); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); setcolor(BLUE); rectangle(185, 444, 233, 479); rectangle(245, 226, 287, 322); rectangle(553, 44, 582, 135); rectangle(483, 308, 512, 399); if (rount[i][0] &lt; rount[i + 1][0]&amp;&amp; rount[i][1] &gt;= rount[i + 1][1])//第一象限 &#123; do &#123; k = linemove21(6,x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &gt;= rount[i + 1][0] &amp;&amp; rount[i][1] &gt; rount[i + 1][1])//第二象限 &#123; do &#123; k = linemove22(6, x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &gt; rount[i + 1][0] &amp;&amp; rount[i][1] &lt;= rount[i + 1][1])//第三象限 &#123; do &#123; k = linemove22(0, x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &lt;= rount[i + 1][0] &amp;&amp; rount[i][1] &lt; rount[i + 1][1])//第三象限 &#123; do &#123; k = linemove21(0, x1, y1, buffer1); &#125; while (k == 1); &#125; getimage(*x1, *y1, *x1 + 20, *y1 + 10, buffer1); fushitu(*x1, *y1); delay(100); putimage(*x1 , *y1 , buffer1, COPY_PUT); setcolor(RED); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); if (i &lt; *amtjudge) nyphoto(rount[i + 1][0], rount[i + 1][1]); &#125; getimage(*x1, *y1, *x1 + 20, *y1 +10, buffer1); fushitu(*x1, *y1); delay(500); putimage(*x1 , *y1, buffer1, COPY_PUT); free(buffer1); free(x1); free(y1);&#125;int linemove1( int* x, int* y, int* buffer1)//大农田沿线段运动&#123; int a[10][2] = &#123; &#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = 1; i &lt; 9; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x-6, *y-8, *x + 16, *y + 18, buffer1); suofangtu(*x, *y,1); delay(8); putimage(*x-6, *y-8, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i-1][0], *y + a[i-1][1], RED); putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x , *y , RED); *x = *x + x0; *y = *y + y0; putpixel(*x,*y, RED); &#125; return judge;&#125;int linemove21(int judge1, int* x, int* y, int* buffer1)//小农田沿线段运动(顺时针)&#123; int a[17][2] = &#123; &#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = judge1; i &lt; judge1+8; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x, *y, *x + 20, *y + 10, buffer1); fushitu(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x , *y , RED); *x = *x + x0; *y = *y + y0; putpixel(*x,*y, RED); &#125; return judge;&#125;int linemove22(int judge1, int* x, int* y, int* buffer1)//小农田沿线段运动(逆时针)&#123; int a[17][2] = &#123; &#123;0,-1&#125;, &#123;-1,-1&#125;, &#123;-1,0&#125;, &#123;-1,1&#125;, &#123;0,1&#125; , &#123;1,1&#125;, &#123;1,0&#125;, &#123;1,-1&#125;, &#123;0,-1&#125;, &#123;-1,-1&#125;, &#123;-1,0&#125;, &#123;-1,1&#125;, &#123;0,1&#125; , &#123;1,1&#125;, &#123;1,0&#125;, &#123;1,-1&#125;,&#123;0,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = judge1; i &lt; judge1+8; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x, *y, *x + 20, *y + 10, buffer1); fushitu(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x, *y, RED); *x = *x + x0; *y = *y + y0; putpixel(*x, *y, RED); &#125; return judge;&#125; pensa.h12345678910#ifndef _PENSA_H_#define _PENSA_H_int zhuzhan(int* a8,int nongyao[6]);void peizhi(void);void drhook(int x, int y);void cross(int x, int y);void drline(int x, int y);#endif pensa.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278 #include &quot;common.h&quot;int zhuzhan(int* a8,int nongyao[6])&#123; int i; if (*a8 == 1) &#123; peizhi(); *a8 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(370, 0, 580, 60); if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a8 = 1; if (nongyao[5] == 0) return 2; else if (nongyao[5] == 1) return 3; &#125; if (nongyao[0] == 0) &#123; if (mouse_press(300, 145, 440, 225) == 1 || mouse_press(160, 225, 300, 305) == 1)//氟铃脲 &#123; *a8 = 1; nongyao[0] = 1; &#125; &#125; if (nongyao[2] == 0) &#123; if (mouse_press(300, 225, 440, 305) == 1)//氯氰菊酯 &#123; *a8 = 1; nongyao[2] = 1; &#125; &#125; if (nongyao[4] == 0) &#123; if (mouse_press(160, 305, 300, 385) == 1)//菌酯 &#123; *a8 = 1; nongyao[4] = 1; &#125; &#125; if (nongyao[5] == 1) &#123; if (nongyao[1] == 0) &#123; if (mouse_press(440, 145, 580, 225) == 1)//甲胺磷 &#123; *a8 = 1; nongyao[1] = 1; &#125; &#125; if (nongyao[3] == 0) &#123; if (mouse_press(440, 385, 580, 465) == 1)//甲维盐 &#123; *a8 = 1; nongyao[3] = 1; &#125; &#125; &#125; if (nongyao[0] == 1) &#123; if (mouse_press(410, 145, 440, 175) == 1 || mouse_press(270, 225, 300, 255) == 1)//氟铃脲 &#123; *a8 = 1; nongyao[0] = 0; delay(400); &#125; &#125; if (nongyao[2] == 1) &#123; if (mouse_press(410, 225, 440, 255) == 1)//氯氰菊酯 &#123; *a8 = 1; nongyao[2] = 0; delay(400); &#125; &#125; if (nongyao[4] == 1) &#123; if (mouse_press(270, 305, 300, 335) == 1)//菌酯 &#123; *a8 = 1; nongyao[4] = 0; delay(400); &#125; &#125; if (nongyao[5] == 1) &#123; if (nongyao[1] == 1) &#123; if (mouse_press(550, 145, 580, 175) == 1)//甲胺磷 &#123; *a8 = 1; nongyao[1] = 0; delay(400); &#125; &#125; if (nongyao[3] == 1) &#123; if (mouse_press(550, 385, 580, 415) == 1)//甲维盐 &#123; *a8 = 1; nongyao[3] = 0; delay(400); &#125; &#125; &#125; if (mouse_press(370, 0, 580, 60) == 1)//装配农药 &#123; *a8 = 1; return 8; &#125; return 7;&#125;void peizhi(void)//配置界面绘画&#123; int i; int x,y; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, BLUE); bar(20, 65, 580, 465); bar(370, 0, 580, 60); puthz(390, 10, &quot;装配农药&quot;, 32, 40, WHITE); puthz(100, 10, &quot;选择配置农药&quot;, 32, 40, BLUE); setcolor(LIGHTGRAY); rectangle(370, 0, 580, 60); line(20, 65, 160, 145); for (i = 0; i &lt; 6; i++) &#123; x = 20 + 140 * i; line(x, 65, x, 465); line(x+1, 65, x+1, 465); y = 65 + 80 * i; line(20, y, 580, y); line(20, y+1, 580, y+1); &#125; puthz(80, 70, &quot;植株种类&quot;, 16, 20, WHITE); puthz(30, 120, &quot;病害种类&quot;, 16, 20, WHITE); puthz(25, 170, &quot;棉铃虫&quot;, 24, 30, WHITE); puthz(25, 250, &quot;黏虫&quot;, 24, 30, WHITE); puthz(25, 330, &quot;白粉病&quot;, 24, 30, WHITE); puthz(25, 410, &quot;锈病&quot;, 24, 30, WHITE); puthz(165, 90, &quot;小麦&quot;, 24, 30, WHITE); puthz(165, 255, &quot;氟铃脲&quot;, 24, 30, WHITE); puthz(165, 335, &quot;菌酯&quot;, 24, 30, WHITE); puthz(305, 90, &quot;玉米&quot;, 24, 30, WHITE); puthz(305, 175, &quot;氟铃脲&quot;, 24, 30, WHITE); puthz(305, 255, &quot;氯氰菊酯&quot;, 24, 30, WHITE); puthz(445, 90, &quot;棉花&quot;, 24, 30, WHITE); puthz(445, 175, &quot;甲胺磷&quot;, 24, 30, WHITE); puthz(445, 415, &quot;甲维盐&quot;, 24, 30, WHITE); drline(160, 145); drline(160, 385); drline(300, 305); drline(300, 385); drline(440, 225); drline(440, 305); if (nongyao[0] == 1) &#123; setfillstyle(1, WHITE); bar(300, 145, 440, 225); bar(160, 225, 300, 305); puthz(165, 255, &quot;氟铃脲&quot;, 24, 30, BLUE); puthz(305, 175, &quot;氟铃脲&quot;, 24, 30, BLUE); drhook(300, 145); drhook(160, 225); setfillstyle(1, RED); bar(410, 145, 440, 175); bar(270, 225, 300, 255); cross(410, 145); cross(270, 225); rectangle(300, 145, 440, 225); rectangle(160, 225, 300, 305); &#125; if (nongyao[1] == 1) &#123; setfillstyle(1, WHITE); bar(440, 145, 580, 225); puthz(445, 175, &quot;甲胺磷&quot;, 24, 30, BLUE); drhook(440, 145); setfillstyle(1, RED); bar(550, 145, 580, 175); cross(550, 145); rectangle(440, 145, 580, 225); &#125; if (nongyao[2] == 1) &#123; setfillstyle(1, WHITE); bar(300, 225, 440, 305); puthz(305, 255, &quot;氯氰菊酯&quot;, 24, 30, BLUE); drhook(300, 225); setfillstyle(1, RED); bar(410, 225, 440, 255); cross(410, 225); rectangle(300, 225, 440, 305); &#125; if (nongyao[3] == 1) &#123; setfillstyle(1, WHITE); bar(440, 385, 580, 465); puthz(445, 415, &quot;甲维盐&quot;, 24, 30, BLUE); drhook(440, 385); setfillstyle(1, RED); bar(550, 385, 580, 415); cross(550, 385); rectangle(440, 385, 580, 465); &#125; if (nongyao[4] == 1) &#123; setfillstyle(1, WHITE); bar(160, 305, 300, 385); puthz(165, 335, &quot;菌酯&quot;, 24, 30, BLUE); drhook(160, 305); setfillstyle(1, RED); bar(270, 305, 300, 335); cross(270, 305); rectangle(160, 305, 300, 385); &#125; if (nongyao[5] == 0) &#123; setfillstyle(1, BLUE); bar(442, 147, 578, 223); bar(442, 387, 578, 463); drline(440, 145); drline(440, 385); &#125;&#125;void drhook(int x, int y)&#123; setcolor(RED); line(x + 110, y + 70, x + 125, y + 80); line(x + 111, y + 70, x + 126, y + 80); line(x + 124, y + 80, x + 139, y + 50); line(x + 125, y + 80, x + 140, y + 50);&#125;void cross(int x, int y)&#123; setcolor(WHITE); line(x, y, x + 30, y + 30); line(x, y + 1, x + 29, y + 30); line(x + 1, y, x + 30, y + 29); line(x, y + 30, x + 30, y); line(x, y + 29, x + 29, y); line(x + 1, y + 30, x + 30, y + 1);&#125;void drline(int x, int y)&#123; setcolor(LIGHTGRAY); line(x, y, x + 140, y + 80); line(x+1, y, x + 141, y + 80);&#125; 借用祖传hz.h123456#ifndef __HZ_H__#define __HZ_H__void puthz(int x, int y,char *s,int flag,int part,int color);#endif hz.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&quot;hz.h&quot;void puthz(int x, int y,char *s,int flag,int part,int color)&#123; FILE *hzk_p=NULL; //定义汉字库文件指针 unsigned char quma,weima; //定义汉字的区码和位码 unsigned long offset; //定义汉字在字库中的偏移量 unsigned char mask[] = &#123;0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01&#125;; //功能数组，用于显示汉字点阵中的亮点 int i,j,pos; switch(flag) //不同的flag对应不同的汉字库，实现了汉字的大小可根据需要改变 &#123; case 16 : &#123; char mat[32]; //16*16的汉字需要32个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\HZ16&quot;,&quot;rb&quot;); //使用相对路径 if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,1); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk16 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*32L; //求出要显示的汉字在字库文件中的偏移 fseek(hzk_p,offset,SEEK_SET); //重定位文件指针 fread (mat,32,1,hzk_p); //读出该汉字的具体点阵数据,1为要读入的项数 for(i=0;i&lt;16;i++) &#123; pos=2*i; //16*16矩阵中有每一行有两外字节 for(j=0;j&lt;16;j++) //一行一行地扫描，将位上为了1的点显示出来 &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) //j%8只能在0—8之间循环，j/8在0，1之间循环 &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; /*==================================================== 以上是一个汉字显示完 ====================================================*/ x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后,重新从左侧开始输出汉字，给y一个偏移量 &#125; break; &#125; case 24 : &#123; char mat[72]; //24*24矩阵要72个字节来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\Hzk24k&quot;,&quot;rb&quot;); if (hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk24 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while(x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*72L; fseek(hzk_p,offset,SEEK_SET); fread (mat,72,1,hzk_p); for (i=0;i&lt;24;i++) &#123; pos=3*i; //矩阵中每一行有三个字节 for (j=0;j&lt;24;j++) // 每一行有24位 &#123; if ((mask[j%8]&amp;mat[pos+j/8])!=NULL) putpixel(x+j,y,color); &#125; y++; &#125; x+=part; s+=2; &#125; x=x0;y0+=flag+10; &#125; break; &#125; case 32 : &#123; char mat[128]; //32*32的汉字需要128个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\HZK32S&quot;,&quot;rb&quot;); if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk32 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*128L; fseek(hzk_p,offset,SEEK_SET); fread (mat,128,1,hzk_p); for(i=0;i&lt;32;i++) &#123; pos=4*i; //32*32矩阵中有每一行有两外字节 for(j=0;j&lt;32;j++) &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; //以上是一个汉字显示完 x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后，给y一个偏移量 &#125; break; &#125; case 48: &#123; char mat[288]; //48*48的汉字需要288个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\Hzk48k&quot;,&quot;rb&quot;); if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk48 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*288L; //求出要显示的汉字在字库文件中的偏移 fseek(hzk_p,offset,SEEK_SET); //重定位文件指针 fread (mat,288,1,hzk_p); //读出该汉字的具体点阵数据,1为要读入的项数 for(i=0;i&lt;48;i++) &#123; pos=6*i; for(j=0;j&lt;48;j++) //一行一行地扫描，将位上为了1的点显示出来 &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) //j%8只能在0—8之间循环，j/8在0，1之间循环 &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; //以上是一个汉字显示完 x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后，给y一个偏移量 &#125; break; &#125; default: break; &#125; fclose(hzk_p);&#125; IMAGE.h1234567891011121314#ifndef IMAGE_H#define IMAGE_Hint bmp_convert(char *bmp,char *dbm); //将 *.bmp 变为 *.dbm,字符串bmp中为bmp所在地址，字dbmp为输出地址int show_dbm(int x,int y,char *dbm,int nowpage); //输入dbmp的路径,在(x,y)输出图片(x需为8的倍数)void cir_bar(int x1,int y1,int x2,int y2,int color); //在指定位置画出一个圆角矩形框 void movetopage(int x1, int y1, int x2, int y2,int page1);void set_color(int color_no,int red,int green,int blue); //指定颜色编号，修改其对应的rgb值 int quick_move_2(int Start, int End, int Size);int quick_move_1(int Start, int End, int Size);void close_display(void); //关闭屏幕显示void open_display(void); //打开屏幕显示 #endif IMAGE.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301/***********************该图像转换及输出函数，要求输入的图片分辨率在640*480之内***********************/#include &lt;stdio.h&gt;#include &lt;dos.h&gt;#include &quot;image.h&quot;#include &lt;graphics.h&gt;#include &lt;conio.h&gt;int bmp_convert(char *bmp,char *dbm) //将 *.bmp 变为 *.dbm,字符串bmp中为bmp所在地址，字dbmp为输出地址&#123;// static int color[16]=&#123;0,4,2,6,1,5,3,7,8,12,10,14,9,13,11,15&#125;; 上win下ps static int color[16]=&#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;//索引与bc内颜色序号对应转换（建议用win画图转化） unsigned char dbmline[640],bmpline[640],pixel[8],Vbyte; int ImageW,ImageH,i,j,k,n,now,bmpcom,gg ; long hangsize; FILE *fbmp,*fdbm; union &#123; unsigned char val; struct &#123; unsigned cl:4; unsigned ch:4; &#125;color; //用位域储存颜色信息，分拆颜色信息 &#125;MyColor; if((fbmp=fopen(bmp,&quot;rb&quot;))==NULL) &#123; printf(&quot;%s\n&quot;,bmp); printf(&quot;Open bmp error!&quot;); return 1; &#125; fseek(fbmp,18,SEEK_SET); //bmp图像的宽高在文件头18字节后 fread(&amp;gg,4,1,fbmp); // fread(&amp;ImageW,4,1,fbmp); fread(&amp;ImageH,4,1,fbmp); ImageW=gg; // ImageH*=2; // printf(&quot;%d &quot;,ImageW); // printf(&quot;%d&quot;,ImageH); if(ImageW==0||ImageH==0||ImageW&gt;641||ImageH&gt;481)/////注意注意！！根据实际修改/ &#123; printf(&quot;The image is too large!Please input image below 640*480.&quot;); fclose(fbmp); return 1; &#125; if((fdbm=fopen(dbm,&quot;wb&quot;))==NULL) &#123; printf(&quot;Creat \&quot;%s\&quot; error!&quot;,dbm); return 1; &#125; bmpcom=(ImageW-1)/8+1; //行处理单元数 hangsize=bmpcom*4; //每行字节数（DIB数据要求每行字节为4整数倍，已计算补零） fwrite(&amp;ImageW,sizeof(int),1,fdbm); fwrite(&amp;ImageH,sizeof(int),1,fdbm); fseek(fbmp,-hangsize,SEEK_END); for(i=0;i&lt;ImageH;i++) &#123; now=0; fread(bmpline,hangsize,1,fbmp); fseek(fbmp,-hangsize*2,SEEK_CUR); for(n=3;n&gt;=0;n--) //每行拆成四个位面的数据输出 // for(n=0;n&lt;=3;n++) &#123; for(j=0;j&lt;bmpcom;j++) &#123; Vbyte=0; for(k=0;k&lt;4;k++) &#123; MyColor.val=bmpline[j*4+k]; pixel[k*2]=color[MyColor.color.ch]; pixel[k*2+1]=color[MyColor.color.cl]; &#125; for(k=0;k&lt;8;k++) &#123; Vbyte+=(pixel[k]&gt;&gt;n&amp;1)&lt;&lt;(7-k); &#125; dbmline[now++]=Vbyte; &#125; &#125; fwrite(dbmline,hangsize,1,fdbm); &#125; fclose(fdbm); fclose(fbmp); return 0;&#125;int show_dbm(int x,int y,char *dbm,int nowpage) //输入dbmp的路径,在(x,y)输出图片(x需为8的倍数)&#123; int ImageW,ImageH,n,i,j; long hangsize; FILE * fdbm; char far * per; if(nowpage==0) per=(char far *)0xA0000000L; else per=(char far *)0xA8000000L; // _VideoBusy=YES; //hanenv系统内的显示寄存器保护变量 if((fdbm=fopen(dbm,&quot;rb&quot;))==NULL) &#123; // printf(&quot;%s&quot;,dbm); // getchar(); // printf(&quot;Open Error!&quot;); return 1; &#125; fread(&amp;ImageW,sizeof(int),1,fdbm); fread(&amp;ImageH,sizeof(int),1,fdbm); // printf(&quot;%d %d&quot;,ImageW,ImageH); hangsize=(ImageW-1)/8; per=per+x/8+y*80; if((ImageH+y)&gt;480) ImageH=480-y; //VGAMED 640*480 for(i=0;i&lt;ImageH;i++) &#123; for(n=8;n&gt;=1;n&gt;&gt;=1) //从第三位颜色平面写到第0 &#123; outportb(0x3c4,2); outportb(0x3c5,n); fread(per,hangsize,1,fdbm); fseek(fdbm,1,SEEK_CUR); &#125; // fseek(fdbm,hangsize*2,SEEK_CUR); per+=80; &#125; fclose(fdbm); // _VideoBusy=NO; outportb(0x3c5,0xf); return 0;&#125;void cir_bar(int x1,int y1,int x2,int y2,int color) //在指定位置画出一个圆角矩形框 &#123; int w=x2-x1,h=y2-y1; setcolor(color); setlinestyle(SOLID_LINE,0,THICK_WIDTH); ellipse(5+x1,10+y1,90,180,5,10); line(0+x1,10+y1,0+x1,10+h-20+y1); ellipse(5+x1,10+h-20+y1,180,270,5,10); line(5+x1,0+y1,5+w-10+x1,0+y1); ellipse(5+w-10+x1+1,10+y1,0,90,5,10); line(w+x1,10+y1,w+x1,y2-10); ellipse(w-5+x1+1,10+h-20+y1,270,360,5,10); line(5+x1,h+y1,5+w-10+x1,h+y1);&#125;void movetopage(int x1, int y1, int x2, int y2,int page1) //显示页间局部图像数据传输，输入左上角坐标及右上角坐标，从page1移动到page2&#123; int per1, per2; int hangsize = (x2 - x1) / 8; int high = y2 - y1 + 1; register int i, p1, p2; if (page1 == 0) &#123; per2 = 0xA0000000L; per1 = 0xA8000000L; &#125; else &#123; per1 = 0xA0000000L; per2 = 0xA8000000L; &#125; per1 = per1 + (x1) / 8 + (y1 ) * 80; per2 = per2 + (x1) / 8 + (y1 ) * 80; for (i = 0; i &lt;high; i++) //传输视频图像 &#123; for (p1 = 8, p2 = 3; p1 &gt;= 1; p1 &gt;&gt;= 1, p2--) //从第三位颜色平面写到第0 &#123; outportb(0x3c4, 2); //颜色位面写寄存器 outportb(0x3c5, p1); outportb(0x3ce, 4); //颜色位面读寄存器 outportb(0x3cf, p2); if (page1 == 0) &#123; quick_move_2(per2, per1, hangsize); &#125; else &#123; quick_move_1(per2, per1, hangsize); &#125; &#125; per1 += 80; per2 += 80; &#125; outportb(0x3cf,0); //恢复设置 outportb(0x3c5,0xf);&#125;void set_color(int color_no,int red,int green,int blue) //指定颜色编号，修改其对应的rgb值 &#123; if(color_no&lt;16) &#123; _AX=0x1007; //选择10H显示中断中的第7号功能 _BL=color_no; geninterrupt(0x10); color_no=_BH; &#125; else color_no = 0xff; //将屏幕边缘色指向调色板255 //修改调色板寄存器 _DH=red; _CH=green; _CL=blue; _BX=color_no; _AX=0x1010; geninterrupt(0x10); //处理屏幕边缘颜色 if(color_no==0xff) &#123; _BH=0xff; _AX=0x1001; geninterrupt(0x10); &#125; &#125;/*此为用汇编编写的支持跨段寻址的数据传输函数，来自《VGA页面图形数据移动技术在特殊显示效果中的应用》一文*/int quick_move_1(int Start,int End,int Size) //Start为原处首地址，End为目标位置首地址 (1 to 0)&#123; asm&#123; push es push ds push di push si push ax push cx push dx mov ax,0a800h mov ds,ax mov ax,Start mov si,ax mov ax,0a000h mov es,ax mov ax,End mov di,ax mov cx,Size rep movsb pop dx pop cx pop ax pop si pop di pop ds pop es &#125; return 0;&#125;int quick_move_2(int Start,int End,int Size) //Start为原处首地址，End为目标位置首地址 (0 to 1)&#123; asm&#123; push es push ds push di push si push ax push cx push dx mov ax,0a000h mov ds,ax mov ax,Start mov si,ax mov ax,0a800h mov es,ax mov ax,End mov di,ax mov cx,Size rep movsb pop dx pop cx pop ax pop si pop di pop ds pop es &#125; return 0;&#125;void close_display(void) //关闭屏幕显示&#123; _BL=0x32; _AH=0x12; _AL=0x01; geninterrupt(0x10);&#125;void open_display(void) //打开屏幕显示&#123; _BL=0x32; _AH=0x12; _AL=0x00; geninterrupt(0x10);&#125; mouse.h123456789101112131415161718#ifndef _mouse_h_#define _mouse_h_int mouse_press(int x1, int y1, int x2, int y2);//如果在框中点击，则返回1；在框中未点击，则返回2；不在框中则返回0void mouse(int,int);//设计鼠标void mouseinit(void);//初始化void mou_pos(int*,int*,int*);//更改鼠标位置void mread(int *,int *,int*);//改坐标不画void save_bk_mou(int x,int y);//存鼠标背景void clrmous(int x,int y);//清除鼠标void drawmous(int x,int y);//画鼠标void newmouse(int *nx,int *ny,int *nbuttons); //更新鼠标extern int MouseX;extern int MouseY;extern int MouseS;extern int press;extern union REGS regs;#endif mouse.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include&lt;conio.h&gt;#include&lt;graphics.h&gt;#include&lt;dos.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &quot;mouse.h&quot;/**************************MOUSE.cUPDATER: dengshuuminFUNCTION: mouse actionABSTRACT: A.mread B.newmouseVERSION: 3.0***************************/int MouseX;int MouseY;int MouseS;int press;//形状用 &amp;pressvoid *buffer;//union REGS regs;int flag=0;void mouseinit()//初始化&#123; int retcode; int xmin,xmax,ymin,ymax,x_max=625,y_max=480; int size; xmin=2; xmax=x_max-1; ymin=8; ymax=y_max-2; regs.x.ax=0; int86(51,&amp;regs,&amp;regs); retcode=regs.x.ax; if(retcode==0) &#123; printf(&quot;Mouse or Mouse Driver Obsent,Please Install!&quot;); delay(5000); &#125; else &#123; regs.x.ax=7; regs.x.cx=xmin; regs.x.dx=xmax; int86(51,&amp;regs,&amp;regs); regs.x.ax=8; regs.x.cx=ymin; regs.x.dx=ymax; int86(51,&amp;regs,&amp;regs); &#125; MouseS = 0; MouseX=320,MouseY=240; save_bk_mou(320,240); mouse(MouseX,MouseY); flag=1;&#125;/*****************************FUNCTION: mouseDESCRIPTION: 画不同形态的鼠标INPUT: x,yRETURN: 无******************************/void mouse(int x,int y)&#123; switch(MouseS) &#123; case 1: //手势鼠标 &#123; setcolor(WHITE); setlinestyle(0,0,1); line(x-1,y+9,x-1,y+8); line(x,y+7,x,y+11); line(x+1,y+6,x+1,y+13); line(x+2,y+8,x+2,y+14); line(x+3,y-1,x+3,y+15); arc(x+4,y-1,0,180,1); line(x+4,y-2,x+4,y+15); line(x+5,y-1,x+5,y+16); arc(x+6,y+3,0,180,1); line(x+6,y+2,x+6,y+16); line(x+7,y+3,x+7,y+17); arc(x+8,y+5,0,180,1); line(x+8,y+4,x+8,y+17); line(x+9,y+5,x+9,y+16); arc(x+10,y+7,0,180,1); line(x+10,y+6,x+10,y+16); line(x+11,y+7,x+11,y+13); setcolor(DARKGRAY); line(x-1,y+9,x-1,y+8); line(x-1,y+8,x+1,y+6); line(x+1,y+6,x+3,y+10); line(x+3,y+10,x+3,y-1); arc(x+4,y-1,0,180,1); line(x+5,y-1,x+5,y+5); arc(x+6,y+3,0,180,1); line(x+7,y+3,x+7,y+7); arc(x+8,y+5,0,180,1); line(x+9,y+5,x+9,y+9); arc(x+10,y+7,0,180,1); line(x+11,y+7,x+11,y+13); arc(x+7,y+13,-90,0,4); line(x+7,y+17,x+3,y+15); line(x+3,y+15,x+1,y+13); line(x+1,y+13,x-1,y+9); &#125; break; case 2: //光标 &#123; setcolor(DARKGRAY); setlinestyle(0,0,1); line(x+1,y-1,x+9,y-1); line(x+1,y+15,x+9,y+15); line(x+5,y-1,x+5,y+15); &#125; break; case 3: //十字 &#123; setcolor(WHITE); setlinestyle(0,0,1); line(x-1,y+7,x+11,y+7); line(x+5,y-1,x+5,y+15); &#125; break; default: //默认鼠标 &#123; setlinestyle(0,0,1); setcolor(WHITE); line(x,y,x,y+13); line(x+1,y+1,x+1,y+12); line(x+2,y+2,x+2,y+11); line(x+3,y+3,x+3,y+10); line(x+4,y+4,x+4,y+12); line(x+5,y+5,x+5,y+9); line(x+5,y+11,x+5,y+14); line(x+6,y+6,x+6,y+9); line(x+6,y+13,x+6,y+15); line(x+7,y+7,x+7,y+9); line(x+8,y+8,x+8,y+9); line(x+9,y+9,x+9,y+9); setcolor(DARKGRAY); line(x-1,y-1,x-1,y+14); line(x-1,y+14,x+3,y+11); line(x+3,y+11,x+3,y+12); line(x+3,y+12,x+4,y+13); line(x+4,y+13,x+4,y+14); line(x+4,y+14,x+7,y+17); line(x+7,y+17,x+7,y+13); line(x+7,y+13,x+6,y+12); line(x+6,y+12,x+6,y+11); line(x+6,y+11,x+5,y+10); line(x+5,y+10,x+11,y+10); line(x+11,y+10,x-1,y-2); &#125; break; &#125;&#125;void mou_pos(int *nx,int *ny,int*nbuttons)//更改鼠标位置&#123; int x0=*nx,y0=*ny; mread(nx,ny,nbuttons); clrmous(x0,y0); save_bk_mou(*nx,*ny); drawmous(*nx,*ny);&#125;void mread(int *nx,int *ny,int*nbuttons)//改坐标不画&#123; int x0=*nx,y0=*ny,buttons0=*nbuttons; int xnew,ynew,buttonsnew; do&#123; regs.x.ax=3; int86(51,&amp;regs,&amp;regs); buttonsnew=regs.x.bx; delay(10); regs.x.ax=3; int86(51,&amp;regs,&amp;regs); if(regs.x.bx==buttonsnew) *nbuttons=regs.x.bx; else *nbuttons=buttons0; xnew=regs.x.cx; ynew=regs.x.dx; &#125;while(xnew==x0&amp;&amp;ynew==y0&amp;&amp;*nbuttons==0); *nx=xnew; *ny=ynew;&#125;/***************************************FUNCTION: mreadDESCRIPTION: 获取新的寄存器信息INPUT: nx,ny,nbuttonsRETURN: 无****************************************///void mread(int *nx,int *ny,int *nbuttons) //&#123;// regs.x.ax=3;// int86(51,&amp;regs,&amp;regs);// *nx = regs.x.cx;// *ny = regs.x.dx;// *nbuttons = regs.x.bx;//&#125;/*******************************************FUNCTION: newmouseDESCRIPTION: 鼠标状态发生变化则更新鼠标INPUT: nx,ny,nbuttonsRETURN: 无********************************************/void newmouse(int *nx,int *ny,int *nbuttons)&#123; int xn,yn,buttonsn; int x0=*nx,y0=*ny,buttons0=*nbuttons; mread(&amp;xn,&amp;yn,&amp;buttonsn); *nx = xn; *ny = yn; *nbuttons = buttonsn; if(buttons0 == *nbuttons) *nbuttons = 0; //使得能连续按键 if(xn == x0 &amp;&amp; yn == y0 &amp;&amp; buttonsn == buttons0) return; //鼠标状态不变则直接返回S clrmous(x0,y0); //说明鼠标状态发生了改变 save_bk_mou(*nx,*ny); drawmous(*nx,*ny);&#125;void save_bk_mou(int nx,int ny)//存鼠标背景&#123; int size; size=imagesize(nx-1,ny-2,nx+11,ny+17); buffer=malloc(size); if(buffer!=NULL) getimage(nx-1,ny-2,nx+11,ny+17,buffer); else printf(&quot;Error&quot;);&#125;void clrmous(int nx,int ny)//清除鼠标&#123; if(flag==1) &#123; setwritemode(XOR_PUT); mouse(nx,ny); putimage(nx-1,ny-2,buffer,COPY_PUT); free(buffer); flag=0; setwritemode(COPY_PUT); &#125;&#125;void drawmous(int nx,int ny)&#123; if(flag==0) &#123; setwritemode(COPY_PUT); mouse(nx,ny); flag=1; &#125;&#125;//如果在框中点击，则返回1；在框中未点击，则返回2；不在框中则返回0int mouse_press(int x1, int y1, int x2, int y2)&#123; //在框中点击，则返回1 if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 1) &#123; return 1; &#125; //在框中未点击，则返回2 else if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 0) &#123; return 2; &#125; //在框中点击右键，则返回3 else if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 2) &#123; return 3; &#125; else &#123; return 0; &#125;&#125; 后续补充（完结撒花&emsp;整个程序的源代码。需要解压密码，可以通过邮件获取，或者自己蒙。什么？你问我为什么要解压密码，当然是因为知识产权了，毕竟不是我一个编写的，还是不能随意传播，而且用处不大，你只需要学习就可以了，而且❀可A院这个爆烂的C应该不久会淘汰吧？或许会换新的爆烂。 点击下载源代码 如果不出意外，这个系列更新应该是无了。如果以后有幸帮学妹学弟搞这玩意，又有了新的东西和新的羁绊，我或许会再加一点东西。现在已经不想更了，因为这一切都和我没关系了（doge），我写的时候可没有像我这么好的人专门花大量时间搞这个。。。 愿世上再无C课设——7.29.2024 完结散花 10.26.2024——最终删减修改。（这种东西，过了就行，没必要花过多时间在这上面]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
</search>
