<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新闻学的魅力]]></title>
    <url>%2F2024%2F08%2F28%2F20240828%2F</url>
    
      <content type="text"><![CDATA[浅谈语言魅力——以一则新闻为例preface: 语言，尤其是中文，是很有深意的。同样的一件事情，用一种语言，可以表达出完全不一样的意思。这就是新闻学啊。类似于各种潜规则，语言也有潜在的意思。就让我们以一则新闻为例子。 这里的第二大段：老人家属赶来后…… 我们可以分析，向家属解释相关情况，这里应该是怎样的。也不过就是说，我看到老人摔倒了，然后把他扶起来了。但是，这里却说，情绪激动的老人，推搡，掌锢，争执不下。那么我请问，老人家属赶来的时候，老人是什么状态？为何家属一来，老人就不醉了？还激动了起来?? 于是，可以猜想，1.老人本身清醒的，等家属来了可以趁此敲诈。2.老人不清醒，误以为是被撞的。但我认为不太可能，首先老人不可能倒在地上很久，应该是跌倒后，小孟就看到了。否则这社会也太颠了。其次老人也不太可能连自己撞没被撞都不知道吧？如果是喝醉，为何家属没来时不发作？家属一到了就清醒了？ 我们看这一段：老人家属则执意要求…… 难道说老人家属就不知道时小孟好意扶起来的吗？我想家属也大概是心知肚明的，要赔偿也是肯定的，毕竟没有实质性的证据。 这里的“会不会真的” “民警心里也犯了嘀咕”，就很好笑了。一个还在读书的青年，还能怀疑到了？这里很明显的就是 出事有责 的现象。出了事情，必须不能闹大，要有人背锅。倘若没有监控，我想说，即使所有人都知道人家是主动去扶老人的，但还是会被罚。 这里还用到了见义勇为这个词语，未免隐射了 当代，连扶老人也成了一件有风险的事情。唉！人与人之间的信任的脆弱，可见一斑了。 这里的老人家属意识到了自己的错误，连连道歉.. 更是可笑，大人也是经历过社会，有一定见识的人了，也懂人情世故。连连道歉难道是真心的吗？我想，大部分都是走个过场罢了。 最后这里说并不后悔，但我想说，即使小孟真的没有丝毫后悔，而且下次碰见也会毫不犹豫的去做，那别人呢？那些犹豫不决的人呢？包括我，我一定也会先思考，或许我也会视而不见，扪心自问。谁想碰到这种敲诈呢？谁有那么多时间被这种事浪费呢？也就当代学子罢了。 ——8.28.2024 附：碰见这种事，要先留下证据等，防人之心不可无，虽然我很无奈，但奈何对于大部分人来说，的确如此！]]></content>
    
  </entry>
  <entry>
    <title><![CDATA[订书机]]></title>
    <url>%2F2024%2F08%2F27%2F20240827%2F</url>
    
      <content type="text"><![CDATA[订书机——我不知道的那些事preface:在装订废稿纸的时候，一时兴起搜查了很早之前就有的疑惑，于是便知道了一些大多人可能并不知道的事。 &emsp;为了方便，请看图片 这个订书机右边那一片金属片是干什么的呢？我一直以为是放长方体盒子（订书钉），或者来压平纸张的。但实际并不好用，结果一查，原来是用来撬起钉子的。 总所周知，这个铁片是可以向上掰起，并且旋转180°的，小时候我也这样做过，但直到此时此刻，我才知道，这也是一种订书方式，如下图 可以看到，左边为不常用的，右边是我们一直以来的订书方式。两种不同在于钉腿的咬合方向，左边是向外，右边是向内。所以，可以知道，左边适用于临时装订，后面要分开的那种。就说这么多了 ——8.27 结语：原来一个小小的订书机竟然隐藏了如此多的功能！在日常生活中，我们往往习惯于按部就班地使用某些工具，却忽略了它们的多种用途。通过这次对订书机的探索，我们不仅发现了它的独特设计和功能，更提醒我们要以好奇心去发掘和了解那些我们习以为常的事物，或许会有更多意想不到的收获。—by gpt]]></content>
    
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语标题大小写原则]]></title>
    <url>%2F2024%2F08%2F13%2F202408131%2F</url>
    
      <content type="text"><![CDATA[【英语】标题首字母大小写规则preface: 转载自网上，遵循互联网传播原则（直接照搬的。个人建议直接看一遍记住，用到生活中就不会忘 在阅读英文资料时，最常接触的英语标题大写方式有两种，一种是全部字母大写，另一种是部分单词首字母大写。如： THE TRUE COST OF BEING LAST IN LINE ——《哈佛商业评论》The Case of the Offensive Band Name （the本不应该大写，这里大写是因为首字母） ——《读者文摘》 其中，前一种较少用，而后一种最为常用。为何？小站认为原因在于前一种多用于强调，而不太利于阅读。 对于后一种方式，一般知道最多的就是，标题中的实词首字母需要大写，而虚词则一律小写。其实，这只是最基本的要求。下面就带大家看看还有哪些具体的规则。 基本规则 ⭐规则1：永远大写标题的第一个和最后一个单词的首字母，无论这两个单词是什么词性。规则2：永远大写以下5类单词的首字母：名词、代词（We、I、He）、动词、形容词、副词。规则3：永远大写5个及以上字母的单词，无论这个单词是什么词性。介词举例：Among, Between, Within连词举例：Although, Because, Until 2 哪些单词不能大写首字母？字母少于5个的介词和连词。介词举例：at, down, for, from连词举例：and, as, but, for, if冠词：a, an, the 。to（即使是作为不定式出现）。 3 常用虚词分类汇总如果有些小伙伴仍然感觉拿捏不清，别担心，下面小站把常用虚词做个汇总，分成两列，请收藏本文，随时需要随时翻开查阅即可。 大写：About, Above, Across, After, Against, Along, Although, Among, Around, Because, Before, Behind, Below, Beneath, Beside, Between, During, Except, Inside, Outside, Since, Through, Toward, Under, Underneath, Unless, Until, Whenever, Where, Whereas, Wherever, While, Within, Without小写：a, an, and, as, as if, as long as, at, but, by, even if, for, from, if, if only, in, into, like, near, now that, nor, of, off, on, on top of, once, onto, or, out of, over, past, so, so that, than, that, the, till, to, up, upon, with, when, yet最后，一些细心的小伙伴可能会发现一些比较糟心的词组，比如“as Though”，就是一个要小写首字母、一个要大写首字母。 转载自：https://blog.csdn.net/weixin_42468475/article/details/134052240 参考：https://zhuanlan.zhihu.com/p/447542998]]></content>
    
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于音乐插件的一些解释]]></title>
    <url>%2F2024%2F08%2F13%2F20240813%2F</url>
    
      <content type="text"><![CDATA[Something about the vip musicpreface: 突然发现插件里面的音乐好多突然全要vip了？（以前不用 &emsp;插件用的是wwy的，只能听免费的歌，如果是自己本地上传的歌创建的歌单，似乎会错乱。但是据我寻找，别人的bl似乎可以正常运行，用的其他插件。具体方法难以找到，所以该问题只能等到换域名（或者换笔记本）之后重新搭建时解决。 当然，这里面的歌曲名字，有些也很抽象，原因可能是wwy官方没有这首音乐（可能是免正版功能吧。 音乐设置了自动播放，插件是用了MetingJS 部分参考链接使用插件aplayer和MeingJS在hexo文章内添加音乐-CSDN博客 APlayer &amp; MetingJS 音乐播放器使用指南 - 流纹 - 博客园 (cnblogs.com)]]></content>
    
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>complaint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循迹的实现思路]]></title>
    <url>%2F2024%2F08%2F05%2F20240805%2F</url>
    
      <content type="text"><![CDATA[基于BC的循迹动画的一种实现思路preface: 总所周知，在BC中实现动画，一般只能实现一些比较简单的直线，或者特定的斜线运动，但是如果要实现完全不确定的斜线运动，或者更加复杂的运动，至少我完全没有思路。所以呢，在大概4月份，受到了小车循迹的启发，便写出了下面的代码，作为一种思路。你可以发现，我队友实现的无人机避障等功能就是依据下面的思路改进完善的。原理很简单，相信理解起来不难，但是想完善、优化并非一朝一夕之事。 代码如下，只是演示思路，所以并没有很完善 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//画无人机的函数，不用看，不用看，不用看，不用看，不用看，不用看。void drfdrone(int x, int y)//xy是左上角坐标&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); //circle(x + 12, y + 12, 4); fillellipse(x + 12, y + 12, 4, 4); rectangle(x + 8, y + 9, x + 15, y + 15);// floodfill(x + 12, y + 12, DARKGRAY); line(x + 5, y + 4, x + 9, y + 8); line(x + 3, y + 4, x + 9, y + 9); line(x + 3, y + 5, x + 8, y + 10); line(x + 9, y + 1, x + 1, y + 9); line(x + 8, y + 1, x + 0, y + 9); line(x + 7, y + 1, x + 0, y + 8); line(x + 15, y + 8, x + 19, y + 4); line(x + 15, y + 9, x + 20, y + 4); line(x + 15, y + 10, x + 20, y + 5); line(x + 15, y + 0, x + 24, y + 9); line(x + 16, y + 0, x + 24, y + 8); line(x + 14, y + 1, x + 23, y + 9); line(x + 16, y + 15, x + 21, y + 20); line(x + 15, y + 15, x + 20, y + 20); line(x + 14, y + 16, x + 20, y + 21); line(x + 24, y + 15, x + 15, y + 24); line(x + 24, y + 16, x + 16, y + 24); line(x + 24, y + 14, x + 14, y + 24); line(x + 9, y + 15, x + 3, y + 21); line(x + 8, y + 15, x + 3, y + 20); line(x + 9, y + 16, x + 4, y + 21); line(x + 0, y + 15, x + 9, y + 24); line(x + 0, y + 16, x + 8, y + 24); line(x + 0, y + 14, x + 10, y + 24);&#125;//简单的void move11(int* x, int* y, int* buffer1)&#123; //这里的xy 是无人机现在的坐标 int a[3][3];//储存无人机坐标3*3的正方形区域点的颜色,9个点 int i; int j; int temp1, temp2; int judge = 1; int dx, dy; //下面应该是核心功能的实现思路。。。。。。 while (1) &#123; for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 3; j++) &#123; temp1 = i - 1; temp2 = j - 1; a[i][j] = getpixel(*x + temp1, *y + temp2);//注意这里实现了对 无人机坐标 （正方形中心）边长为5的矩形区域点列 //的颜色get if (a[i][j] == BLUE) &#123; judge = 0; &#125; &#125; &#125; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 3; j++) &#123; if (a[i][j] == BLUE) &#123; temp1 = i - 1; temp2 = j - 1; dx = temp1; dy = temp2; putpixel(*x, * y, RED);//无人机运动过后,清除该点颜色。 //注意这里没考虑路线交叉的情况。。。。。。。 *x += dx; *y += dy; &#125; &#125; &#125; &#125;&#125;void dronemove1(void)//这里不是核心&#123; //-======================================================== void* buffer1 = malloc(imagesize(0, 0, 25, 25)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i; *x1 = 100;//注意这里的初始化 *y1 = 100; move11(x1, y1, buffer1); free(buffer1); free(x1); free(y1);&#125;//主函数void main(void)&#123; int gd = VGA;//graphdriver int gm = VGAHI;//graphmode initgraph(&amp;gd, &amp;gm, &quot;C: \\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 setbkcolor(WHITE);//background color setcolor(RED); setfillstyle(1, RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//右上角画 退出 setcolor(GREEN); line(80, 100, 520, 100);//画标题 rectangle(220, 120, 420, 200); rectangle(220, 240, 420, 320); rectangle(220, 360, 420, 440); //++++++++++++++ //这里应该是运动的路径，可以随意更改。这里的循迹是根据颜色来的，蓝色为路径，无人机行驶过后就会变色 setcolor(BLUE); line(100, 100, 200, 200); line(200, 200, 400, 300); while (1) &#123; dronemove1();//动画，加while应该是便于观察。 &#125; closegraph();&#125; 这里的演示没有考虑到路线交叉等复杂情况，具体怎么完善可以看看C课设拯救计划中我队友的代码（具体文件是哪个我也不知道，或者看演示也行）。这里的主要原理是先画出路径的线（假定为蓝色），然后编写一个函数判断无人机这个点 旁边的点的颜色，使得无人机向周围蓝色的点移动，然后把这个点换别的颜色。（我现在也看不懂我的代码写的啥。思路就是这样 bye~~~ ——8.05.2024]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品书记]]></title>
    <url>%2F2024%2F08%2F05%2Fconmyreading%2F</url>
    
      <content type="text"><![CDATA[My Diary of Reading Bookspreface: 浅记一下，浅评一下，不接受任何反驳 &nbsp; 我认为的文学&emsp; 广为流传的文学是很难得的，由此，我们不难猜测，能够广为流传的文学作品，一定是有所共性的，这也就意味着，能够流传的文学作品，也必然会缺失什么。像四大名著，小说形式、表达含蓄隐晦。这种方式很巧妙。因为不同的人，看同一个作品往往只根据自己的想法和理解来评价，于是乎，一个能够包容很多，有很多解读方式的作品，就能满足大部分人的认同感。倘若一部文学作品，是完全直勾勾的表达作者的观点，那么我想，如果没有时代、气运什么的外部推动的加成，是不可能流传起来的（当然，不排除被骂得风行一阵子）。一本书，往往作者写的时候是按照自己的一种想法来写的，解读出来，就有了千变万化的隐喻，给人一种很高大尚的感觉，高不可攀，说的天花乱坠。但实际往往并非如此。我只问一句，写这么多的隐喻讽刺有什么用呢？难道一切会改变哪怕一丢丢呢？ &emsp; 我想，文学应该是一种个人的东西，是自己的牢骚，是自己的表达。文学倘若要得到大多数人的认可，在当下这种难以言语的环境下，必须得失去一些东西才行。至于这些东西重不重要，那就不得而知了。就我回忆从小到现在的人生经历，我没有体会到任何所谓的文学滋养，我所学的东西都是古代的、近代的，现代的呢？显然没有。那么未来呢？想必还是代代相传。那现在的文学发展在一个完全的局外人看来是怎样的呢？毫无生气。日渐式微，没落。就我个人看来，礼乐、礼仪、文明，这些字词显然不适用于现代。就如同我们站在今天的视角来看古代觉得他们可怜，制度落后，仿佛我们有优越感一样，我一直认为，我们也不过是未来人眼中的可悲的古代人罢了（前提是还有未来。 &emsp;总而言之，也不知道言何了 李白能豪迈地说：安能摧眉折腰事权贵，使我不得开心颜！现代又有几人能如此，或者哪怕有一丝想法？义务教育在教导，但社会现实呢？这何尝又不是一种讽刺。这是最好的时代，这是最坏的时代。我想，省略了“看似”和“实则”这两个词罢… … ——8.13 如何看待现实中艺术创作者和其作品之间的关系&emsp; 答：分开来看。不要因作品而推崇作者，不要因作者而否定作品。 这里直接引用一些段落：（并不代表本人的观点，只是说有些地方颇有启示意义 我始终觉得，真正残酷的其实是观众。他们时常不同程度地被肉眼看到的表象或者自己一厢情愿认定的“真实”所迷惑。他们认为自己理解艺术家的艺术、充分了解对方的品格和行为方式，稍有差池就引发毫无根据的论战与不满。之所以说此类纷争与不满缺乏根据是在于一个很简单的理由：对于任何一个人的人格与人品，若非经过一定时间的亲身接触与观察，是无法得到相对客观结论的；至于观众所接触到的到底是什么呢？首先是作品，然而作品与人品、美学与道德是没有必然联系的；其次就是经由包括电视、广播、报纸、图书、网络等各种媒体所传播的、大量经过人为加工而成的间接信息。以艺术家的作品为基础，辅以各种未必完整客观的二手信息，并自行添加想象的泡沫而产生的结晶，就是观众心中所认定的那个“真实的艺术家”。就在这个摇摇欲坠缺乏客观基础的认识平台上，为彼此认识上的差异反复进行论争与辩驳，怎么看都是一件让人啼笑皆非的事。其实大可不必舍近求远，只要扪心自问：在日常生活中，你能够百分百保证自己真正了解谁？你是否能够理解和包容他们的过去和他们的缺陷？在思考了这个问题之后，再去重新审视对心中那位遥不可及的艺术家的固有评价，或许就可以心平气和地对自己的想法做出适当调整了吧。原文链接 这和作者的作品有什么关系。毕加索虽然渣，但是作品依然有艺术价值；郁达夫情感生活也风评不佳，也不耽误我们欣赏《沉沦》，在国内同性之爱还zz不正确呢，那我就不能看维特根斯坦和福柯了吗？以及zz正确这真的是个褒义词吗链接 （附：正止 Maybe it comes down to this: For people able to separate the artist from the art, whatever the habits good or bad of its creators, as Gertrude Stein might have put it, “The art is the art is the art.” Can We Separate Art from the Artist? Should We? **I think it isn’t either&#x2F;or; its much more complicated. Sometimes it is good and necessary to separate. Art is created by imperfect beings. The fact that imperfect beings, even those who in some ways are horrible people, can at times create something beautiful should give us pause before we cancel or censor it. Should We Separate the Art from the Artist? - Open to Debate** &nbsp; The Moon and Sixpence 知书，知作者（中文为浏览器插件翻译，显然有些地方不准确） W. Somerset Maugham（毛姆）​ The Moon and Sixpence, novel by W. Somerset Maugham, published in 1919. It was loosely based on the life of French artist Paul Gauguin. ​ W. Somerset Maugham (born Jan. 25, 1874, Paris, France—died Dec. 16, 1965, Nice) was an English novelist, playwright, and short-story writer whose work is characterized by a clear unadorned style, cosmopolitan settings, and a shrewd understanding of human nature. ​ Maugham was orphaned at the age of 10; he was brought up by an uncle and educated at King’s School, Canterbury. After a year at Heidelberg, he entered St. Thomas’ medical school, London, and qualified as a doctor in 1897. He drew upon his experiences as an obstetrician in his first novel, Liza of Lambeth (1897), and its success, though small, encouraged him to abandon medicine. He traveled in Spain and Italy and in 1908 achieved a theatrical triumph—four plays running in London at once—that brought him financial security. During World War I he worked as a secret agent. After the war he resumed his interrupted travels and, in 1928, bought a villa on Cape Ferrat in the south of France, which became his permanent home. ​ His reputation as a novelist rests primarily on four books: Of Human Bondage (1915), a semi-autobiographical account of a young medical student’s painful progress toward maturity; The Moon and Sixpence (1919), an account of an unconventional artist, suggested by the life of Paul Gauguin; Cakes and Ale (1930), the story of a famous novelist, which is thought to contain caricatures of Thomas Hardy and Hugh Walpole; and The Razor’s Edge (1944), the story of a young American war veteran’s quest for a satisfying way of life. Maugham’s plays, mainly Edwardian social comedies, soon became dated, but his short stories have increased in popularity. Many portray the conflict of Europeans in alien surroundings that provoke strong emotions, and Maugham’s skill in handling plot, in the manner of Guy de Maupassant, is distinguished by economy and suspense. In The Summing Up (1938) and A Writer’s Notebook (1949) Maugham explains his philosophy of life as a resigned atheism and a certain skepticism about the extent of man’s innate goodness and intelligence; it is this that gives his work its astringent cynicism. ​ W·萨默塞特·毛姆（W. Somerset Maugham，1874 年 1 月 25 日生于法国巴黎，1965 年 12 月 16 日卒于尼斯）是一位英国小说家、剧作家和短篇小说家，其作品的特点是清晰朴素的风格、国际化的背景和对人性的敏锐理解。 ​ 毛姆在10岁时成为孤儿;他由叔叔抚养长大，并在坎特伯雷国王学校接受教育。在海德堡学习一年后，他进入伦敦圣托马斯医学院，并于 1897 年获得医生资格。他在第一部小说《兰贝斯的丽莎》（Liza of Lambeth，1897）中借鉴了他作为产科医生的经历，这部小说的成功虽然很小，但鼓励他放弃了医学。他在西班牙和意大利旅行，并于1908年取得了戏剧上的胜利——同时在伦敦上演了四部戏剧——为他带来了经济上的保障。在第一次世界大战期间，他是一名秘密特工。战后，他恢复了中断的旅行，并于 1928 年在法国南部的费拉角购买了一栋别墅，成为他的永久住所。 ​ 他作为小说家的声誉主要取决于四本书：《人类的束缚》（1915 年），这是一部半自传体作品，讲述了一位年轻的医学生走向成熟的痛苦过程;《月亮与六便士》（The Moon and Sixpence，1919年），以保罗·高更（Paul Gauguin）的生平为背景，描绘了一位非传统艺术家的作品;蛋糕和啤酒 （1930），一位著名小说家的故事，被认为包含托马斯·哈代和休·沃波尔的漫画;以及*《剃刀的边缘》（1944* 年），讲述了一位年轻的美国退伍军人寻求令人满意的生活方式的故事。毛姆的戏剧，主要是爱德华时代的社会喜剧，很快就过时了，但他的短篇小说越来越受欢迎。许多人描绘了欧洲人在陌生环境中的冲突，这些冲突激起了强烈的情感，而毛姆在处理情节方面的技巧，以居伊·德·莫泊桑的方式，以经济和悬念而著称。在《总结》（1938年）和《作家的笔记本》（1949年）中，毛姆将他的生活哲学解释为一种无神论和对人类天生善良和智慧程度的怀疑;正是这一点使他的作品具有严厉的愤世嫉俗。** 09-01一些句子： 牛奶是好东西，尤其是在它里面加上了几滴白兰地，就更好喝了，可母牛却巴不得让人快点把它挤掉。憋胀的乳头是很不舒服的。 苦难、不幸却往往使人变得心胸狭小，具有报复心理。 目前是看完了主人公思特里克兰德离开其家庭的部分，“我”接下来将会遇见主人公。由于时间有限，这里就先不对上面的句子和文章作分析，后面有时间再写吧。]]></content>
    
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>观书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自制作简易扫雷]]></title>
    <url>%2F2024%2F08%2F01%2F20240807%2F</url>
    
      <content type="text"><![CDATA[基于Borland C3.1开发的简单扫雷preface: 暑假让我弟学这个爆烂的C，让他自己学学C语言，编出个扫雷的基本功能就可以，没想到，编写了大概有一周的时间，才画好了界面？所以昨天一晚上，加上今天一上午，下午一点时间，便自己用爆烂的C （凭借着死去的C课设记忆）编出了一个堪称能玩的扫雷代码。当然，考虑到我弟的水平，只用了一个main.c文件，和祖传的鼠标库，就完成了这个简单的游戏。下面分享一下，当然功能还不够完善，而且思路不是特别好，（用的一维数组，大意了）。有很多可以简化改进之处，但是好歹能跑，也几乎没有任何的bug 游戏界面如下： 代码如下：（这里鼠标库就不放了，源码可以直接到C课设拯救计划里面找，还要下一个BC3.1，然后就能畅玩扫雷了！） main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;#include&quot;mouse.h&quot;void drawbackground(void);void bomb(int bombxy[10]);int checkbomb(int bombxy[10]);void inputbox(int(*temp)[4]);int checkifin(int now, int box[10]);void showbomb(int out[10], int box[81][4]);int showshuzi(int i, int out[10], int box[81][4]);void setzhanai(int box[81][4], int cankao[81]);void clearzero(int i, int out[10], int box[81][4]);//0void judgeifwin(int box[81][4]);void main(void)&#123; int *a ; int i,j; int out[10]; int gd=VGA;//graphdriver int gm=VGAHI;//graphmode int box[81][4];//储存81个格子的坐标，左上和右下。 initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 mouseinit(); *a = 1; while (1) &#123; int all; int saveclick[81] = &#123;-1&#125;; int cankao[81] = &#123; 0&#125;; if (*a != 1) &#123; break; &#125; if (*a == 1) &#123; drawbackground(); bomb(out); inputbox(box); setfillstyle(1, WHITE); bar(420, 350,601,409); *a = 2; &#125; MouseX = 640;//防止鼠标留痕，挡住扫雷界面；因为不加就会 MouseY = 0; while (1) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); setzhanai(box, cankao); judgeifwin(box); for (i = 0; i &lt; 81; i++) &#123; if (mouse_press(box[i][0], box[i][1], box[i][2], box[i][3]) == 1) &#123; if (checkifin(i,out) == 0)//点击的区域不是雷 &#123; clrmous(MouseX, MouseY); setfillstyle(1, LIGHTGRAY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); clearzero(i, out, box); &#125; else if (checkifin(i,out) == 1)//game over &#123; showbomb(out, box); outtextxy(420, 350, &quot;GAME OVER&quot;); while (1) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); if (mouse_press(418, 41, 600, 103) == 1) &#123; break;//退出游戏 &#125; if (mouse_press(422, 237, 630, 297) == 1) &#123; *a = 1; clrmous(MouseX, MouseY); break;//再来一局游戏 &#125; &#125; &#125; &#125; &#125; if (mouse_press(418, 41, 600, 103) == 1) &#123; break;//退出游戏 &#125; if (mouse_press(422, 237, 630, 297) == 1) &#123; *a=1; clrmous(MouseX, MouseY); break;//再来一局游戏 &#125; &#125; &#125; delay(100);//程序结束运行 closegraph();&#125;void judgeifwin(int box[81][4])&#123; int i; int count = 0; for (i = 0; i &lt; 81; i++) &#123; if (getpixel(box[i][0]+5, box[i][1]+5 ) == DARKGRAY) &#123; count++; &#125; &#125; if (count == 10) &#123; outtextxy(420, 350, &quot;YOU WIN!&quot;); &#125;&#125;void clearzero(int i, int out[10], int box[81][4])//0&#123; int judge; int j; int a[8]; a[0] = i - 10; a[1] = i - 9; a[2] = i - 8; a[3] = i - 1; a[4] = i + 1; a[5] = i + 8; a[6] = i + 9; a[7] = i + 10; judge = showshuzi(i, out, box); if (judge == 0) &#123; if (box[i][0] &gt; 40 &amp;&amp; box[i][1] &gt; 120 + 40 &amp;&amp; box[i][2] &lt; 360 - 40 &amp;&amp; box[i][3] &lt; 480 - 40)//周围有八个格子 &#123; for (j = 0; j &lt; 8; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if (i == 0) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[4], out, box); showshuzi(a[6], out, box); showshuzi(a[7], out, box); &#125; else if (i == 8) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[3], out, box); showshuzi(a[5], out, box); showshuzi(a[6], out, box); &#125; else if (i == 72) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[1], out, box); showshuzi(a[2], out, box); showshuzi(a[4], out, box); &#125; else if (i == 80) // || i == 8 || i == 80 || i = -72) &#123; showshuzi(a[0], out, box); showshuzi(a[1], out, box); showshuzi(a[3], out, box); &#125; else if (i &gt; 0 &amp;&amp; i &lt; 9) &#123; for (j = 3; j &lt; 8; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if (i &gt; 72 &amp;&amp; i &lt; 81) &#123; for (j = 0; j &lt; 5; j++) &#123; showshuzi(a[j], out, box); &#125; &#125; else if ((i / 9) &gt; 0 &amp;&amp; (i / 9) &lt; 8 &amp;&amp; ((i % 9) == 0)) &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 0 || j == 3 || j == 5) &#123; ; &#125; else &#123; showshuzi(a[j], out, box); &#125; &#125; &#125; else &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 2 || j == 4 || j == 7) &#123; ; &#125; else &#123; showshuzi(a[j], out, box); &#125; &#125; &#125; &#125;&#125;int showshuzi(int i,int out[10],int box[81][4])//显示第i-1个方块的数字&#123; int ji; int j; int a[8]; char buffer[10]; ji = 0; a[0] = i - 10; a[1] = i - 9; a[2] = i - 8; a[3] = i - 1; a[4] = i + 1; a[5] = i + 8; a[6] = i + 9; a[7] = i + 10; if (box[i][0] &gt; 40 &amp;&amp; box[i][1] &gt; 120 + 40 &amp;&amp; box[i][2] &lt; 360 - 40 &amp;&amp; box[i][3] &lt; 480 - 40)//周围有八个格子 &#123; for (j = 0; j &lt; 8; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if (i == 0) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[4], out) == 1) &#123; ji++; &#125; if (checkifin(a[6], out) == 1) &#123; ji++; &#125; if (checkifin(a[7], out) == 1) &#123; ji++; &#125; &#125; else if (i == 8) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[3], out) == 1) &#123; ji++; &#125; if (checkifin(a[5], out) == 1) &#123; ji++; &#125; if (checkifin(a[6], out) == 1) &#123; ji++; &#125; &#125; else if (i == 72) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[1], out) == 1) &#123; ji++; &#125; if (checkifin(a[2], out) == 1) &#123; ji++; &#125; if (checkifin(a[4], out) == 1) &#123; ji++; &#125; &#125; else if (i == 80) // || i == 8 || i == 80 || i = -72) &#123; if (checkifin(a[1], out) == 1) &#123; ji++; &#125; if (checkifin(a[0], out) == 1) &#123; ji++; &#125; if (checkifin(a[3], out) == 1) &#123; ji++; &#125; &#125; else if (i &gt; 0 &amp;&amp; i &lt; 9) &#123; for (j = 3; j &lt; 8; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if (i &gt; 72 &amp;&amp; i &lt; 81) &#123; for (j = 0; j &lt; 5; j++) &#123; if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else if ((i/9)&gt;0&amp;&amp;(i/9)&lt;8&amp;&amp;((i%9)==0)) &#123; for (j = 0; j &lt; 8; j++) &#123; if(j==0||j==3||j==5) &#123; ; &#125; else if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; else &#123; for (j = 0; j &lt; 8; j++) &#123; if (j == 2 || j == 4 || j == 7) &#123; ; &#125; else if (checkifin(a[j], out) == 1) &#123; ji++; &#125; &#125; &#125; //ji代表周围有多少个雷； itoa(ji, buffer, 10); if (ji != 0) &#123; setfillstyle(1, LIGHTGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); setcolor(BLUE); outtextxy(box[i][0]+10, box[i][1]+10, buffer); return 1; &#125; else &#123; setfillstyle(1, LIGHTGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); &#125; return 0;&#125;int checkifin(int now, int box[10])&#123; int i; for (i = 0; i &lt; 10; i++) &#123; if (now == box[i]) &#123; return 1; &#125; &#125; return 0;&#125;void setzhanai(int box[81][4],int cankao[81])&#123; int i; for (i = 0; i &lt; 81; i++) &#123; if (mouse_press(box[i][0], box[i][1], box[i][2], box[i][3]) == 3)//右键点击 &#123; if (cankao[i] == 0&amp;&amp; (getpixel(box[i][0]+10, box[i][1]+10) == DARKGRAY))// &#123; setfillstyle(1, GREEN); clrmous(MouseX, MouseY); bar(box[i][0]+10, box[i][1]+10, box[i][2]-10, box[i][3]-10); cankao[i] = 1; delay(200); &#125; else if (cankao[i] == 1&amp;&amp;(getpixel(box[i][0]+10,box[i][1]+10) == DARKGRAY)|| (getpixel(box[i][0] + 10, box[i][1] + 10)==GREEN)) &#123; setfillstyle(1, DARKGRAY); clrmous(MouseX, MouseY); bar(box[i][0], box[i][1], box[i][2], box[i][3]); cankao[i] = 0; delay(200); &#125; &#125; &#125;&#125;void showbomb(int out[10], int box[81][4])&#123; int i; for (i = 0; i &lt; 10; i++) &#123; setfillstyle(1, RED); clrmous(MouseX, MouseY); bar(box[out[i]][0], box[out[i]][1], box[out[i]][2], box[out[i]][3] ); &#125;&#125;void inputbox(int(*temp)[4])&#123; int i, j; for (j = 0; j &lt; 9;j++)//i确定列数，j确定行数。 &#123; for (i = 0; i &lt; 9; i++) &#123; temp[i + 9 * j][0] = 1 + 40 * i; temp[i + 9 * j][1] = 1 + 120 + 40 * j; temp[i + 9 * j][2] = 40 + 40 * i - 1; temp[i + 9 * j][3] = 40 + 120 + 40 * j - 1;; &#125; &#125;&#125;void bomb(int bombxy[10])//利用返回指针，或者直接传入数组更好；&#123; int i; //总共分成81份； srand(time(NULL)); for (i = 0; i &lt; 10; i++) &#123; bombxy[i] = rand() % 81 + 1;//生成1-81的随机数 &#125; checkbomb(bombxy); &#125;int checkbomb(int bombxy[10])&#123; int i, j; for (i = 0; i &lt; 10; i++) &#123; for (j = i+1; j &lt; 10; j++) &#123; if (bombxy[i] == bombxy[j]) &#123; bombxy[i] = rand() % 81 + 1; i = -1;//重新检查 break; &#125; &#125; &#125; return 0;&#125;void drawbackground(void)&#123; int i; setbkcolor(WHITE); setcolor(GREEN); settextstyle(1, HORIZ_DIR, 2);//HOR...表示横向显示，第二个1表是字体大小。1为小，0默认。2，3..大 outtextxy(432, 60, &quot;exit the game&quot;); outtextxy(437, 256, &quot;restart the game&quot;); rectangle(418, 41, 600, 103); rectangle(422, 237, 630, 297); //============== setfillstyle(1, DARKGRAY); bar(0, 120, 360, 480); setfillstyle(1, YELLOW); bar(0, 0, 360, 120); setcolor(GREEN); rectangle(25, 40, 100, 80); rectangle(150, 40, 220, 80); rectangle(345-75, 40, 345, 80); setcolor(RED); rectangle(0, 120, 360, 480); for (i = 0; i &lt; 10; i++)//画十次 &#123; line(0, 120 + 40 * i, 360, 120 + 40 * i); &#125; for (i = 0; i &lt; 10; i++)//画十次 &#123; line(40 * i, 120, 40 * i, 480); &#125;&#125; 其实代码量也不多，有蛮多有点重复，工作量也就大概400行右吧。个人认为编程这种东西，我们不是主攻的（计算机专业啥的），刚开始学学思路就差不多。谁还死记函数什么啊？我编的时候都经常问gpt，或者借鉴之前写的代码。~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 就这样吧，是时候和祖传的鼠标库说再见了。愿世上再无C语言 ​ ——8.1.2024]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Leaning Of English]]></title>
    <url>%2F2024%2F07%2F20%2Fcon20240720%2F</url>
    
      <content type="text"><![CDATA[Vocabularypreface: In order to dominate myself learning English, reciting English words for CET6, so I write this article. 7.21.2024Word List 1 author 作者，作家。 accord 一致，符合，协议；vi.使一致; vt.授予，赠与。in accord with benefit vt.vi.n. economic n. adj.经济学，经济的。economy issue n. 问题 vt.发行，分发. release, come out of, supply. issue a new uniform to the children. water issued from the hole.. impact n. v. consumer n. focus n. v. climate n. concern n. vt. environment n. challenge n. vt.反对，质疑 positive adj.肯定的 process n.过程，程序 vt.加工处理 culture n.教养 community n.团体，群落 project n. 方案vt.投射，规划，预计推断 academic n.大学老师 adj.不切实际的，学术的 medium n.媒介 adj.中等的 design n. vt. demand n. vt. mental adj. negative n. 负数，（相片）底片adj. species n. decade n. involve vt. remain n. vi. individual n. adj. economy n. expert n. adj.熟练的 compare vt. communication n. account n. vi.占…，说明…的原因 account for argue vi. vt.主张 access n. 入口，进入…的机会vt.获取（计算机信息）have access to potential n. adj. claim n. vt.使死亡，索取，主张 graduate n. 毕业生，研究生adj.研究生的v.（使）毕业 advantage n. emotion n. evidence n. vt.证实 performance n.执行，业绩，工作性能 avoid vt. force n.力，军队(pl.) vt.用力推 financial adj. factor n. disease n. effective adj.(法律上)生效的，有效的 fund n. 资金vt. cognitive adj.认知的 contribute vt.vi.投稿，造成 figure n.数字人物体型，画像，图形 vt.认为，猜想vi计算，出现 protein n. region n.区域，部位，范围 attitude n. management n.管理（人，部门） solution n.溶液 fuel n. vt.刺激，加燃料 insurance n. behavior n. credit encourage poverty attract colleague device engage 吸引 score 计分 current 流 professional n. adj. apply 涂，敷 available detail vt.详细说明 trend unemployment pressure promote similar extreme identify reflect planet beyond ecosystem 生态系统 expense various approach 靠近，方式 despite scale 攀登，天平，大小规模，鳞 conduct 传导，管理 contact expand 扩展，增强 occur 被想起，发生出现。 Word List 2 describe predict statement 结算单 stereotype 陈规 advocate n. vt. associate 伙伴同事；副的联合的；交往；使关联； institution 制度习俗，协会机构 adolescent complex innovation pattern athlete mass purchase release reserve 保留预订；保护区 specific 细节；具体的 consumption crisis debate disaster feature unique efficiency essential generate motivate represent critical fossil 化石 electronic recovery significant status budget character communicate court 法院，球场，庭院 emerge insect maintain object package respond security adopt application charge commercial conventional 传统的，惯用的常规的 option responsible reveal schedule attack concept desire employment estimate productivity response survive vary calorie define enhance executive 执行者；行政的，执行的 principle reward series vulnerable yield 产量；产生，屈服，变形，产出； confidence demonstrate 示威；说明论证，示范演示，表现出； genetic 遗传的；遗传学 ideal 理想；理想的，空想的 ignore illustrate perspective admit audience basis breed 品种；繁殖养育，酿成； cite 表彰，引用，传唤 compete manufacture 制造n. vt. 加工 participant recognition 认可，认出 urban adj. wealth accelerate achievement addition 附加物，加法 7.22.2024Word List 3 aspect 外表，样子 behave candidate consequence contract 合同，感染（病） corporate 公司的，全体的，共同的 depression function haven 保护区，安全的地方 preserve 保护区 psychological 心理(学)的 rely reputation vehicle 机动车，工具 ancient appeal 上诉，恳求 artificial assume 承担，假定 client 当事人，顾客 critic dolphin 海豚 elite expression majority mobile monitor 班长，监测器。监控 patent penguin 企鹅 recession 衰退 revenue 收入收益，税收 sample 样本，体验 supplement 增补，补充；增刊，补充物 wealthy anxiety cancer capacity 容量，才能，地位身份 competitive consume 毁灭 crime decrease explore expose 揭露，使暴露 federal 联邦的 incentive 激励刺激 previous relative strategy aid alternative commitment crowd establish invest label pose \\;pose a threat to priority recover 重新获得，挽回 shrink target vital adapt attach background instance institute resident transport acquire appropriate aware brand chief conservation fascinate 迷住 be fascinated by infant n. adj. massive obtain regulation 规则，控制 therefore transform acknowledge 承认，确认，报偿，感谢 assess 估价，评价 assign debris 垃圾，碎片残渣 emphasis mission norm numerous preference routine tackle afford anticipate Word List 4 association 团体，交往 collaboration 合作，勾结；in collaboration with combine component 部件，组成部分；构成的 discipline 学科，纪律，训练惩罚； eliminate 淘汰 exchange exhaust interaction justify original profession radical recognize transition 过渡转变 trial 试验，审判 accident attribute 特征；be attributed to burden n. vt. characteristic n. adj. conflict domestic enormous 巨大的 guarantee humanity 人类，人性 nutrition 营养 primarily 首先 racial 种族的 rank rarely stock 原料，库存品，公债，牲畜；常用的 alcohol 酒精 attempt brief capable chip 碎片，芯片，缺口 chronic 慢性的，长久的，久病的，积习难改的 commit consult 请教商议查阅 crash creation electric expertise immigrant ingredient interpret item manufacturer notion oppose productive property pursue recycle sufficient superior additional beneficial combination complaint conclude diminish exotic fatigue grant momentum overwhelm passion signal thrive vast annual assistance comprehensive contrast contribution cope distinguish exhibit fiction finance household imply intellectual interact modify presentation reform sanctuary whereas accomplish 7.23.2024Word List 5 accurate adjust administration alter apartment census committee comparison consist consistent convert coral counterpart crucial cycle distract dramatic element equality implement incorporate initiative insight intensive leisure literature mere migrate minimize moral obstacle peak sensitive severe threaten urge version volume accuse alien atmosphere commission convince criticism dean definition deprive devote dinosaur dual efficient emergency equip existence expansion fertilizer fundamental independence isolate orbit polar portray primary questionnaire register ruin sophisticated tendency ultimate universe volunteer web absorb abstract adequate appearance arouse attractive authority bizarre characterize correlate counter deficit discount display diverse extract faculty graphic highlight Word List 6 intense internal investigate lever mall modest navigate objective paragraph predator privacy reject reluctant reverse scheme trait transfer trigger agent array autonomy barely barrier celebrity champion circulation complain confirm congress database destructive detect drill drought epidemic exaggerate excessive fake hypothesis impose inspire legal multiple narrative optimistic phenomenon rational reaction restore rival snack snail upgrade vision absence abuse acupuncture adverse alert arrange assert assumption breakthrough cherish classic collapse compel concentrate conference confident confront consensus controversy deadline deplete derive digest dismiss distinct encounter entertainment float formula foster furniture hinder indifferent intelligent invisible irritate jack literacy Word List 7 livestock melt minimum multiply obligation obsess overcome pasta pest possess proof reliable relieve religious remote resolve sacrifice slip stimulus tenant tremendous tribe underestimate unity virgin virtual abundant accumulate ambitious antibiotic approve bang boom bound classical conscious considerable constant construct criminal depict deserve deteriorate devise distribution dominate engine entrepreneur evolution exclude exploit external facilitate hawk hazard identical incident indulge industrial initial intimate irrigation limitation merely mortgage neglect negotiate occupation outfit penalty persistent premium prime profile prohibit prolong prospect protest pursuit recall relevant rigorous scan specialist stray stream submit subtle texture tolerant undermine]]></content>
    
      <categories>
        <category>leaning</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to study in dorm?]]></title>
    <url>%2F2024%2F06%2F18%2F20240616%2F</url>
    
      <content type="text"><![CDATA[于寝室光明正大的学习preface: 总是看见室友平日说话就是谈打游戏，晚上也是刷手机到个明天还不睡。然而，总是有无声的时候。下床定眼一看，在学习。俗话说：无声才是最可怕的，不怕室友大声游戏，就怕坐在座位上一声不吭。室友也总是莫名其妙的出去，还不忘找一堆借口，有人问，回答也是含糊其辞。作为旁观者，我当然知道是要去学习。但这种行为莫名有些奇怪敷衍，仿佛自己在偷偷摸摸似的（虽然事实也是如此。（那么怎么于寝室光明正大的学习呢？ &emsp; 在宿舍里光明正大地学习可以通过以下几种方法： 公开学习计划：可以在寝室里明确自己的学习计划，比如告诉室友自己每天会在某个时间段进行学习。这不仅能让室友了解你的安排，也能让你自己有更强的学习动机。 合理安排时间：制定一个合理的作息时间表，包括学习、休息和娱乐的时间。这样既能保证高效学习，也能避免因为学习影响到室友的正常生活。 找到合适的学习地点：如果宿舍环境不太适合学习，可以考虑去图书馆、自习室或者其他安静的地方进行学习，这样既能提高学习效率，也能避免与室友的冲突。 与室友沟通：如果室友对你学习时间的安排有疑虑，可以主动与他们沟通，解释自己的学习需求和计划，并寻求他们的理解和支持。 树立榜样：如果你能坚持在宿舍里安静地学习，可能会对室友产生积极的影响，带动他们也一起学习。良好的学习氛围对大家都有好处。 利用空闲时间：利用宿舍安静的时候进行学习，比如早晨或晚上睡觉前的时间，这样既不会打扰室友，也能有效利用时间。 总的来说，关键在于合理安排时间，与室友保持良好的沟通，尽量在不打扰他人的情况下进行学习。如果大家能互相理解和支持，宿舍生活会更加和谐美好。 gpt如是说。 起猛了，用了这么久突然发现gpt4o能生成图片了。但感觉不如下面我自己创作出来了大作美妙（ 反正我个人目前难以做到于寝室里学习，但要我去外面教室自习就目前看来是impossible的。在寝室自习，一个自我控制能力很关键，显然目前我还没有。还要能静下心来。所以我仍然选择呆在寝室里，而不是去教室般的囚笼里进行所谓的学习。 ​ ——6.18.2024]]></content>
    
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么童年的鞋子不见了？]]></title>
    <url>%2F2024%2F06%2F09%2Fxiezi%2F</url>
    
      <content type="text"><![CDATA[魔术贴渐渐淡出preface: If you are very careful and can always be self-reflection, then you may discorve a tiny but interesting question. 在我小时候，鞋子都是没有鞋带的，也就是行业上所说的魔术贴（我那里的dialect namely 黏哒几。 when I was just in senior high school, I gradually rarely seen them in my foot, which are replaced by 鞋带。(((( emsp; 前加&amp;。。（请忽略，缩进字符代码记录,nbsp;断行 &emsp; 正如你所见，如果不出意外，这里应该成功实现了首行缩进。 &emsp; 在今天上午，突然发现，洗一双鞋子用时(waste time)最久的，最烦的果然是把鞋带拔出鞋子。而且想到日后还要重新插入鞋子，而且always忘记哪个孔之后要穿过鞋子中间孔。总而言之，对于难以静下心的student来说，可以称作是痛苦的事情，那么，为什么到了高中、大学、社会，除了皮鞋啥的，我所见到的鞋，几乎都是必带鞋带的呢？ 这里是我检索到的一些资料。 主要原因应该就是如下： 外观。 有鞋带便于把鞋带系的花里胡哨，显得很好看 耐久度。魔术贴耐久不太好，这点确实。鞋带基本用到废弃 紧度。魔术贴紧度只能一部分，鞋带可调节的范围更大。 gpt4o: 回答如下： 有鞋带的鞋子是主流，而有魔力贴（也称为魔术贴、Velcro）的鞋子不是，主要有以下几个原因： 1. 调节与贴合性 鞋带：鞋带可以根据穿着者的需求进行微调，从而使鞋子更加贴合脚部，提供更好的支撑和舒适性。不同的绑法和松紧度可以适应不同的脚型和活动需求。 魔力贴：虽然方便，但其调节范围有限，难以实现鞋带那样精确的贴合性和支撑效果。 2. 牢固性与耐久性 鞋带：鞋带在系紧后能提供更牢固的固定，尤其在剧烈运动时，不容易松脱，提供更好的安全性。 魔力贴：虽然方便快速，但在长时间使用或高强度活动中，魔力贴容易失去粘性，尤其在积尘、沾水后，粘性会下降。 3. 适用范围 鞋带：广泛适用于各种类型的鞋子，包括运动鞋、休闲鞋、登山鞋等。特别是在专业运动鞋领域，鞋带的使用能更好地满足运动需求。 魔力贴：多用于儿童鞋、老年鞋或一些特殊需求的鞋款，如医疗鞋，主要是为了方便穿脱。 4. 外观与时尚 鞋带：鞋带的设计更具多样性，可以通过不同颜色、材质和绑法来增添鞋子的时尚感和个性化元素。 魔力贴：设计较为单一，时尚感和个性化较少。 5. 文化和传统 鞋带：有着悠久的历史和文化传承，已成为鞋类设计的经典元素。人们在心理上更倾向于接受和使用有鞋带的鞋子。 魔力贴：作为一种相对较新的技术，主要被认为是功能性和便捷性的象征，而不是时尚或传统的代表。 综上所述，有鞋带的鞋子在调节性、牢固性、适用范围、外观时尚感以及文化传统方面具有明显优势，这些因素使其成为主流选择。 总而言之，本次更新就如此了。 plus: countless eaxms will come, so I don’t have leisure time to post blogs frequently. 下次更新，大概就是7月中旬了，多亏了那个可爱的 社会实践活动。。。——6.9.2024。(为什么最近没有好康的？因为库存不够)]]></content>
    
      <categories>
        <category>为什么十万个</category>
      </categories>
      <tags>
        <tag>回忆与对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么一坐到椅子上就想睡觉]]></title>
    <url>%2F2024%2F05%2F21%2Fsleep%2F</url>
    
      <content type="text"><![CDATA[How to design a kind of chair for study so students can sleep well? 众所周知，好的椅子要充分体会到使用者的感受，要能够具有多种不同的功能，要能够运用小学所学的生物和物理和数学和英语知识，要运动大学的自动化等等等等。实现全方位一体化自动化，给使用者最好的使用体验……. 那么有一所学校就坐到了这一点。上高数课时，总是一坐上座位就想睡觉，我发现这并不是一件很寻常的事。那么为什么在已知早上睡到9、10点，中午1-4发生的情况下，刚进入教室还精神萎靡的我，一坐上座位就开始犯困睡觉了呢？ 总所周知，问题的根源往往不来自于自己，所以根据和高中时期的对比，必定是椅子的问题。 那么什么样的椅子适合睡觉呢？ 下面是gpt4o的回答。 学生在课堂上容易感到困倦的原因可以涉及到人体生理和心理因素，而选择合适的椅子可以一定程度上减轻这种困倦感。下面是一些物理学和生物学方面的知识，以及根据这些知识来阐释适合学生睡觉的椅子的特征：**（确实，睡着了就减轻了困倦感** 舒适性： 椅子的座椅和靠背应该具有一定的软硬度和弹性，以提供舒适的支撑。过于硬的座椅会增加身体的疲劳感，而过于软的座椅则缺乏支撑性，容易导致姿势不良和疲劳。 正确的坐姿支持： 椅子应该能够提供良好的腰部和背部支撑，以保持正确的坐姿。过于笔直的椅背可能会导致不适，而过于倾斜的椅背则容易让人沉睡。 足够的靠背高度： 靠背的高度应该适中，以支撑学生的上半身，同时不会太高以至于限制学生的头部活动。 座椅深度和宽度： 座椅的深度和宽度应该适中，以确保学生可以舒适地坐在上面，而不会感到拥挤或不稳定。 通风透气性： 椅子的座椅和靠背材料应该具有良好的通风透气性，以防止学生在长时间坐在上面时出现不适或汗湿。 减少压力点： 椅子的设计应该尽量减少对身体压力点的压迫，特别是臀部和背部的压力点，以减轻学生长时间坐姿造成的不适感。 可调节性： 椅子最好具有一定的可调节性，包括座椅高度、靠背倾斜角度等，以适应不同身高和体型的学生。 综上所述，适合学生睡觉的椅子应该具有舒适性、正确的坐姿支持、适中的靠背高度和座椅深度、良好的通风透气性，同时尽量减少对身体压力点的压迫，并具有一定的可调节性。这样的椅子可以帮助学生在课堂上保持舒适的坐姿，减轻疲劳感，从而降低入睡的可能性。 首先让我们欣赏一下座位椅子的构型。 映入眼帘的是宽大的木板平面，可以自然而然的联想到，这张富有历史悠久感的看似平平无奇的木板，几乎每天每两节课都有着不同的主人。而很容易推知，汗液和衣服就是他洗澡的水和毛巾。当我们坐上去时，便在无形中催化了一些潜移默化的美妙的化学反应，使得坐上去的生物消耗了一些能量，昏昏欲睡，浑身乏力。 再分析其美妙的曲线，完美的符合了人体大腿-屁股这个连接体的形态。极大的增大了化学反应的接触面积，使得反应更加迅速。由此，坐上去的生物能够得到极大的满足。。。 而且通过简单的观察，我们可以看见其完全是自动化的。人椅分离10毫米，椅子自动回位，完美的节省了使用者的能量消耗，延长了使用者的寿命。 这是一张图片。 总而言之，就到此为止。——更新于5.23]]></content>
    
      <categories>
        <category>为什么十万个</category>
      </categories>
      <tags>
        <tag>离奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2024%2F04%2F21%2Ftop%2F</url>
    
      <content type="text"><![CDATA[公告（8.16.2024​ 一些前言 一些小问题： 关于界面加载慢，延迟高：背景图大，文章附图，最好耐心等待一会，或者退出浏览器重输网址。建议减少清理浏览器缓存的频率（因为缓存过后进入本站将更流畅 关于界面的透明，透明确实影响文章字的清晰度，但早已忘记了如何修改，所以就搁置。看不清可以用鼠标选中…… 关于域名。 目前是买了三年，后面极大可能会更换域名，请注意到时候的文章（更换域名的时候也可能会重新搭建blog，文章到时候应该会全部搬迁，有可能会换用其他主题（比如butterfly等等 关于评论。目前需要magic方可注册账号评论，注册最左边——也就是第一个（liveRe）。极少情况下会出现广子，请勿点击和相信。 关于wx二维码，真实有效 关于部分文章需要密码解锁。法1：自己破解。法2：评论区留言（联系方式。法3：线下单杀 关于音乐错乱。请见最近文章： Something about the vip music 其他：待补充……]]></content>
    
      <tags>
        <tag>preface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爆烂的C下载（附）]]></title>
    <url>%2F2024%2F04%2F16%2F7%2F</url>
    
      <content type="text"><![CDATA[爆烂的C下载（附）​ 纯净的BC下载，仅供提前学习 ​ 先说说为什么这么长时间没更新。 原因有很多。一是上周六的数学期中考试，而是C课设马上就验收了。三是四月份的事情实在是太多，又是体测又是其他的，清明也不过一天假，不断的调休。便有了看似很多的三天假期。各种课又多…… 压榨的牲口为数不多的精力。 但为了说明作者仍然活着（这是一件多么可喜的事情），于是便有了这个BC的下载链接。使用方法很简单，解压后，进入DISK_C(我通常把这个文件夹叫作虚拟C盘)，里面的CODE文件夹就是代码区域，BORLANDC文件夹是BC自带的文件。CODE里面的SOURCE文件夹便是你的工作路径。也就是说，你只需要把你编写的.C和.h文件放到SOURCE文件夹中即可。OUTPUT是每次编译会产生的垃圾。可以随时删除。TC0000.SWP也是垃圾。 总之，BC自己摸索，便会使用。 下面提供下载链接 下次更新估计要到五一劳动节。如果没更新，说明挂科了（） 点击下载爆烂的C]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C课设拯救计划]]></title>
    <url>%2F2024%2F03%2F14%2F5%2F</url>
    
      <content type="text"><![CDATA[C课设拯救计划 前言：为什么我要专门耗费时间来写这么一个东西呢？如果你有幸考入了华中柯基大学，又在填志愿的时候阴差阳错的选择了人工智能或者自动化专业，那么你就马上会听闻只存在于传说中的C课设。这种C课设，不仅仅是用了一种已经消失数十年的编译器，即:爆烂的C（Borland C3.1又简称为BC），其所用的函数，语法等等于现代的编译器如VS（Visual Studio)均有所不同。不仅其自身使用起来十分的麻烦，令人恼火，而且你几乎找不到任何什么学习BC编程的途径。所以焦虑是不可避免的。虽然有学长学姐代代相传的帮忙，但这种事是学院默许的，亦可以说是学院支持的。由此，我们从中其实也学不到什么。就我个人体会而言，全靠个人的体会与学习，只能说…。所以对于大部分而言，结果往往是到deadline的时候，猛抄写，篡改前人留下来的代码，或者找到选同样题目的同学…… 所以，我特此写一份较为详细的拯救计划。所谓相见有缘。（doge）（本计划不定期随缘更新，看impulse） BC最基本的用法 首先，不会真的有大佬会用BC这种东西来编写C课设吧。就其作用而言，不建议给自己找痛苦。人生痛苦的事情很多，没必要自己去找。（用其他编译器，也很简单，以后我或许会说到如何简便的编写 先上BC的图片（建议在电脑上食用，手机可能排版会出问题） 建立工程：意思就是把你写的代码变成一个.exe文件（可执行文件，想必自己下游戏资源这种简单的东西应该早就知道了）。如何建立？点击Project 有个open，直接输入新建的pgi(?)的名字（就是把那个*.pgi改成 1.pgi等等），这样就可以add 你自己编写的.c文件了。全部添加进去后，点Run，success就行，最终编写完成，就点Compile （好像还要点Make？）。但前期只要run就行。 其他：其他的东西自己慢慢摸索，差不多就能搞懂了。BC我目前用过的东西有: Edit中的 复制粘贴，主要是修改错误时会用BC直接修改（一些简单的问题）。注意在BC中修改后一定要点File中的save（BC没编译成功不会自动保存）。还有一个就是Window中的Output，可以查看文本窗口的输出，但基本没用（基本都是图形化窗口，用不到） 关于环境配置，其实没什么，所谓环境配置，就是一个简单的设置Options中的Output，和什么什么的。这些东西自己看看就会慢慢理解的。而且，群里都有配置好了的BC，直接用就行。也可以找我要。至于什么纯净的BC，就是没有学长学姐的工程。但大部分你只要把他们写的东西删掉就行了。（除非有大佬自己改BC），关于这些东西，后面会讲到。 你用别的编译器写的汉字，在BC中是无法显示的，原因好像是汉字编码方式，要什么GBK方式。但这些都没有用，只不过可以让你高谈阔论一番，显得自己很厉害罢了。关于BC的一些报错解决方法，日后也会讲到。 自此，我相信你已经学会了使用BC建立工程。虽然你可能还不会编写.c,.h文件。 如果还是不会使用BC，可以去看看别人怎么用的。但基本全靠自己，当然也可以问我，用视频教学（目前还不知道怎么上传视频），前提是你能找到我（doge）。 头文件的编写(三月16日更新) 头文件编写还是有固定的套路的，一般你自己直接复制粘贴就行。 这里介绍通用的模板： 123456#ifndef _COMMON_H_ // 这里的意思是if not define #define _COMMON_H_ //则define; common.h,是你自己命名的头文件名字，注意文件后缀//这里就是函数声明，和一些struct的引用，或者define a 1;什么什么的void hanshu();#endif 那么这个的原理就是条件编译，其目的在于水代码 防止头文件重复包含（？。有兴趣自己去CSDN博客，或者edge什么的搜就行。 当然一般而言我们还会编写一个总头文件，一般命名为common.h; 你可以发现它就是如同这样 1234567891011121314151617181920212223242526272829303132333435363738#ifndef _COMMON_H_#define _COMMON_H_/*----------------------------包含所有的头文件，以后引用头文件只需要 include &quot;common.h&quot;；更加方便，代码简洁----------------------------*/#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//上面是BC自带的头文件，下面为自己编写的//----必备#include&quot;mouse.h&quot;//鼠标库#include&quot;hz.h&quot;//汉字库//--界面#include &quot;welcome.h&quot;//开屏动画#include &quot;mainpage.h&quot;//主界面#include &quot;mainfunc.h&quot;//农田界面#include &quot;history.h&quot;//历史记录界面#include &quot;usehelp.h&quot;//系统说明界面//---func:功能文件#include &quot;move.h&quot;//配合鼠标使用的鼠标move函数#include &quot;showtime.h&quot;//显示时间函数#include &quot;shuju.h&quot;//数据库#endif 当然，这是我编写的尚未完成品。注意自己编写的 头文件最好用”” ，爆烂的C自带的用&lt;&gt;，具体原因有兴趣自己查找。 那么关于头文件的全部暂且就到这里了。当然你建立工程的时候如果把头文件不需要手动添加。 拜拜了~ 贴图的工厂化实现（已完善） 怎么贴图？很简单。爆烂的C可以用祖传的代码，批量化贴图。你根本不需要理解，你只需要CTRL C, CTRL V。n张图片便已经贴上去了。 废话不多说，直接上代码。这是一个使用例子。(? 123bmp_convert(&quot;1.bmp&quot;, &quot;1.dbm&quot;);open_display();show_dbm(100,100, &quot;1.dbm&quot;, 0); 其中，你只需要操作的部分如下： 将1.bmp改成你要贴的图片的名字。不要告诉我你不知道文件后缀是什么。 当然还有所有的1. 其中show_dbm(100，100，…..)，前两个是贴图的位置，左上角坐标。 注意，这种只能贴bmp，而且还要用到ps修改。具体有祖传文件教学。这里我就不提供下载方式了。因为我日后会以图文形式补充，想必大家都能在救助群里找到。 就是这么多了。当然，要#include .h文件。笑 注意，你的贴图文件放在source文件夹内，即和你的.c文件放一起。 为防止还没有人不会，上代码（？？？） 1234567891011121314151617181920212223？#include &lt;stdio.h&gt;#include &lt;graphic.h&gt;#include &lt;image.h&gt;void main()&#123;int gd=VGA;//graphdriverint gm=VGAHI;//graphmodeinitgraph(&amp;gd,&amp;gm,&quot;C: \\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 bmp_convert(&quot;1.bmp&quot;, &quot;1.dbm&quot;); open_display(); show_dbm(100,100, &quot;1.dbm&quot;, 0); bmp_convert(&quot;2.bmp&quot;, &quot;2.dbm&quot;); open_display(); show_dbm(300, 200, &quot;2.dbm&quot;, 0);getch();//鼠标按键后退出closegraph();delay(100)&#125; 虽然不知道有没有问题，但还是暂且认为该代码有问题吧（doge） 附件：贴图祖传代码下载（已经修改，完美适配VGA模式 即640X480下的贴图） 点击下载 1234567891011if(ImageW==0||ImageH==0||ImageW&gt;641||ImageH&gt;481)/////注意注意！！根据实际修改/&#123; printf(&quot;The image is too large!Please input image below 640*480.&quot;); fclose(fbmp); return 1;&#125;if((fdbm=fopen(dbm,&quot;wb&quot;))==NULL)&#123; printf(&quot;Creat \&quot;%s\&quot; error!&quot;,dbm); return 1;&#125; 上述的头文件和.c文件经过了修改，至于.c文件，我们无需看懂原理。上面是.c文件大约40-50行部分代码。这里的Imagew 和ImangHI 要根据实际值修改。否则就会出现 The image is too… 然后贴图失败。。 *这里的贴图的重要一点就是对 图片的处理， 首先要下个VS PS， 然后根据文件中的食用方法来便可。 当然其中有些东西不必在意。如：调用 show_dbm(int x,int y,char dbm,int nowpage)即可在在(x,y)输出图片(x 需为 8 的倍数)，char * dbm 处填入的 dbm 文件地址。 这里的X并不需要为8的倍数。当然，也许只是我们没有理解其原因。但是只要能贴上图就行。 贴图的工厂化实现就是这样了。请低调使用，勿宣传（.jpg） —4.21.2024 报告的借鉴以及验收过程 在4月的27日，也是极其幸运的过了C课设。原因主要来自于本人抽签时一发入魂，抽中了好老师。所以喜提A-。所以，也是上演了一出抽卡现场。验收其实报告几乎不看（所以我用的全局变量也是根本没看，当然据说这个看老师，有老师似乎喜欢看？？），所以没必要过于精细，只是代码分配部分，要把.c谁写的都写明。而我那里并未，所以当场加了。 报告直接借鉴即可食用。 验收过程实际上也很简单。就是要把你的CODE文件夹，复制到机房电脑的C盘（不是桌面）上，然后找到C盘中的Borlandc&#x2F;bin&#x2F;bc.exe。打开那个BC，然后自己改下路径即可。实际上手后十分简单。具体可以参考bilibili中的6个钢镚（?），我这里就不赘婿了，理解了就简单。路径就是文件路径。所以我们在编写的过程中，最好用相对路径。比如文件的打开啥的。 老师的话我们是听我们讲了我们的程序功能。因为我设计了梯田，是相对一个创新的点，所以老师就简单的要我们加个功能。就是让无人机高度在农药喷洒时也显示，也就是一个调用函数的问题。当然，还要调调参数，总之十分简单。但也有老师很考验心态和能力。只能说，验收就是看抽卡。文件操作必须要掌握。我当时认为不需要，结果验收时许多老师都重视，甚至要你改登录注册的代码。（而许多人是直接照搬的…） 就说这么多吧，愿世上再无C课设 –5.5 报告下载 英文输入法 输入法是登陆注册界面必不可少的。那么这里直接提供代码，来源不明。具体如何使用请看编写的原作者（未知）的注释。 这里的输入法明显要和文件操作结合起来比较方便。或者数组之类。但还是用文件操作更好。 这里面呢，就两个函数，对应两种输入法。可视与不可视。调用即可。建议登录注册不必太过高级。基本功能实现即可，因为要么老师根本不看，要么老师要你加这里的功能。比如忘记密码、让输入的密码可视什么的。（而这些都容易实现（所以就有人故意不把程序搞完美，预判老师会要求加的功能… 源文件下载 那么就说这么多吧。虽然更新速度慢，但不是还早着吗？-5.19 编程的开始​ 水了这么久，终于来到了激动人心的编程环节。其实主要是因为不知道该水什么了）那么为了节省一些时间，所以编程开始的讲解主要就是按照 我们那一组编写的代码的顺序来，毕竟，与其自己盲目的学这学那，不如完整的看一遍往届的代码。当然我自己尝试过，不过由于看不懂，所以收获不多。但还是收获良多。（比如时间显示就是看往届代码，贴图实现一开始也是看着抄写的）当然由于种种原因，不开放源代码，毕竟是个人劳动成果，白嫖有害身心健康，所以要得到代码，要么有缘相见，要么找到我，要么评论区随缘（评论要先梯才可注册账号？，评论确实用的网站不好，但不想改了，因为不会。以后换笔记本可能会改。） 那么我们下次更新开始！还有15天高考，我不祝愿各位高考顺利，因为这仅仅是套话罢了，毫无征兆与真诚的祝福……平和之心对待 ——5.23 课设要求&emsp;sorry，被我什么时候删掉了？？？。（23级的所有题也没了，哭（ &emsp;题目是无人机喷洒农药，要求是生长检测，农药配置，无人机喷洒农药。大体来讲就这三点。我编写的时候就是按四个方面来的，生长检测，结果查看，农药配置，农药喷洒。 思路历程&emsp;为什么C课设选题时选到了这道题目？ 答：C课设选题，其实就是开一个大会，许多班的人坐在一个大教室。然后出题老师会分别讲题目的要求（当然，我是一点没听，大多数人也是），然后呢，不知道什么时候，班长就突然说来选题，其实就是在一张打印好的纸上，有题目的序号，填写你和你的队友的名字，学号。而且因为我们班是30个人，有15道题目，所以题目不能重复，就靠抢？（除非你们班班长很公平，想到了用抽签的方式决定选题的先后顺序。） 所以这里建议选题的时候，坐的离班长近一点。最好坐旁边。 我当时连队友都没找，听到说选题开始，才问谁还没组队。结果发现，所有人都早早组好了队伍（当然除了队友（他也是比较内向吧，与班里的人没交流。于是乎，一坨人为了选题乱挤。所以到我选题的时候，已经是最后了。幸而找到一道22级的题目，也就是这道题。于是乎，便莫名其妙的选好了题目。 &emsp;总结： 开那个选题大会时，坐班长旁边比较好。 选题靠抢的话一定不要顾及什么面子啥的，直接乱挤，先到先得。不要有所谓的高尚，因为别人可不会管你，当你选到了一个痛苦的题目而无从下手时。。。。 队友尽量提前找好，而且尽量找负责的吧，行动力强。拖到deadline赶C课设，或者只有你一个人急，抑或是你一个人做了一堆事。。没必要，本来就是团队合作。 这个选题序号代表了验收的顺序，所以如果选的靠前（1-5的样子）那么就是第一天晚上验收。太靠后（10-15）就是最后一天了。所以选中间比较好。我选的是8。。因为第一天必有zcj，开局必有下马威吗，所以挂的可能性蛮大的，到后面也能有经验，你能问老师的验收风格，比如是加啥啥功能。最后验收就有点痛苦了。毕竟早死早超生。 还有聪明的人直接随便搞，挂科。如果不想保研确实可以如此。C课设重修只要程序能运行就过，所以可以借鉴代码。当还是别吧，当作锻炼自己的机会。（我也是不保研，我都承受了这种痛苦，你怎么能直接逃课？doge 多问问往届学长，如果是往届的题目。不是的话自求多福。 程序没必要太过注重细节。比如什么精美啥的。老师看重的思路（我的就是因为那个梯田贴图让老师赞赏了），拿我的作为例子，两种农田，小农田的地形，农作物种类。。。（都是学长建议的。连夜加的。但梯田，高度显示是自己想到的。但是预验收时，学长也说到了许多没考虑到的点，比如多架无人机，无人机电量，无人机扫描农田（就是说，不是哪里有病就喷农药到哪里），无人机喷农药到一半就返航…… 这些确实我基本没考虑，但万幸最后过了。现在看来还是验收老师好。 思路目前就这么多了，再见&#x2F; ——6.14.2024 后补经过我的询问，也是终于找到了课设选题的文件： 2023级C语言课程设计 课程设计共同要求： 1． 用C语言编程实现，编译环境采用BC3.1，掌握C语言编写较复杂程序的一些基本技巧； 2． 要求在图形化界面下操作，界面要友好，不提倡使用贴图，贴图软件实现的功能必须控制在总代码量的5%以内； 3． 注意程序的结构，必须采用工程化的思想来组织程序； 4． 要求画流程图（没有流程图的不给评分）； 5． 两人一组，每班最多只出现一个三人组，小组个人代码和实现功能分工合理，每人程序不得少于1000行（登录、注册、开机欢迎动画界面、程序结束动画代码不计入）； 6． 每组提供一份报告，报告内容应包含数据结构设计、程序流程图、程序功能介绍、源代码等，并注明每人的工作量； 7． 原则上，不得使用全局变量； 8． 注意程序的可读性和可维护性； 评分标准 软件系统需求分析、系统分析与设计报告 15% 编程工作量 10% 人机界面及接口 10% 软件功能、软件结构、编码规范 30% 排错与调试技巧 25% 团队协作 10% 技术难度附加分 （0-10分） 特别提醒：出现下列情况，不予通过。 （1）个人有效代码量不足1000行；**** （2）被2个老师认定代码抄袭的；**** （3）不按指定时间进行验收的**** （4）所选题目核心功能不能稳定运行的；**** l 参考文献 王士元. C高级实用程序设计. 北京: 清华大学出版社. 1996 周纯杰，刘正林等. 标准C语言程序及应用. 武汉: 华中科技大学出版社. 2005 周纯杰，何顶新等. 程序设计教程—用C&#x2F;C++语言编程. 北京: 机械工业出版社, 2016 姚远. 高级C语言程序设计技巧与实例. 北京: 机械工业出版社, 1995 陈清华, 朱红. C语言课程设计. 南京: 东南大学出版社, 2003 潭浩强. C语言程序设计. 北京: 清华大学出版社, 2000 等等…… 指导教师：周纯杰，何顶新，左峥嵘，高常鑫，汪国有，彭刚，周凯波，陈忠 C语言课程设计可选题目 简历辅助设计系统 主要功能说明：实现一个简历辅助设计系统。支持模板制作与模板选择；支持内容选择（比如，学习经历、实践经历等）；支持导入文本后自动排版；支持文本修改和简历修改。 武汉欢乐谷旅游模拟系统 主要功能说明：为武汉欢乐谷设计并实现一个旅游模拟系统。支持地图查看和列表查看两种方式查看项目；支持在线门票相关业务、特殊项目在线预约、预约提醒、路线推荐等。 3.小区物业管理app模拟 主要功能说明：完成一款典型小区物业管理app的各项功能仿真模拟。比如，华润物业的朝昔app。 夺岛军演游戏 主要功能说明：模拟攻占岛屿军演作战系统，场景自主设定，兵力申请与调派，后勤物资补给等功能。 ​ 5.智能家居app模拟 主要功能说明：完成包括空调、空气净化器、扫地机器人、冰箱、监控设备等至少5种联网设备的管理功能，具备家用设备的接入、设备启动、状态检测与显示，设备记录数据的分析等功能。 火星家园建设规划系统 主要功能说明：模拟火星宜居家园部署规划、进行就地取材，建设人类家园生活设施，并提供演练展示。 林果自动采摘系统模拟 主要功能说明：根据果园面积进行采摘路径规划、模拟智能农机进行采摘作业、对采摘林果进行统计、并运输林果到集中站进行储存、盘点等功能。 农田无人机喷洒农药模拟系统 主要功能说明：利用无人机进行农作物生长监测，针对不同病害进行农药配制，对农药喷洒路径进行规划，模拟无人机喷洒过程等功能。 家庭看护机器人模拟仿真系统 主要功能说明：根据家庭成员的需求，陪伴机器人进行家庭服务，包括人机交互、端茶倒水、炒菜做饭、开窗关窗、浇花扫地、健康监测、突发状况报警。 10.酒店服务机器人模拟仿真系统 主要功能说明：某酒店多服务机器人的服务全过程模拟，包括根据酒店的订单分配以及机器人送餐、送水、送快递等服务的全过程。 人工智能学院大楼智慧建造系统 主要功能说明： 实现场地平整、地基建设、楼房建设、外墙装饰的施工过程管理功能，包括图形化模拟显示、施工建材调度、施工进度管控等模块。 家用婴童陪伴神器 主要功能说明：能识别婴童的状态（翻身、睡着、睡醒、口鼻被捂、呼吸频率、跟踪爬行过程）、电子围栏越过预警、典型过程抓拍形成成长相册。 学院５０年院庆组织过程模拟 主要功能说明： 模拟学院５０周年的庆典的全过程，包括院友的接待、组织、院庆当天活动的全过程。 学生选课模拟系统 主要功能说明： 参考HUB系统功能，以菜单方式模拟选课，包括后台课程管理和前端选课全过程，具有课程信息浏览、选课信息查询等功能。 东湖水质无人艇检测系统 主要功能说明： 模拟无人艇进行东湖水质检测的全过程，包括采集标本的无人艇航迹规划、水质态势分析及预测、治理措施及建议。 仿windows资源管理器系统 主要功能说明： 实现windows资源管理器的主要功能。 模拟BC的汉化文本编辑器 主要功能说明： 模拟BC的编辑器，界面需要汉字显示，至少包括BC编辑器的文件和编辑的相关功能。 无人驾驶汽车中控仪表系统模拟 主要功能说明： 具有无人驾驶汽车中控仪表系统主要功能的模拟。 19． 图书馆信息管理系统模拟 主要功能：参考学校图书馆，模拟图书馆的主要核心功能。 FIFA世界杯2022淘汰赛模拟系统 主要功能说明： 模拟FIFA世界杯2022淘汰赛全过程。包括各场比赛的集锦及技术统计、颁奖仪式、十佳进球模拟等功能。 源代码逐文件分析当然，我和我队友的代码基本完全独立，这样做十分有必要，尤其是你和队友不熟或者不能总是在同一个地方编写代码时。分工明确非常重要，否则到了ddl，你会十分的痛苦。而且，验收老师也基本有这个要求。一个人编写一个文件，最好互不干涉。 我编写的部分其实主要的框架都是由我一人编写，因为队友实在难以沟通，但这样的好处是我自己对于整个程序的流程十分清楚，免去了必须看懂队友代码的麻烦。所以变成了队友必须看我的代码才能编写。下面列举出文件分析。 commom.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef _COMMON_H_#define _COMMON_H_/*----------------------------包含所有的头文件，以后引用头文件只需要 include &quot;common.h&quot;；更加方便，代码简洁----------------------------*/#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;string.h&gt;#include&lt;dos.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;conio.h&gt;//上面是BC自带的头文件，下面为自己编写的//这里的头文件直接复制粘贴即可，不需要管太多。 //----必备，这里主要是往届祖传文件#include&quot;mouse.h&quot;//鼠标库#include&quot;hz.h&quot;//汉字库#include &quot;IMAGE.h&quot;//贴图 //--界面#include &quot;welcome.h&quot;//开屏动画#include &quot;mainpage.h&quot;//主界面#include &quot;mainfunc.h&quot;//农田界面#include &quot;elsetian.h&quot;//另一个农田界面#include &quot;usehelp.h&quot;//系统说明界面#include &quot;growlook.h&quot;//生长检测动画#include &quot;outcome.h&quot;//大农田的结果查看界面//---func:功能文件#include &quot;move.h&quot;//配合鼠标使用的鼠标move函数#include &quot;showtime.h&quot;//显示时间函数#include &quot;shuju.h&quot;//数据库#include &quot;drzhiwu.h&quot;#include &quot;abdrone.h&quot;#include&quot;illness.h&quot;#include &quot;recover.h&quot; //这下面的都是队友编写的。#include &quot;pensa.h&quot;#include &quot;pensadh.h&quot;#include &quot;pssj.h&quot;#include &quot;zpjm.h&quot;#endif 为了方便，我的所有的解释会全放到代码里面。 设置common.h其实是我看了几个往届代码从而发现的一个共性。作用经过检验发现是：把所有编写的.h文件放到这个.h文件中，以后编写.c文件只要#include &quot;common.h&quot;就可以了。免去了各种麻烦。当然，如果你想水代码可以不这样做，但是实在毫无必要。 这里其实含金量不大。头文件编写上面已经说过，因此就不再赘述了。可以发现，我们的编写其实并不规范，只是按照个人习惯罢了。比如头文件的命名，都是为了自己理解方便。当然我又不是码农，而且英语也不太好，所以基本用中文，英文，啥的。 还有一个建议：写代码的时候多写写注释，方便自己和队友看懂。 welcome123456#ifndef _WELCOM_H_#define _WELCOM_H_int welc(int *a);//函数声明#endif 12345678910111213141516171819202122232425262728293031323334/*----------------------------------------欢迎界面----------------------------------------*/#include &quot;common.h&quot;int welc(int *a)//欢迎页 &#123; if (*a == 1) &#123; setbkcolor(WHITE);//background color setcolor(GREEN);//边界color setfillstyle(1, GREEN);// puthz(40, 150, &quot;农田无人机喷洒农药系统&quot;, 32, 50, GREEN); puthz(100, 250, &quot;你最好的选择！&quot;, 32, 50, GREEN); *a = 0; &#125; ////-------------加载动画 setfillstyle(1, RED); bar(110, 300, 530, 380); puthz(125, 322, &quot;加载中&quot;, 32, 50, YELLOW); setfillstyle(1, YELLOW); bar(265, 320, 305, 360); delay(400); bar(315, 320, 355, 360); delay(400); bar(365, 320, 405, 360); delay(400); bar(415, 320, 455, 360); delay(400); bar(465, 320, 505, 360); delay(400);//这里就是实现了一个动画的过程，原理十分简单。。。。。。 return 1;&#125; 这里为了方便，直接把.c和.h文件放到一个标题中了。毕竟在算代码量的时候也会剔除头文件，而且似乎那个课程报告里也不用？但我加了。可以看到，头文件编写就只要Ctrl c + Ctrl v 就可以了。 我应该先讲讲main.c文件的，但晚了。 *这里的a有什么用呢？其实就是我在调用函数的时候是 welc(&amp;a)，而a在main.c那里赋值了初始值1。这样welc函数就运行了一次，之后在函数内部 a&#x3D;0，所以这样之后就不再调用。实现了调用一次的作用。这个还是要先看main.c了解总体框架。* main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;common.h&quot;//程序控制台：负责页面跳转。//实现各个函数的跳转，调用void main(void)&#123; int a1 = 1; int a2 = 1; int a3 = 1; int a4 = 1; int a5 = 1; int a6 = 1; int a7 = 1; int a8 = 1; int a9 = 1; int a10 = 1; int i, j; int page;//页面值 //初始化VGA模式 int gd=VGA;//graphdriver int gm=VGAHI;//graphmode initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径 page=0;//初始化为0； mouseinit();//这里是祖传代码里面的，初始化鼠标，就是生成一个鼠标。 while (1) &#123; switch (page) &#123; case 0: page = moveint(welc, &amp;a1);//欢迎界面，return：welc中的1//可参考 move.c。 break; case 1: page = moveint(hello, &amp;a2);//主界面，return各种数字。 for (i = 0; i &lt; 5; i++) &#123; nongyao[i] = 0; &#125;//这里是队友后面加的，修bug。不用管 break; case 2: page = moveint1(mainfunc, &amp;a3,diannian_bitmap,dianbai_bitmap,dianmian_bitmap);//大农田界面。简单农田。 nongyao[5] = 0; //这里本质就是调用了mainfunc这个函数，后面这一坨是当时没想好，懒得改了。 break; case 3: page = moveint( elsetian, &amp;a4);//另一个奇怪的农田。进阶农田， nongyao[5] = 1;//队友加的，修bug，农药配置那的，这里是直接用了全局变量 break; case 4: page = moveint(usepage, &amp;a5);//系统说明界面，主要介绍了本系统的使用方法 break; case 5: page = moveint(elseoutcome, &amp;a6);//小农田的结果查看界面。。 break; case 6: page = moveint(outcome, &amp;a7);//查看大农田，说明农作物具体的生长状况，， break; case 7: page = moveint2(zhuzhan, &amp;a8, nongyao); break; case 8: page = moveint2(zpjiemian, &amp;a9, nongyao);//装配农药 break; case 9: page = moveint3(psdonghua, &amp;a10, nongyao, diannian_bitmap, dianbai_bitmap, dianmian_bitmap, rount, &amp;amtjudge);//喷洒动画 break; case -1://-1是点了 退出 框框；直接关闭BC break; default :break; &#125; if (page==-1) break; &#125; delay(1000);//程序结束运行 closegraph();&#125; 这里总体就是用了switch page模式。调用的函数代表不同的界面，函数通过改变返回值来实现界面的跳转。这里的moveint什么的是一个我编写的中转的函数，功能就是防止鼠标留痕啥的。具体后面会说到。 这里只需要学到这个界面跳转的基本框架即可。 这次更新就到这里吧。bye~ ——6.28 函数介绍（1）setbkcolor即：set background color,设置背景颜色十分通俗易懂。用法：就是setbkcolor( ); 括号里面加颜色的英文大写。但是颜色也是有种类的，并不是可以随心所欲的调色。颜色具体有如下： 12345678910111213141516#define BLACK//黑色 0#define BLUE//蓝色 0xAA0000#define GREEN //绿色 0x00AA00#define CYAN //青绿 0xAAAA00#define RED //红色 0x0000AA#define MAGENTA //紫红 0xAA00AA#define BROWN //棕色 0x0055AA#define LIGHTGRAY//浅灰 0xAAAAAA#define DARKGRAY //深灰 0x555555#define LIGHTBLUE //淡蓝 0xFF5555#define LIGHTGREEN //浅绿 0x55FF55#define LIGHTCYAN//浅青 0xFFFF55#define LIGHTRED //浅红 0x5555FF#define LIGHTMAGENTA//浅紫 0xFF55FF#define YELLOW //黄色 0x55FFFF#define WHITE //白色 0xFFFFFF setcolor也就是设置颜色，主要是边框的颜色，setcolor(GREEN); 之后你用的各种绘图函数所绘制出来的图形，点，线的边框颜色就是绿色。就像画图这个软件一样。bar, rectangle, line, putpixel. 其颜色与上面的表一致。 setfillstyle设置填充颜色。setfillstyle所设置的填充颜色只对于一些特定的函数有用。比如bar.bar与rectangle的区别是，前者含义是画实心矩形，后者不是。这也就意味这，setfillstyle之后，bar的边框颜色还是由setcolor决定的，但内部的颜色是setfillstyle的颜色。rectangle内部颜色还是背景色。 用法：setfillstyle( 1, GREEN);第二个参数是要填充的颜色，第一个参数代表了填充的方式。具体见下表 12345678910111213EMPTy_FILL 0 用背景色填充区域(空填)SOLID_FILL 1 用实填充色填充(实填)LINE_FILL 2 ----填充LTSLASH_FILL 3 ///填充SLASH_FILL 4 ///用粗线填充BKSLASH_FILL 5 用粗线填充LTBKSLASH_FILL 6 填充HATCH_FILL 7 网格线填充xHATCH_FILL 8 斜网格线填充INTEREAVE_FILL 9 间隔点填充WIDE_DOT_FILL 10 大间隔点填充CLOSE_DOT_FILL 11 小间隔点填充USER_FILL 12 用户定义图样填充 正确性我并没有确定，一般而言，在使用bc过程中，我只用到了setfillstyle(1, );其中数字和英文是等效的。其实如果聪明的话，你也许已经想到，可以用数字代表颜色，这样可以用一个数组把颜色给储存起来，从而实现颜色的改变。当然我本人是没有尝试过的。 bar用法: bar(a,b ,c,d); 四个参数分别代表左上角和右下角的坐标x，y。十分简单。只需要注意界面的坐标系是怎么建的即可。这个要看图形化的模式，也就是下面的initgraph中会讲到的。意义为画实心矩形。颜色由setcolor和setfillstyle决定。 delay十分简单，就是delay( 1000); 数字代表毫秒。一般的用途是防止鼠标的连续点击（就是说点一次但实际效果是多次），还有界面跳转时用用防止跳转频繁导致bc崩。加上总没事。 initgraph和closegraph图形化界面必用。只需要main函数里用一次就行。用法如下： 12345678int gd=VGA;//graphdriver int gm=VGAHI;//graphmode initgraph(&amp;gd,&amp;gm,&quot;C:\\BORLANDC\\BGI&quot;);//这里后面的C:什么的看放的BGI文件路径//省略。。。。。closegraph(); 这里就是直接复制粘贴即可。唯一要注意的就是initgraph中的“ ”这里的文件路径要根据bgi文件夹的路径来。所以验收的时候就要注意了，最好把你的文件放到那个C盘里。具体验收的流程我以后记得会补充。 原理可以自行上网搜索。 ——7.17 usehelp1234567891011121314151617181920212223242526272829303132333435363738#include &quot;common.h&quot;/*========================用户说明界面简单的操作说明书=========================*/int usepage(int* a5)&#123; if (*a5 == 1) &#123; cleardevice(); setbkcolor(WHITE);//background color setcolor(RED);//边界color setfillstyle(1, RED);//意思：设置绿色的填充模式为1（完全填充） rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); puthz(250,10, &quot;系统说明&quot;, 32, 30,GREEN); setcolor(GREEN);//边界color rectangle(10, 50, 635, 470); puthz(10+5, 50+5, &quot;该系统模拟了两个不同的农田，代表了两种不同的用户。平坝田地势平坦，一览无余，适用于种植大户，设置了小麦与玉米间种。小农田地势多样、具有障碍物，植物多种分布不匀杂乱。操作流程：首先进入农田，点击生长检测，此时无人机运行开始检测。结束后，可以在结果查看界面查看农作物的患病情况，并根据需要，选择配置相应的农药。农药装配到无人机后，无人机会自动进行最优路径规划，并进行农药喷洒。&quot;, 32, 30, GREEN); *a5 = 0; &#125; showbiankuang(0, 0, 80, 40);//showbiankuang是自己编写的一个函数，作用为鼠标移动到那里会标亮矩形边框提示。实际意义不大，因为验收老师不会关注这个。但闲的时候可以直接套用。 showbiankuang(600, 0, 640, 40); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a5 = 1;//注意这里要把a5还原。 return 1;// &#125; return 4;&#125; 为了方便和效率，没有特殊列出，头文件只有源文件里面的函数声明。所以这里的usehelp.h就略去了。这里巧妙的一点就是函数传入了a5这个参数，这样使得if（a5&#x3D;&#x3D;1）这里面的代码只调用一次，能够很好的防止各种bug，界面更加稳定。我这里所有的界面跳转都用到了这个基本的思想。 move12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;common.h&quot;/*-------------- 解决了鼠标的闪动问题， 解决了鼠标被 图像遮挡的问题--------------*///适用于 int类型函数。可参考 welcome.h中的使用int moveint(int (*hanshu)(int*), int* a)&#123; int b; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; b= hanshu(a);//顺序有严格要求，不能颠倒，否则出问题 if (*a != -10)//注意只能if，不能while,而且，这里的*a!=-10是为了消除warning &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return b;&#125;int moveint1(int (*hanshu)(int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49]), int* a, unsigned char b[384][49], unsigned char c[192][49], unsigned char d[192][49])//这个不用看，这么复杂是因为当时不知道文件操作怎么用。。&#123; int bbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbb = hanshu(a,b,c,d); if (*a!=-10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbb;&#125;void showbiankuang(int x1, int y1, int x2, int y2)//用于显使得鼠标在 矩形中显示边框&#123;//矩形的内部颜色都是白色 if (mouse_press( x1, y1, x2, y2)==2|| mouse_press(x1, y1, x2, y2) == 1) &#123;//鼠标在框内，而且不处于左键点击状态。其实也可以不这么写。 setcolor(BLUE); rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1);//内部标亮为蓝色 &#125; else &#123; setcolor(WHITE); rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1);//覆盖标亮 &#125;&#125; 这里总共就三个函数，第一个和第二个的原理一模一样，只不过是能调用的函数类型不一样。moveint这个函数就是智能调用函数形式为 int hanshu(int *a);这种定义类型的。同理你可以根据实际情况改成，比如movevoid(void (*hanshu)(int ),int *a)。这个原理就是把函数作为参数传递。唯一作用就是解决历代流传下来的界面跳转时的鼠标留痕问题。 showtime12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;common.h&quot;#include &quot;shuju.h&quot;#include &quot;showtime.h&quot;/*-----------------------------------------------------展示时间，具体时间可以自行修改，显示的坐标也可以。注意这里实现了时间每秒刷新一次。------------------------------------------------------*/void displayCurrentTime(void)&#123; int currenttime = 1;//设定现在时间,初始化。 int pasttime = 0;//参考时间 //////////////////////////////// time_t timep; struct tm* p; char timeString[20]; // 获取当前时间的秒数 time(&amp;timep); // 转换为协调世界时的时间结构体 p = localtime(&amp;timep); //这一段是通用代码，就是直接复制即可，就是把时间的信息放到了timep这个结构里面 ////////////////////////////// currenttime = p-&gt;tm_sec;//赋值 getshijian1(&amp;pasttime);//实现一段时间内（1s）pasttime=currenttime. //get...这个函数就是把文件里面的数字传给pasttime，相当于赋值。。 if (pasttime != currenttime)//利用这个实现每过一秒中就刷新一个，具体自己理解） &#123; clearTimeArea();// 清除时间显示区域 pasttime = currenttime; setshijian1(pasttime);//把文件里面的数字改成pattime的数字 &#125; // 在窗口中显示转换后的时间信息 setcolor(LIGHTGREEN);//outtextxy的颜色 settextstyle(1, HORIZ_DIR, 1);//HOR...表示横向显示，第二个1表是字体大小。1为小，0默认。2，3..大 outtextxy(10, 10, &quot;Local Time&quot;); settextstyle(1, HORIZ_DIR, 1); sprintf(timeString, &quot;%d-%02d-%02d- %02d:%02d:%02d&quot;,//图形化下的数据显示函数。sprintf将这些储存到timestring字符串中 p-&gt;tm_year + 1900, p-&gt;tm_mon + 1, p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);//这里要加1900和1的原因感兴趣自己可以去查。 outtextxy(10, 30, timeString);//显示字符串&#125;/*-----------------------------------------------------用一个实心矩形（注意改背景色），遮挡。并不断刷新，实现部分cleardevice()的效果。 c=bioskey(0); //读取键盘输入内容------------------------------------------------------*/void clearTimeArea(void) &#123; setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(10, 30, 300, 55); // 清除时间显示区域&#125; &emsp;这里实现了一个时钟的显示吧，意义不大，主要是让界面看起来更丰富一点。clearTimeArea就是用一个矩形覆盖上一秒的数字，然后重新outtexty，这样就实现了时间的更新。但是要实现每秒更新一次时间，就要引入pasttime了。否则实际情况是clearTimeArea一直在执行，导致时钟一直在闪烁。原理用到了文件操作。但其实，我一开始是直接用结构（struct）然后直接全局变量。。在shuju.h中你也会见到全局变量的用法。 这个的原理还是比较简单的。但仍然存在的bug是鼠标放到时钟显示的地方会被遮挡，这个小细节还没想到如果优化，但其实意义不大，老师不会注重这些与选题无关的细节，就比如室友还加了买门票提醒出现小红点功能，碰到cj还不是直接挂？管你做的多细节？只要有一些核心的东西没到点就是寄。 mainpage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;common.h&quot;/*-----------------------------------------------------主界面的编写，实现不同功能界面的跳转可以一览本程序的功能。------------------------------------------------------*/int hello(int* a2)&#123; //绘图,只画一次,绘制主界面 if (*a2 == 1) &#123; int i = -1; clrmous(MouseX, MouseY); cleardevice(); setbkcolor(WHITE);//background color setcolor(RED); setfillstyle(1,RED ); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//右上角画 退出 setcolor(GREEN); puthz(80, 60, &quot;无人机喷洒农药系统&quot;, 32, 50, GREEN); line(80, 100, 520, 100);//画标题 rectangle(220, 120, 420, 200); rectangle(220, 240, 420, 320); rectangle(220, 360, 420, 440); puthz(230, 140, &quot;进入平坝田&quot;, 32, 38, GREEN); puthz(230, 260, &quot;进入小农田&quot;, 32, 38, GREEN); puthz(230, 380, &quot;系统说明&quot;, 32, 50, GREEN); //画三个框框，代表三种功能。 *a2 = 0; setshijian1(i);//初始化 time.dat文件 &#125;//else--------------------------------------------------- displayCurrentTime();//左上角显示时间 showbiankuang(220,120,420,200);//用于显使得鼠标在 矩形中显示边框 showbiankuang(220, 240, 420, 320); showbiankuang(220, 360, 420, 440); showbiankuang( 600 ,0 ,640 ,40 );//------------------------------------------------------- //界面的跳转 if( mouse_press(600,0,640,40) == 1) &#123; *a2 = 1;//使得函数参数重置，为了能够实现返回界面 return -1;//关闭BC。 &#125; else if (mouse_press(220,120,420,200) == 1) &#123; *a2 = 1; return 2;//进入大农田 &#125; else if (mouse_press(220, 240, 420, 320)== 1) &#123; *a2 = 1; return 3;//小农田 &#125; else if (mouse_press(220, 360, 420, 440) == 1) &#123; *a2=1; return 4 ;//系统说明 &#125; return 1; &#125; 此界面就是初始界面了。十分简单。绘图部分完全不用看，界面跳转也是一个通用模板了。 drzhiwu123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 #include&quot;common.h&quot;/*========================================functions: 画植物，包括小麦，玉米，棉花。=========================================*///=============// 画棉花，透视图//==============void mianhua(int x, int y)//x,y为其的左上角坐标。20*35&#123; setcolor(GREEN); setfillstyle(SOLID_FILL, GREEN); bar(x + 10, y + 15, x + 12, y + 35); line(x + 7, y + 14, x + 10, y + 17); line(x + 10, y + 17, x + 16, y + 14); ellipse(x+18, y+17,10, 360, 2, 4);//画椭圆函数 ellipse(x + 5, y +16 , 20, 360, 3, 4); floodfill(x + 5, y + 16, GREEN); floodfill(x + 18, y + 17, GREEN); line(x+10, y+15, x+10, y+9); line(x+11, y+15, x+11, y+9); line(x+10, y+9, x+3, y+7); line(x+3, y+7, x+9, y+5); line(x+9, y+5, x+6, y+1); line(x+6, y+1, x+10, y+2); line(x+10, y+2, x+12, y+5); line(x+12, y+5, x+15, y+1); line(x+15, y+1, x+16, y+5); line(x+16, y+5, x+19, y+6); line(x+19, y+6, x+19, y+9); line(x+19, y+9, x+13, y+10); line(x+13, y+10, x+13, y+13); line(x+13, y+13, x+11, y+10); floodfill(x + 9, y + 3, GREEN); setcolor(WHITE); line(x+10, y+9, 6+x, y+8); line(x+11,y+ 9, 10+x, 4+y); line(11+x, y+9, x+15, y+2); line(x+12, y+8, x+14, y+7);&#125;//=============// 画玉米，透视图//==============void yumi(int x, int y) //xy为左上角35*35&#123; setcolor(GREEN); setfillstyle(SOLID_FILL, GREEN); bar(x + 12, y + 3, x + 16, y + 35); arc(x+14, y+4, 0, 180, 2); floodfill(x + 13, y + 3, GREEN); line(x + 12 , y +4 , x +5 , y +4 ); line(x +5 , y + 4, x +2 , y +10 ); line(x +2 , y +10 , x +6 , y +8 ); line(x + 6, y +8 , x +12 , y +7 ); line(x + 12, y +18 , x +9 , y + 17); line(x + 9, y + 17, x +7 , y + 28); line(x +7 , y +28 , x +12 , y + 22); line(x + 16, y +24 , x + 21, y +20 ); line(x + 21, y + 20, x +27 , y +25 ); line(x + 27, y +25 , x +23 , y +17 ); line(x +23 , y +17 , x + 16, y + 20); floodfill(x + 20, y + 19, GREEN); floodfill(x + 10, y + 20, GREEN); floodfill(x + 5, y + 7, GREEN); line(x + 16, y +17 , x + 20, y +15 ); line(x +20 , y +15 , x +20 , y +4 ); line(x + 20, y +4 , x +16 , y +12 ); floodfill(x + 19, y + 19, GREEN); line(x + 16, y + 13, x + 20, y + 6); line(x +12 , y +10 , x + 7, y +8 ); line(x + 7, y + 8, x +12 , y + 12); line(x + 7, y +8 , x +6 , y +10 ); line(x + 6, y + 10, x +12 , y + 17); line(x + 6, y +10 , x +12 , y +12 ); setfillstyle(SOLID_FILL, YELLOW); floodfill(x + 10, y + 12, GREEN); floodfill(x + 18, y + 12, GREEN);&#125;//=======//小麦块//=======void xiaomaikuai(int x, int y)&#123; xiaomai(x, y); xiaomai(x+5, y); xiaomai(x-5, y);&#125;//画小麦透视图,,,其大小为 20*19.void xiaomai(int x, int y)&#123; x = x +10;//修正小麦坐标 //xy是最顶点 setcolor(GREEN); putpixel(x, y, GREEN); line(x, y, x, y + 19); line(x, y + 6, x + 5, y + 6 - 5); line(x, y + 6, x - 5, y + 6 - 5); line(x, y + 12, x - 5, y + 6); line(x, y + 12, x + 5, y + 6 );&#125;//画小麦俯视图void fxiaomai(int x, int y)//xy是最左边的点//25*25&#123; setcolor(GREEN); line(x + 2, y + 10 + 6 + 4 + 3, x + 6, y + 2 + 6 + 4 + 3); line(x + 2, y + 6 + 6 + 4 + 3, x + 10, y + 6 + 6 + 4 + 3); line(x + 6, y + 12 + 6 + 4 + 3, x + 3, y + 3 + 6 + 4 + 3); line(x + 10, y + 9 + 6 + 4 + 3, x + 7, y + 12 + 6 + 4 + 3); line(x + 11, y + 10 + 6 + 4 + 3, x + 8, y + 7 + 6 + 4 + 3); line(x + 13, y + 10 + 6 + 3, x + 6 + 12, y + 2 + 6 + 3 + 3); line(x + 2 + 12, y + 6 + 6 + 3, x + 10 + 12, y + 6 + 6 + 3 + 3); line(x + 6 + 12, y + 12 + 5 + 4, x + 3 + 12, y + 3 + 6 + 3 + 3); line(x + 10 + 12, y + 9 + 6 + 3, x + 7 + 12, y + 12 + 4); line(x + 11 + 12, y + 10 + 3 + 3, x + 8 + 12, y + 7 + 4 + 3); line(x + 6 + 10, y + 12, x + 8 + 10, y + 12 + 2); line(x + 6 + 10, y + 12, x + 6 - 2 + 10, y + 12 + 2); line(x + 6 + 10, y + 12, x + 6 + 10, y + 12 - 4); line(x + 6 + 10, y + 12, x + 6 - 2 + 10, y + 12 - 4); line(x + 4, y + 2, x + 8, y + 10); line(x + 8, y + 6, x + 8, y + 2); line(x + 8, y + 10, x + 12, y + 2); line(x + 4, y + 10, x + 8, y + 18); line(x + 8, y + 14, x + 8, y + 10); line(x + 8, y + 18, x + 12, y + 10); line(x + 8, y + 2, x + 16, y + 10); line(x + 16, y + 6, x + 16, y + 2); line(x + 16, y + 10, x + 24, y + 2); line(x + 8, y + 10, x + 16, y + 18); line(x + 16, y + 14, x + 16, y + 10); line(x + 16, y + 18, x + 24, y + 10);&#125;//=============// 画玉米，俯视图//==============void fyumi(int x, int y)&#123; setcolor(GREEN); circle(x + 12, y + 12, 2); line(x + 12, y + 10, x + 20, y + 2); line(x + 20, y + 2, x + 16, y + 9); line(x + 16, y + 9, x + 13, y + 11); line(x + 14, y + 9, x + 20, y + 13); line(x + 20, y + 13, x + 13, y + 13); putpixel(x + 13, y + 13, GREEN); putpixel(x + 13, y + 14, GREEN); putpixel(x + 14, y + 14, GREEN); putpixel(x + 14, y + 15, GREEN); putpixel(x + 15, y + 15, GREEN); putpixel(x + 15, y + 16, GREEN); putpixel(x + 14, y + 17, GREEN); putpixel(x + 15, y + 17, GREEN); putpixel(x + 16, y + 17, GREEN); putpixel(x + 17, y + 17, GREEN); putpixel(x + 18, y + 17, GREEN); line(x + 18, y + 17, x + 20, y + 23); line(x + 20, y + 23, x + 13, y + 20); line(x + 13, y + 20, x + 12, y + 15); line(x + 11, y + 11, x + 2, y + 10); line(x + 2, y + 10, x + 2, y + 12); line(x + 2, y + 12, x + 5, y + 13); line(x + 5, y + 13, x + 11, y + 14); line(x + 7, y + 14, x + 3, y + 21); line(x + 3, y + 21, x + 12, y + 18); line(x + 5, y + 10, x + 13, y + 7); setfillstyle(SOLID_FILL, GREEN); floodfill(x + 12, y + 12, GREEN); // 遇到边界颜色停止 setfillstyle(SOLID_FILL, YELLOW); floodfill(x + 15, y + 18, GREEN);&#125; 完全没有技术含量，仅仅是画图而已。 那今天的更新就到这里吧，大概不久就要去练科三了，时间也变的紧张起来。考驾照无非就是67个人围着一辆车子，一个人10多min，一天下来基本在太阳底下站。。。早七晚六不用说。大二上学期更没时间，课表全满，双休也有课，每天早八晚九了。。。 abdrone123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &quot;common.h&quot;/*===========================================无人机所有函数，包括运动，画图=============================================*///俯视图 的无人机//用于大农田void drfdrone(int x, int y)//xy是左上角坐标&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); //circle(x + 12, y + 12, 4); fillellipse(x + 12, y + 12, 4, 4); rectangle(x + 8, y + 9, x + 15, y + 15);// floodfill(x + 12, y + 12, DARKGRAY); line(x + 5, y + 4, x + 9, y + 8); line(x + 3, y + 4, x + 9, y + 9); line(x + 3, y + 5, x + 8, y + 10); line(x + 9, y + 1, x + 1, y + 9); line(x + 8, y + 1, x + 0, y + 9); line(x + 7, y + 1, x + 0, y + 8); line(x + 15, y + 8, x + 19, y + 4); line(x + 15, y + 9, x + 20, y + 4); line(x + 15, y + 10, x + 20, y + 5); line(x + 15, y + 0, x + 24, y + 9); line(x + 16, y + 0, x + 24, y + 8); line(x + 14, y + 1, x + 23, y + 9); line(x + 16, y + 15, x + 21, y + 20); line(x + 15, y + 15, x + 20, y + 20); line(x + 14, y + 16, x + 20, y + 21); line(x + 24, y + 15, x + 15, y + 24); line(x + 24, y + 16, x + 16, y + 24); line(x + 24, y + 14, x + 14, y + 24); line(x + 9, y + 15, x + 3, y + 21); line(x + 8, y + 15, x + 3, y + 20); line(x + 9, y + 16, x + 4, y + 21); line(x + 0, y + 15, x + 9, y + 24); line(x + 0, y + 16, x + 8, y + 24); line(x + 0, y + 14, x + 10, y + 24);&#125;//==================================================//动画实现代码。建议自己理解。。。。。详细调用在growlook.c里面的大农田里面有。//原理大概就是视觉停留（？，void move11(int* x, int* y, int* buffer1)&#123; for (; *x &lt; 620 - 25; *x = *x + 2)//运动到了最左端。。 &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1);//保存image到buffer drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT);//恢复图像 &#125;&#125;void move12(int* x, int* y, int* buffer1, int* judge)&#123; for (; *y &lt; *judge + 25; (*y)++) &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(10); putimage(*x, *y, buffer1, COPY_PUT); &#125; *judge = *y;&#125;void move13(int* x, int* y, int* buffer1)&#123; for (; *x &gt; 20; *x = *x - 2) &#123; getimage(*x, *y, *x + 25, *y + 25, buffer1); drfdrone(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); &#125;&#125;//=============================================//无人机透视图，用于小农田void drtdrone(int xx, int y)//xy是左上角坐标 75*44&#123; int x; x = xx - 25; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(0 + x, 4 + y, 24 + x, 5 + y); bar(49 + x, 4 + y, 73 + x, 5 + y); bar(x + 4, y + 6, x + 5, y + 10); bar(x + 6, y + 9, x + 20, y + 10); bar(x + 19, y + 6, x + 20, y + 10); bar(x + 53, y + 6, x + 54, y + 10); bar(x + 54, y + 10, x + 69, y + 9); bar(x + 68, y + 6, x + 69, y + 9); bar(x + 7, y + 11, x + 9, y + 14); bar(x + 16, y + 11, x + 18, y + 13); bar(x + 8, y + 16, x + 22, y + 17); bar(x + 55, y + 11, x + 57, y + 13); bar(x + 64, y + 14, x + 66, y + 11); bar(x + 51, y + 16, x + 65, y + 17); bar(x + 24, y + 11, x + 49, y + 13); bar(x + 21, y + 20, x + 51, y + 22); bar(x + 23, y + 24, x + 50, y + 25); line(x + 11, y + 18, x + 13, y + 18); line(x + 60, y + 18, x + 62, y + 18); line(x + 9, y + 15, x + 23, y + 15); line(x + 50, y + 15, x + 64, y + 15); line(x + 10, y + 14, x + 17, y + 14); line(x + 10, y + 13, x + 15, y + 13); line(x + 10, y + 12, x + 10, y + 14); line(x + 15, y + 12, x + 15, y + 13); line(x + 57, y + 14, x + 63, y + 14); line(x + 58, y + 13, x + 63, y + 13); line(x + 58, y + 12, x + 58, y + 13); line(x + 63, y + 12, x + 63, y + 13); line(x + 23, y + 12, x + 23, y + 14); line(x + 50, y + 12, x + 50, y + 14); line(x + 8, y + 2, x + 10, y + 0); line(x + 8, y + 3, x + 11, y + 0); line(x + 14, y + 0, x + 16, y + 2); line(x + 13, y + 0, x + 16, y + 3); line(x + 12, y + 0, x + 9, y + 3); line(x + 13, y + 1, x + 15, y + 3); line(x + 12, y + 1, x + 10, y + 3); line(x + 12, y + 1, x + 14, y + 3); line(x + 21, y + 18, x + 21, y + 19); line(x + 20, y + 18, x + 20, y + 21); line(x + 52, y + 18, x + 52, y + 21); line(x + 53, y + 18, x + 53, y + 20); line(x + 23, y + 23, x + 25, y + 23); line(x + 48, y + 23, x + 50, y + 23); line(x + 57, y + 2, x + 59, y + 0); line(x + 57, y + 3, x + 60, y + 0); line(x + 58, y + 3, x + 61, y + 0); line(x + 62, y + 0, x + 59, y + 3); line(x + 63, y + 0, x + 65, y + 2); line(x + 63, y + 1, x + 65, y + 3); line(x + 62, y + 1, x + 64, y + 3); line(x + 62, y + 2, x + 63, y + 2); line(x + 23, y + 26, x + 23, y + 32); line(x + 24, y + 26, x + 24, y + 30); line(x + 22, y + 32, x + 22, y + 42); line(x + 21, y + 32, x + 21, y + 42); line(x + 20, y + 37, x + 20, y + 41); line(x + 21, y + 41, x + 25, y + 41); line(x + 21, y + 42, x + 24, y + 42); line(x + 49, y + 26, x + 53, y + 37); line(x + 49, y + 27, x + 53, y + 38); line(x + 51, y + 34, x + 51, y + 42); line(x + 48, y + 41, x + 53, y + 41); line(x + 49, y + 42, x + 52, y + 42); line(x + 53, y + 37, x + 53, y + 41); line(x + 51, y + 34, x + 51, y + 42); line(x + 52, y + 42, x + 52, y + 34); bar(x + 41, y + 28, x + 43, y + 36); bar(x + 41, y + 26, x + 42, y + 36); line(x + 38, y + 36, x + 43, y + 36); line(x + 31, y + 26, x + 29, y + 30); line(x + 32, y + 26, x + 29, y + 31); line(x + 34, y + 36, x + 30, y + 36); line(x + 30, y + 36, x + 30, y + 27); line(x + 29, y + 30, x + 29, y + 35); setcolor(LIGHTGRAY); setfillstyle(1, LIGHTGRAY); floodfill(x + 12, y + 3, DARKGRAY); floodfill(x + 61, y + 3, DARKGRAY); floodfill(x + 13, y + 12, DARKGRAY); floodfill(x + 60, y + 11, DARKGRAY); line(x +26 , y +23 , x +47 , y + 23); bar(x +6 , y + 6, x +18 , y + 8); bar(x +55 , y +6, x +67 , y +8 ); bar(x + 24, y +14 , x + 49, y +19 ); line(x +23 , y + 16, x +23 , y + 19); line(x +50 , y + 16, x +50 , y + 19); setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(x +26 , y + 17, x + 27, y +18 ); bar(x + 29, y + 17, x + 30, y + 18);&#125; 这个文件就是画无人机（两种形式），写了一段实现简单动画平移的函数，目前关于如何实现斜线运动我那时就没想到，之后也就没想了（只想到了循线这种）。比较简单，不需要多看。。 shuju.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &quot;shuju.h&quot;#include &quot;common.h&quot;//==============================================================//控制时间间隔。原理请配合showtime.c使用//这里和时间那里有关，其实可以直接搞个全局变量就OK，//但当时怕被发现，换成了文件操作，当时也是刚刚学这东西，所以就当练练手了void setshijian1(int cankaotime)//这个函数的作用就是把传进的 cankaotime这个东西写入到time.dat文件//中（这种文件都能直接用记事本打开好像，还是比较方便检查错误的）&#123; FILE* filePointer1; filePointer1 = fopen(&quot;data//time.dat&quot;, &quot;w&quot;); //具体用法建议问chatgpt或者上网搜 if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; fprintf(filePointer1, &quot;%d\n&quot;, cankaotime);//设置使得time.dat 储存cankaotime的数字 fclose(filePointer1);&#125;//上面那一串都是直接复制粘贴的，原理我不太懂。。套路就是这样吧，那里的if那一大段要不要其实无所谓了，我后面//自己编写的时候也基本没加，但加上还是好的，便于检查内存分配的问题。void getshijian1(int *cankaotime)&#123; FILE* filePointer1; filePointer1 = fopen(&quot;data//time.dat&quot;, &quot;r&quot;); if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; fscanf(filePointer1, &quot;%d&quot;, cankaotime);//设置使得cankaotime获得time.dat 储存的数字，注意这里用了指针。。 fclose(filePointer1); //fscanf用&amp;,fprintf不用&amp;&#125;//这里只需要掌握fscanf和fprintf的用法就行，靠这两个函数就能基本实现储存和读取数据了。//====================================================//这一堆都是偷偷藏起来的全局变量，后面想改，但时间不够，而且难度高，所以索性摆烂了，全都是大农田用的，因为//大农田搞了个植物自愈，自愈不完全，病情加深的功能，虽然验收老师并没有感到十分的赞赏。。。。。。无用功吧属//实是。unsigned char dianmian_bitmap[192][49];//这三个就是储存点的坐标，就是植物生病会随机出现颜色点，点的//坐标就储存到了这个数组里面，现在想来就是纯纯折磨自己。搞了个点的随机显示。如果你仔细观察大农田就会发现了unsigned char dianbai_bitmap[192][49];unsigned char diannian_bitmap[384][49];//，棉铃虫，白粉病，黏虫。//下面这三个是储存生病植物的坐标，用了全局变量，当然可以用文件操作（小农田就是这样，但要重写实在太麻烦dbfxy bai = &#123; 0 &#125;;//小麦地得白粉病 的坐标。 注意当x，y均为0时，表示该区域不得病。dbfxy mian = &#123; 0 &#125;;//得棉铃虫病的坐标。 注意当x，y均为0时，表示该区域不得病。niang nian = &#123; 0 &#125;;//黏虫的坐标，左上角坐标， 注意当x，y均为0时，表示该区域不得病。//下面三个是队友写的全局变量。。看不太懂int nongyao[6];//氟铃胺，甲胺磷，氯氰菊酯，甲维盐，菌酯, nongyao[6]用于判断大小农田 0:大 1：小int rount[386][2];//储存需要喷洒农药的植物坐标int amtjudge;//判断需要喷洒的植物的棵数//=================================================================================//获得所有植物的坐标，把植物坐标传入到 plantPostions里面。void getxtxiao(int plantPositions3[][2])//小农田的代码，就是把植物坐标传入文件xt是小田的意思&#123;//小麦 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtxiao.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 104; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;void getxtyumi(int plantPositions3[][2])&#123;//玉米 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtyumi.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 68; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;void getxtmianhua(int plantPositions3[][2])&#123;//棉花 int row = 0; FILE* filePointer3; filePointer3 = fopen(&quot;data//xtmianhua.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 for (row = 0; row &lt; 68; row++)//画植物的数量为坐标数 &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;plantPositions3[row][0], &amp;plantPositions3[row][1]); &#125; fclose(filePointer3);&#125;//=================================================//下面的三个文件对文件进行初始化定义。//这个函数就是起到初始化文件的作用，就是重新生成一般xtyumi.dat等三个文件（储存了植物坐标），清空记录的作用吧。void setxtzhiwu(int plantPositions1[][2], int plantPositions2[][2], int plantPositions3[][2])&#123; int j; FILE* filePointer1; // 文件指针 FILE* filePointer2; FILE* filePointer3; filePointer1 = fopen(&quot;data//xtyumi.dat&quot;, &quot;w&quot;); // 以写入模式打开文件 filePointer2 = fopen(&quot;data//xtmianhua.dat&quot;, &quot;w&quot;); filePointer3 = fopen(&quot;data//xtxiao.dat&quot;, &quot;w&quot;); if (filePointer1 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; if (filePointer2 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; if (filePointer3 == NULL) &#123; printf(&quot;Unable to open the file.\n&quot;); getch(); exit(1); &#125; for (j = 0; j &lt; 68; j++) &#123; fprintf(filePointer1, &quot;%d %d\n&quot;, plantPositions1[j][0], plantPositions1[j][1]); &#125; for (j = 0; j &lt; 68; j++) &#123; fprintf(filePointer2, &quot;%d %d\n&quot;, plantPositions2[j][0], plantPositions2[j][1]); &#125; for (j = 0; j &lt; 104; j++) &#123; fprintf(filePointer3, &quot;%d %d\n&quot;, plantPositions3[j][0], plantPositions3[j][1]); &#125; fclose(filePointer1); fclose(filePointer2); fclose(filePointer3);&#125;//下面是大农田里用到的//就是清空全局变量的值，全部归零，防止退出到主界面时，上一次的检测结果影响。void zero(void)//重置储存。。&#123; int i, j; for (i = 0, j = 192; i &lt; 192, j &lt; 384; i++, j++) &#123; bai.bfzuobiao[i][0] = 0; bai.bfzuobiao[i][1] = 0; mian.bfzuobiao[i][0] = 0; mian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][0] = 0; &#125;&#125;//下面这两个函数都是gpt生成的，当时出现了内存爆炸的问题，心里也很慌，gpt说位图能减少内存使用，所以//阴差阳错之下就用到了这东西，反正我看不懂，但还是会用的。具体使用好像是在illness.c和recover.c里面// 设置位图中的某个像素值，具体原理我当时也没去了解，过了C课设之后更不学了。。void setshu(unsigned char bitmap[49], int x, int value)&#123; if (value) &#123; bitmap[x / 8] |= (1 &lt;&lt; (x % 8)); // 设置为 1 &#125; else &#123; bitmap[x / 8] &amp;= ~(1 &lt;&lt; (x % 8)); // 设置为 0 &#125;&#125;// 获取位图中的某个像素值int getshu(unsigned char bitmap[49], int x)&#123; return (bitmap[x / 8] &gt;&gt; (x % 8)) &amp; 1;&#125; shuju.h12345678910111213141516171819202122232425262728293031323334353637383940#ifndef _SHUJU_H#define _SHUJU_H/*--------------作为数据库，实现一次定义--------------*/typedef struct&#123; int bfzuobiao[384][2];//&#125; niang; //储存黏虫的坐标信息；typedef struct&#123; int bfzuobiao[192][2];//&#125; dbfxy;//储存小麦的白粉病信息以及玉米的棉铃虫信息//引用全局变量，extern dbfxy bai;extern dbfxy mian;extern niang nian;extern unsigned char dianmian_bitmap[192][49];//位图，储存颜色点的信息extern unsigned char dianbai_bitmap[192][49];extern unsigned char diannian_bitmap[384][49];//初始化位图和获取位图的0，1.void setshu(unsigned char bitmap[49], int x, int value);int getshu(unsigned char bitmap[49], int x);extern int nongyao[6];//氟铃胺，甲胺磷，氯氰菊酯，甲维盐，菌酯, nongyao[5]用于判断大小农田 0:大 1：小extern int rount[386][2];//储存需要喷洒农药的植物坐标extern int amtjudge;//判断需要喷洒的植物的棵数//初始化小农田里的各种植物坐标。以及从文件中获取各个植物的坐标到数组中void setxtzhiwu(int plantPositions1[][2], int plantPositions2[][2], int plantPositions3[][2]);void getxtmianhua(int plantPositions3[][2]);void getxtyumi(int plantPositions3[][2]);void getxtxiao(int plantPositions3[][2]);//=====================//time.dat //function:控制时间间隔，每隔一秒刷新void setshijian1(int cankaotime);void getshijian1(int* cankaotime);//=====================void zero(void);//重置大农田的患病植物坐标储存#endif 这两个文件基本涉及到了所有的文件操作的相关函数（我是指我编的程序里面用到的），对于看懂整个代码有很大作用。比较复杂，因为是后面边写便堆砌上去的。毕竟文件操作都是差不多距离验收一个月前加上去的。虽然我们用到的文件操作仅仅限于储存数组，但毫无争议的是，还是要学更多，毕竟画图没有什么含金量，你也可以发现，其实整个程序抛弃画图，我现在看来，C课设编写的程序也就那样。。。详细解释看新加的注释 ​ ——7.28 mainfunc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include &quot;common.h&quot;/*===========================================实现了分工，其中准备喷洒会进入另外一个新界面。绘制了农田和植物的基本样子。=============================================*/int mainfunc(int* a3, unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49])&#123;//大农田的绘制 int i; srand(time(NULL)); //================================ //这里是绘制大农田界面 if (*a3 == 1) &#123; cleardevice(); clrmous(MouseX, MouseY); setbkcolor(WHITE);//background color drawBackground();//画通用背景 farmfield();//绘制农田 *a3 = 0; &#125; //=========================== if (*a3 ==- 1)//实现界面跳转后，返回改界面的重新绘图 &#123; cleardevice(); clrmous(MouseX, MouseY); setbkcolor(WHITE);//background color drawBackground(); farmfield(); for (i = 0; i &lt; 192; i++)//小麦区域的发病率 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1],diannian[i]); &#125; &#125; for (i=192; i &lt; 384; i++)//玉米区域的发病率 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1],diannian[i]); &#125; &#125; for (i = 0; i&lt; 192; i++)//玉米区域的发病率. &#123; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; mianling(mian.bfzuobiao[i][0], mian.bfzuobiao[i][1],dianmian[i]); &#125; &#125; for (i = 0;i &lt; 192; i++) &#123; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; baifen(bai.bfzuobiao[i][0], bai.bfzuobiao[i][1],dianbai[i]); &#125; &#125; *a3 = 2; &#125; //上面这一段是重新绘图，因为结果查看后要返回到大农田界面，所以要这样 //====================ELSE //鼠标显示边框 showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(100, 5, 100 + 140, 50); //===================下面是界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; zero();//重置病虫坐标 delay(100); return 1;//返回前一个界面 &#125; else if (mouse_press(100, 5,240, 50) == 1)//连续点击生长检测 &#123; *a3 = 2; clrmous(MouseX, MouseY); grow();//无人机动画的实现 recover();//再次点击生长检测，部分区域恢复 //显示三种病 showbaifen(dianbai); shownianchong(diannian); showmianling(dianmian); &#125; if (*a3 == 2 || *a3 == -1)//这里实现了必须先点击一次生长检测，才能点击结果查看和准备喷洒的功能 &#123; if (mouse_press(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50) == 1) &#123; *a3 = -1; delay(100); return 6;//结果查看部分 &#125; else if (mouse_press(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50) == 1) &#123; *a3 = -1; delay(100); return 7;//准备喷洒部分 &#125; showbiankuang(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); showbiankuang(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); &#125; return 2;&#125;//绘制通用背景void drawBackground(void)&#123; setcolor(RED);//边界color setfillstyle(1, GREEN);//意思：设置绿色的填充模式为1（完全填充） rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, GREEN); bar(100, 5, 100 + 140, 50); bar(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); bar(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); puthz(100 + 10, 5 + 5, &quot;生长检测&quot;, 32, 30, WHITE); puthz(100 + 140 + 30 + 10, 5 + 5, &quot;结果查看&quot;, 32, 30, WHITE); puthz(100 + 140 + 140 + 30 + 30 + 10, 5 + 5, &quot;准备喷洒&quot;, 32, 30, WHITE);&#125;//绘制农田 void farmfield(void)&#123; int x = 0, y = 0; int j; int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;; setfillstyle(1, BROWN); setcolor(BROWN); bar(20, 60+5, 640-20, 480-15);//边框，即农田大小 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域, &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j]) &#123; j++; fxiaomai(x, y); &#125; &#125; for (y = 0; y &lt;= 300; y = y + 100)//玉米的绘制 &#123; for (x = 20; x &lt;= 620 - 25; x = x + 25) &#123; fyumi(x, 65+50 + y); fyumi(x, 65 +25+50 + y); &#125; &#125;&#125; 这一个文件是实现了大农田的农田绘制和植物的生长检测功能（包括无人机动画，病虫害显示）这段代码个人认为有用的包括那个 必须得先点击一个按键，之后便可点击其他。也许你有其他的方法，但我暂时还没思路。 illness.h123456789101112131415161718192021222324252627#ifndef _ILLNESS_H_#define _ILLNESS_H_//大农田显示void showbaifen(unsigned char abc[192][49]);void baifen(int x, int y, unsigned char abc[49]);void ifbaifen(unsigned char abc[49]);void nianchong(int x, int y, unsigned char aaa[49]);//画黏虫void ifnianchong(unsigned char aaa[49]);//随机点列void shownianchong(unsigned char aaa[384][49]);void ifmianling(unsigned char aaa[49]);//随机显示void mianling(int x, int y, unsigned char aaa[49]);void showmianling(unsigned char aaa[192][49]);int randill(int j);//控制不同的病的不同的发病率。就是使得一种病，每次检测时，的发病率不同//小农田显示void showxtbaifen(void);void xtbaifen(int x, int y, FILE* filePointer5);//画出白粉病，适用于俯视图。25*25大小void showxtnianchong(void);void xtnianchong(int x, int y, FILE* filePointer5);//画出白粉病，适用于俯视图。25*25大小void xtymmian(int x, int y, FILE* filePointer5);void showxtymmian(void);void showxtymnian(void);void xtymnian(int x, int y, FILE* filePointer5);void showxtmhmian(void);void xtmhmian(int x, int y, FILE* filePointer5);void showxtmhxiu(void);void xtmhxiu(int x, int y, FILE* filePointer5);#endif illness.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965#include &quot;common.h&quot;/*==========================植物患病的概率===========================*/int randill(int k)//这里j代表系数,注意0，1，2，3.&#123;//随机显示 点 int judge; int i, j; int a[4][60] = //这一堆控制的是显示点数量的比例啥的，没什么大用。。。建议不用看 &#123; //棉铃虫对于玉米的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40,40,40,40,5,5,5,5,7,7,7,7,7,8,8,8,8,10,10,10,10,11,11,11,12,13,13,14,14,14,14,14,15,15,16,17,18,19,20,20,20,20,20,20 &#125;, //黏虫对于小麦的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40, 40,40,40,40,5,5,5,6,6,6,6,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,12,12,12,13,14,14,15,16,17,18,19,20,21,22,22,22,22,22 &#125;, //黏虫对于玉米的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40, 40,40,40,40,5,5,6,6,6,6,7,7,7,9,9,9,10,10,10,11,11,11,12,12,12,13,13,13,13,13,14,14,15,16,16,17,18,19,20,21,22,22,22,22 &#125;, //白粉对于小麦的 &#123;40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40, 40,40,40,40,5,5,5,5,5,5,7,7,7,7,7,8,8,8,8,10,10,10,10,11,11,11,12,13,13,14,14,14,14,14,16,17,18,19,20,20,20,20,20,20 &#125;, &#125;; int b[4][60] = &#123; 0 &#125;; judge = rand() % 8; if (judge != 0)//有8分之一的概率全部是正常 &#123; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 60; j++) &#123; b[i][j] = a[i][j]; &#125; &#125; &#125; else &#123; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 60; j++) &#123; b[i][j] = 999; &#125; &#125; &#125; i = rand() % 60; return b[k][i];&#125;/*==========================显示棉铃虫，大农田===========================*/void showmianling(unsigned char aaa[192][49])//棉铃虫。感染玉米和棉花。&#123;// int aaa[49] = &#123; 0 &#125;;// int temp; int judge = 0; int j; int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//控制y的加的数，使其跳过小麦区域。 int x; int y; int i; x = 0; y = 0; i = 0; temp = randill(0);//控制发病率的调整比例 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域的发病率 &#123; j = -1; for (y = 65 + 50; y &lt; 465; y = y + jia2[j])//3行 &#123; ifmianling(aaa[i]);//控制点的形成 j++; judge = rand() % temp; if (judge == 0)// &#123; mianling(x, y,aaa[i]); mian.bfzuobiao[i][0] = x; mian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;/*==========================显示棉铃虫点列===========================*/void mianling(int x, int y, unsigned char aaa[49])//&#123; int i; int j; int jjj; int mlxy[49][2] = &#123; //蓝色点所有可能的位置...49个点 &#123; 7 , 3 &#125;, &#123; 19 , 1 &#125;, &#123; 20 ,1 &#125;, &#123; 6 , 5 &#125;, &#123; 9, 5 &#125;, &#123; 18 , 4&#125;, &#123; 18 , 5&#125;, &#123; 11 , 6 &#125;, &#123; 14 , 6 &#125;, &#123; 5 ,7 &#125;, &#123; 2 , 8 &#125;, &#123; 7 ,8 &#125;, &#123; 13 ,7 &#125;, &#123; 17 , 7 &#125;, &#123; 22 ,7 &#125;, &#123; 19 , 8 &#125;, &#123; 20 , 8 &#125;, &#123; 6 , 10 &#125;, &#123; 4 , 11 &#125;, &#123; 1 ,13 &#125;, &#123; 3 , 16 &#125;, &#123; 1 ,17 &#125;, &#123; 1 , 18 &#125;, &#123; 2 , 18 &#125;, &#123; 7 , 19 &#125;, &#123; 7 , 20 &#125;, &#123; 5 ,23 &#125;, &#123; 7 , 23 &#125;, &#123; 10 , 12 &#125;, &#123; 10 , 13 &#125;, &#123; 9 , 17 &#125;, &#123; 11 , 15 &#125;, &#123; 12 , 14 &#125;, &#123; 19 , 12 &#125;, &#123; 22 , 12 &#125;, &#123; 22 ,13 &#125;, &#123; 22 , 15 &#125;, &#123; 18 , 15 &#125;, &#123; 19 , 16 &#125;, &#123; 13 , 17 &#125;, &#123; 15 , 16 &#125;, &#123; 15 , 19 &#125;, &#123; 16 , 19 &#125;, &#123; 14 , 21 &#125;, &#123; 15 , 23 &#125;, &#123; 16 , 22 &#125;, &#123; 17 , 24&#125;, &#123; 19 , 21 &#125;, &#123; 21 , 23 &#125;, &#125;; for (i = 0; i &lt; 49; i++) &#123; mlxy[i][0] = mlxy[i][0] + x; mlxy[i][1] = mlxy[i][1] + y; &#125; for (j = 0; j &lt; 49; j++) &#123; jjj = getshu(aaa, j); if ( jjj== 1) &#123; setcolor(BLUE); putpixel(mlxy[j][0], mlxy[j][1], BLUE); &#125; &#125;&#125;/*==========================使得能够随机显示棉铃虫点列===========================*/void ifmianling(unsigned char aaa[49])//随机显示&#123; int judge[49]; int i; for (i = 0; i &lt; 49; i++) &#123; judge[i] = rand() % 2;//显示的概率为 1/2.. if (judge[i] == 1) &#123; setshu(aaa, i, 0);//不显示 &#125; else &#123; setshu(aaa, i, 1);//显示 &#125; &#125;&#125;void shownianchong(unsigned char aaa[384][49])//黏虫。两者均患&#123; int judge = 0; int j; int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;; int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;; int x; int y; int i; int temp1, temp2; temp1 = randill(1); temp2 = randill(2); x = 0; y = 0; i = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域的发病率 &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j]) &#123; ifnianchong(aaa[i]); j++; judge = rand() % temp1;// if (judge == 0)// &#123; nianchong(x, y,aaa[i]); nian.bfzuobiao[i][0] = x; nian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125; i = 192;//就是说，nian.bfzuobiao[i][],第1--192个是小麦区域的得了黏虫病的坐标，第193-384个是玉米的 //注意， 进行了农药喷洒后，请注意把对应的坐标 重新赋值为0 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域的发病率 &#123; j = -1; for (y = 65+50; y &lt; 465; y = y + jia2[j])//3行 &#123; ifnianchong(aaa[i]); j++; judge = rand() % temp2;// 1/4的发病率 if (judge == 0)// &#123; nianchong(x, y,aaa[i]); nian.bfzuobiao[i][0] = x; nian.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;void nianchong(int x, int y, unsigned char aaa[49])//&#123; int i; int j; int jjj; int ncxy[43][2] = &#123; //洋红色点所有可能的位置...43个点 &#123; 1 , 2 &#125;, &#123; 1 , 5 &#125;, &#123; 3 , 3 &#125;, &#123; 2 ,20 &#125;, &#123; 2 , 22 &#125;, &#123; 4 , 20 &#125;, &#123; 6 , 13 &#125;, &#123; 6 , 14 &#125;, &#123; 6 , 16 &#125;, &#123; 7 , 14 &#125;, &#123; 10 , 9 &#125;, &#123; 10 , 11 &#125;, &#123; 11 , 10 &#125;, &#123; 13 ,11 &#125;, &#123; 15 , 9 &#125;, &#123; 16 , 10 &#125;, &#123; 16 , 11 &#125;, &#123; 17 , 10 &#125;, &#123; 18 , 9 &#125;, &#123; 11 , 18 &#125;, &#123; 11 ,19 &#125;, &#123; 11 , 20 &#125;, &#123; 10 ,19 &#125;, &#123; 10 , 21 &#125;, &#123; 17 , 17&#125;, &#123; 16 , 18 &#125;, &#123; 17 , 18 &#125;, &#123; 18 , 18 &#125;, &#123; 22 ,17 &#125;, &#123; 22 , 19 &#125;, &#123; 21 , 18 &#125;, &#123; 21 , 19 &#125;, &#123; 21 , 20 &#125;, &#123; 11 , 2 &#125;, &#123; 13 , 2 &#125;, &#123; 13 , 3 &#125;, &#123; 15 , 3 &#125;, &#123; 16 , 2 &#125;, &#123; 20 , 3&#125;, &#123; 20 , 4 &#125;, &#123; 21 , 5 &#125;, &#123; 22 , 3 &#125;, &#123; 22 , 4 &#125; &#125;; for (i = 0; i &lt; 43; i++) &#123; ncxy[i][0] = ncxy[i][0] + x; ncxy[i][1] = ncxy[i][1] + y; &#125; for (j = 0; j &lt; 43; j++) &#123; jjj = getshu(aaa, j); if (jjj == 1) &#123; setcolor(YELLOW); putpixel(ncxy[j][0], ncxy[j][1], YELLOW); &#125; &#125;&#125;void ifnianchong(unsigned char aaa[49])//随机显示&#123; int judge[43]; int i; for (i = 0; i &lt; 43; i++) &#123; judge[i] = rand() % 2;//显示的概率为 1/2. if (judge[i] == 1) &#123; setshu(aaa, i, 0);//不显示 &#125; else &#123; setshu(aaa, i, 1);//显示 &#125; &#125;&#125;void showbaifen(unsigned char abc[192][49])//白粉病的发病率&#123; int judge = 0; int j; int jia[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//控制y的加的数，使其跳过玉米区域。 int x; int y; int i; int temp; temp = randill(3); x = 0; y = 0; i = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//96*2片区域,,这是24列 &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia[j])//6行 &#123; ifbaifen(abc[i]); j++; judge = rand() % temp; if (judge == 0)// 1/4的概率得病 &#123; baifen(x, y,abc[i]); bai.bfzuobiao[i][0] = x;////储存区域生病的坐标； bai.bfzuobiao[i][1] = y; i++; &#125; else &#123; i++; &#125; &#125; &#125;&#125;void baifen(int x, int y, unsigned char abc[49])//画出白粉病，适用于俯视图。25*25大小&#123; int i; int j; int jjj; int bfxy[34][2] = &#123; //白色点所有可能的位置 &#123;5, 5&#125;, &#123; 7, 4&#125;, &#123; 9, 5&#125;, &#123; 7, 9&#125;, &#123; 4, 9&#125;, &#123; 4, 14&#125;, &#123; 3, 14&#125;, &#123; 8, 18&#125;, &#123; 8, 19&#125;, &#123; 9, 14&#125;, &#123; 13, 5&#125;, &#123; 13, 6&#125;, &#123; 13, 7&#125;, &#123; 13, 8&#125;, &#123; 13, 14&#125;, &#123; 14, 14&#125;, &#123; 14, 17&#125;, &#123; 14, 20&#125;, &#123; 18, 21&#125;, &#123; 19, 15&#125;, &#123; 20, 11&#125;, &#123; 16, 6&#125;, &#123; 17, 6&#125;, &#123; 18, 3&#125;, &#123; 5, 1 &#125;, &#123; 21 , 1 &#125;, &#123; 21 , 23 &#125;, &#123; 5 ,22 &#125;, &#123; 10 ,22 &#125;, &#123; 1 , 13 &#125;, &#123; 1 , 18 &#125;, &#123; 3 , 11 &#125;, &#123;22 , 9 &#125;, &#123; 23 , 19&#125;//34个点 &#125;; for (i = 0; i &lt; 34; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 34; j++) &#123; jjj = getshu(abc, j); if (jjj == 1) &#123; setcolor(WHITE); putpixel(bfxy[j][0], bfxy[j][1], WHITE); &#125; &#125;&#125;void ifbaifen(unsigned char abc[49])//使得白粉病 设置白点的随机显示&#123; int judge[34]; int i; for (i = 0; i &lt; 34; i++) &#123; judge[i] = rand() % 3;//显示的概率为 2/3.。。 if (judge[i] == 1) &#123; setshu(abc, i, 0);//不显示 &#125; else &#123; setshu(abc, i, 1); &#125; &#125; &#125;//============================================================================================================//============================================================================================================//下面为小农田void showxtbaifen(void)//小农田显示白粉病&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[104][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(3); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;w&quot;); getxtxiao(plantPositions3);//使得小麦坐标到了plantpositions3 for (x = 0; x &lt; 104; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtbaifen(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // fclose(filePointer5); // 关闭文件&#125;void xtbaifen(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[31][2] = &#123; //白色点所有可能的位置 31 &#123; 1 , 2 &#125;, &#123; 2 , 6 &#125;, &#123; 2 , 10 &#125;, &#123; 2 , 13 &#125;, &#123; 1 , 15 &#125;, &#123; 3 , 8 &#125;, &#123; 3 , 18 &#125;, &#123; 4 , 12 &#125;, &#123; 5 , 4 &#125;, &#123; 5 , 8 &#125;, &#123; 5 , 14 &#125;, &#123; 5 , 16 &#125;, &#123; 5 , 17 &#125;, &#123; 7 , 9 &#125;, &#123; 10 , 2 &#125;, &#123; 10 , 3 &#125;, &#123; 10 , 8 &#125;, &#123; 10 , 13 &#125;, &#123; 10 , 17 &#125;, &#123; 12 , 8 &#125;, &#123; 12 , 10 &#125;, &#123; 14 , 6 &#125;, &#123; 14 , 13 &#125;, &#123; 15 , 2 &#125;, &#123; 15 , 16 &#125;, &#123; 18 , 3 &#125;, &#123; 17 , 8 &#125;, &#123; 17 , 13 &#125;, &#123; 18 , 11 &#125;, &#123; 19 , 11 &#125;, &#123; 19 , 17 &#125; &#125;; int ttemp; for (i = 0; i &lt; 31; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 31; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(WHITE); putpixel(bfxy[j][0], bfxy[j][1], WHITE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125; &#125;void showxtnianchong(void)//小农田&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[104][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(3); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;w&quot;); // 以读取模式打开文件 filePointer5 = fopen(&quot;data//xmncdian.dat&quot;, &quot;w&quot;); // 以读取模式打开文件 getxtxiao(plantPositions3);//使得小麦坐标到了plantpositions3 for (x = 0; x &lt; 104; x++)// &#123; judge = rand() % temp; if (judge == 0) &#123; xtnianchong(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // 关闭文件 fclose(filePointer5); &#125;void xtnianchong(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[27][2] = &#123; //黄色点所有可能的位置 27 &#123; 4, 1 &#125;, &#123; 1 , 4 &#125;, &#123; 1 , 8 &#125;, &#123; 1 , 12 &#125;, &#123; 2 , 16 &#125;, &#123; 3 , 15 &#125;, &#123; 7 , 3 &#125;, &#123; 7 , 7 &#125;, &#123; 5 , 11 &#125;, &#123; 7 , 13 &#125;, &#123; 7 , 16 &#125;, &#123; 8 , 16 &#125;, &#123; 7 , 18 &#125;, &#123; 9 , 6 &#125;, &#123; 10 , 6 &#125;, &#123; 9 , 11 &#125;, &#123; 12 , 4 &#125;, &#123; 12 , 15 &#125;, &#123; 12 , 18 &#125;, &#123; 13, 12 &#125;, &#123; 15 , 8 &#125;, &#123; 15 , 10 &#125;, &#123; 17 , 2 &#125;, &#123; 17 , 6 &#125;, &#123; 16, 18 &#125;, &#123; 17 , 18 &#125;, &#123; 18 , 15 &#125; &#125;; int ttemp; for (i = 0; i &lt; 27; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 27; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(YELLOW); putpixel(bfxy[j][0], bfxy[j][1], YELLOW); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtymmian(void)//小农田玉米的棉虫病坐标&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(2); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtymmian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//ymmldian.dat&quot;, &quot;w&quot;); getxtyumi(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtymmian(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); // 关闭文件 fclose(filePointer5); // 关闭文件&#125;void xtymmian(int x, int y,FILE* filePointer5)//画出&#123; int i; int j; int bfxy[27][2] = &#123; //蓝色点所有可能的位置 27 &#123; 5 , 6 &#125;, &#123; 5 , 8 &#125;, &#123; 8 , 6 &#125;, &#123; 10 ,5 &#125;, &#123; 12 , 6 &#125;, &#123; 14 , 5 &#125;, &#123; 15 , 7 &#125;, &#123; 14 , 9 &#125;, &#123; 13 , 12 &#125;, &#123; 13 , 14 &#125;, &#123; 10 , 19 &#125;, &#123; 11 , 20 &#125;, &#123; 9 , 23 &#125;, &#123; 14 , 18 &#125;, &#123; 14 , 23 &#125;, &#123; 14 , 26 &#125;, &#123; 13 , 29 &#125;, &#123; 13 , 34 &#125;, &#123; 16 , 29 &#125;, &#123; 16 , 34 &#125;, &#123; 17 , 11 &#125;, &#123; 17 , 22 &#125;, &#123; 19 , 20 &#125;, &#123; 21 , 19 &#125;, &#123; 23 , 18 &#125;, &#123; 24 , 21 &#125;, &#123; 25 , 23 &#125; &#125;; int ttemp; for (i = 0; i &lt; 27; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 27; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(BLUE); putpixel(bfxy[j][0], bfxy[j][1], BLUE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtymnian(void)&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(2); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//ymncdian.dat&quot;, &quot;w&quot;); getxtyumi(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtymnian(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtymnian(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[26][2] = &#123; //蓝色点所有可能的位置 26 &#123; 3 , 10 &#125;, &#123; 4 , 7 &#125;, &#123; 6 , 4 &#125;, &#123; 6 , 6 &#125;, &#123; 8 , 8 &#125;, &#123; 11 , 5 &#125;, &#123; 10, 6 &#125;, &#123; 14 , 3 &#125;, &#123; 16 , 5 &#125;, &#123; 13 , 8 &#125;, &#123; 12 , 10 &#125;, &#123; 24 , 19 &#125;, &#123; 23 , 20 &#125;, &#123; 26 , 24 &#125;, &#123; 16 , 20 &#125;, &#123; 17 , 20 &#125;, &#123; 14 , 20 &#125;, &#123; 9 , 21 &#125;, &#123; 9 , 26 &#125;, &#123; 13 , 25 &#125;, &#123; 15 , 27 &#125;, &#123; 15 , 32 &#125;, &#123; 13 , 31 &#125;, &#123; 14 , 21 &#125;, &#123; 15 , 23 &#125;, &#123; 11 , 21 &#125; &#125;; int ttemp; for (i = 0; i &lt; 26; i++) &#123; bfxy[i][0] = bfxy[i][0] + x; bfxy[i][1] = bfxy[i][1] + y; &#125; for (j = 0; j &lt; 26; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(YELLOW); putpixel(bfxy[j][0], bfxy[j][1], YELLOW); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtmhmian(void)//小农田 棉花的棉铃虫病坐标&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(1); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//mhmldian.dat&quot;, &quot;w&quot;); getxtmianhua(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtmhmian(plantPositions3[i][0], plantPositions3[i][1],filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtmhmian(int x, int y, FILE* filePointer5)&#123; int i; int j; int bfxy[33][2] = &#123; // 33 &#123; 9 , 2 &#125;, &#123; 9 , 5 &#125;, &#123; 8 , 6 &#125;, &#123; 11 , 3 &#125;, &#123; 12 , 6 &#125;, &#123; 11 , 9 &#125;, &#123; 5 , 12 &#125;, &#123; 4 , 14 &#125;, &#123; 6 , 15 &#125;, &#123; 9 , 15 &#125;, &#123; 5 , 18 &#125;, &#123; 11 , 16 &#125;, &#123; 12 , 13 &#125;, &#123; 13 , 20 &#125;, &#123; 12 , 23 &#125;, &#123; 11 , 25 &#125;, &#123; 13 , 25 &#125;, &#123; 12 , 27 &#125;, &#123; 12 , 29 &#125;, &#123; 16 , 2 &#125;, &#123; 16 , 4 &#125;, &#123; 14 , 5 &#125;, &#123; 15 , 8 &#125;, &#123; 13 , 9 &#125;, &#123; 13 , 11 &#125;, &#123; 17 , 6 &#125;, &#123; 19 , 6 &#125;, &#123; 20 , 8 &#125;, &#123; 19 , 12 &#125;, &#123; 18 , 15 &#125;, &#123; 20 , 15 &#125;, &#123; 19 , 18 &#125;, &#123; 21 , 18 &#125; &#125;; int ttemp; for (i = 0; i &lt; 33; i++) &#123; bfxy[i][0] = bfxy[i][0] + x-1; bfxy[i][1] = bfxy[i][1] + y+1; &#125; for (j = 0; j &lt; 33; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(BLUE); putpixel(bfxy[j][0], bfxy[j][1], BLUE); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125;void showxtmhxiu(void)&#123; FILE* filePointer4; FILE* filePointer5; int plantPositions3[68][2]; int judge = 0; int j; int x; int i; int temp; temp = randill(1); x = 0; i = 0; filePointer4 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;w&quot;); filePointer5 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;w&quot;); getxtmianhua(plantPositions3); for (x = 0; x &lt; 68; x++) &#123; judge = rand() % temp; if (judge == 0) &#123; xtmhxiu(plantPositions3[i][0], plantPositions3[i][1], filePointer5); fprintf(filePointer4, &quot;%d %d\n&quot;, plantPositions3[i][0], plantPositions3[i][1]); i++; &#125; else &#123; i++; &#125; &#125; fclose(filePointer4); fclose(filePointer5); &#125;void xtmhxiu(int x, int y, FILE* filePointer5)//&#123; int i; int j; int bfxy[35][2] = &#123; //洋红色点所有可能的位置 35 &#123; 8 , 0 &#125;, &#123; 6 , 5 &#125;, &#123; 5 , 6 &#125;, &#123; 4 , 16 &#125;, &#123; 6 , 13 &#125;, &#123; 8 , 14 &#125;, &#123; 7 , 17 &#125;, &#123; 11 , 1 &#125;, &#123; 10 , 2 &#125;, &#123; 10 , 8 &#125;, &#123; 10 , 7 &#125;, &#123; 11 , 12 &#125;, &#123; 11 , 15 &#125;, &#123; 11 , 18 &#125;, &#123; 11 , 20 &#125;, &#123; 11 , 22 &#125;, &#123; 11 , 31 &#125;, &#123; 12 , 32 &#125;, &#123; 12 , 10 &#125;, &#123; 13 , 15 &#125;, &#123; 13 , 16 &#125;, &#123; 13 , 18 &#125;, &#123; 13 , 22 &#125;, &#123; 13 , 30 &#125;, &#123; 14 , 10 &#125;, &#123; 16 , 9 &#125;, &#123; 18 , 4 &#125;, &#123; 18 , 8 &#125;, &#123; 20 , 6 &#125;, &#123; 17 , 13 &#125;, &#123; 18 , 17 &#125;, &#123; 19 , 14 &#125;, &#123; 19 , 16 &#125;, &#123; 21 , 14 &#125;, &#123; 21 , 17 &#125; &#125;; int ttemp; for (i = 0; i &lt; 35; i++) &#123; bfxy[i][0] = bfxy[i][0] + x-1; bfxy[i][1] = bfxy[i][1] + y+1; &#125; for (j = 0; j &lt; 35; j++) &#123; ttemp = rand() % 2; if (ttemp == 1) &#123; setcolor(LIGHTRED); putpixel(bfxy[j][0], bfxy[j][1], LIGHTRED); fprintf(filePointer5, &quot;%d %d\n&quot;, bfxy[j][0], bfxy[j][1]); &#125; &#125;&#125; 其实这里有很多重复的代码和东西，一个农田只看一种植物的一种病就可以了。。其他都是复制粘贴的，说实话。建议不用细看，因为颜色点的随机显示，老师根本不注重，而且不会细看。。。现在让我自己看，我也看不懂 。 recover123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;common.h&quot;//===========================//大农田里面的部分植物自愈//===========================void recover(void)//完全随机重新刷新；；&#123; int j;//跳过区域用 int jia1[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//跳过玉米区域。 int jia2[] = &#123; 25,75,25,75,25,75,25,75 &#125;;//跳过小麦区域。 int x, y;//循环 int i = 0;//调用患病植株坐标 int ii;//同上 int judge = 0;//恢复比例的分子 int temp1, temp2;//自愈比例分母 temp1 = randrecover(0);//小麦自愈比例 temp2 = randrecover(1);//玉米自愈比例 for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//小麦区域, &#123; j = -1; for (y = 65; y &lt; 465; y = y + jia1[j])// &#123; j++; judge = rand() % temp1;// if (judge == 0)// &#123; setcolor(BROWN); setfillstyle(1, BROWN); bar(x, y, x + 25, y + 25);//矩形覆盖原生病植物。再画健康植物 fxiaomai(x, y); nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][1] = 0; bai.bfzuobiao[i][0] = 0; bai.bfzuobiao[i][1] = 0;//使其为0；表示其恢复健康。 i++; &#125; else i++; &#125; &#125; i = 192; ii = 0; for (x = 20; x &lt; 620 - 25 + 1; x = x + 25)//玉米区域 &#123; j = -1; for (y = 65 + 50; y &lt; 465; y = y + jia2[j])// &#123; j++; judge = rand() % temp2;// if (judge == 0)// &#123; setcolor(BROWN); setfillstyle(1, BROWN); bar(x, y, x + 25, y + 25); fyumi(x,y); mian.bfzuobiao[ii][0] = 0; mian.bfzuobiao[ii][1] = 0;//使其为0，表示健康 nian.bfzuobiao[i][0] = 0; nian.bfzuobiao[i][1] = 0;// i++; ii++; &#125; else &#123; i++;//表示仍然患病，跳过 ii++; &#125; &#125; &#125;&#125;int randrecover(int k)//恢复比例分配&#123; int i; int a[2][10] = &#123; &#123;1,1,2,2,2,2, 2,3,3,4&#125;,//小麦 &#123;1,1,2,2,2,2, 2,3,3,4&#125;//玉米的 &#125;; i = rand() % 10; return a[k][i];&#125; 这里的生病、自愈都是完全用随机数搞的，但实际上验收老师就看了一两遍无人机扫描结果，所以根本没有用。。。 elsetian123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577#include &quot;common.h&quot;// 画植物，均为左上角坐标。void drawPlants(void)&#123; // 绘制固定位置的植物 int i; //玉米的坐标30*35 int plantPositions1[][2] =//直接穷举法列举出植物坐标 &#123; //梯田那部分。11个 &#123;100,100&#125;, &#123; 3 , 92 &#125;, &#123; 73 , 89 &#125;, &#123; 46 , 171 &#125;, &#123; 138 , 213 &#125;, &#123; 99 , 154 &#125;, &#123; 120 , 151 &#125;, &#123; 9 , 120 &#125;, &#123; 65 , 140 &#125;, &#123; 158 , 156 &#125;, &#123; 89 , 199 &#125;,//最右上角一块 5 &#123; 501 , 238 &#125;, &#123; 598 , 265 &#125;, &#123; 598 , 227 &#125;, &#123; 574 , 144 &#125;, &#123; 544 ,132 &#125;,// 第三块 18 &#123; 350 , 95 &#125;, &#123; 356 , 132 &#125;, &#123; 366 , 168 &#125;, &#123; 379 , 204 &#125;, &#123; 392 , 243&#125;, &#123; 469 , 100&#125;, &#123; 470 , 139 &#125;, &#123; 470 , 215 &#125;, &#123; 470 , 175 &#125;, &#123; 470 , 254 &#125;, &#123; 473 , 294 &#125;, &#123; 416 , 265 &#125;, &#123; 447 , 291 &#125;, &#123; 405 , 197 &#125;, &#123; 416 , 231 &#125;, &#123; 445 , 254 &#125;, &#123; 438 , 220 &#125;, &#123; 452 , 191 &#125;, // 最上面区域 6个 &#123; 0,256 &#125;, &#123; 31 , 283 &#125;, &#123; 66 , 291 &#125;, &#123; 149 , 281 &#125;, &#123; 120 , 289 &#125;, &#123; 94 , 293 &#125;, &#123; 105 , 330 &#125;, &#123; 108 , 367 &#125;, &#123; 118 , 437 &#125;, &#123; 111 , 402 &#125;, &#123; 55 , 326 &#125;, &#123; 69 , 421 &#125;, &#123; 67 , 358 &#125;, &#123; 177 , 321 &#125;, &#123; 181 , 349 &#125;, &#123; 188, 414 &#125;, &#123; 195 , 380 &#125;, &#123; 207 , 329 &#125;, &#123; 212 , 365 &#125;, &#123; 212, 411 &#125;, &#123; 232 , 330 &#125;, &#123; 236 , 366 &#125;, &#123; 236 , 443 &#125;, &#123; 236 , 405 &#125;, &#123; 608 , 380 &#125;, &#123; 592 , 411 &#125;, &#123; 611 , 442 &#125;, &#123; 328 , 443 &#125;, &#123; 371 , 406 &#125;, &#123; 376 , 369 &#125;, &#123; 379 , 332 &#125;, &#123; 337 , 406 &#125;, &#123; 337 , 369 &#125;, &#123; 346 , 332 &#125; &#125;; //棉花的20*35 int plantPositions2[][2] = &#123; //梯田那部分。12个 &#123; 31 , 89 &#125;, &#123; 53 , 85 &#125;, &#123; 123 , 111 &#125;, &#123; 75 , 182 &#125;, &#123; 115 , 193 &#125;, &#123; 165 , 198 &#125;, &#123; 147 , 136 &#125;, &#123; 45 , 117 &#125;, &#123; 28 , 145 &#125;, &#123; 90 , 123 &#125;, &#123; 141 , 176 &#125;, &#123; 502 , 90 &#125;, &#123; 502 , 305 &#125;, &#123; 502 , 129 &#125;, &#123; 502 , 157 &#125;, &#123; 502 , 199 &#125;, &#123; 502 , 278 &#125;, &#123; 530 , 315 &#125;, &#123; 605 , 305 &#125;, &#123; 582 , 308 &#125;, &#123; 556 , 311 &#125;, &#123; 521 , 103 &#125;, &#123; 585 , 123 &#125;, &#123; 605 , 129 &#125;, //中间 23 &#123; 283 , 87 &#125;, &#123; 304 , 87 &#125;, &#123; 284, 128 &#125;, &#123; 271 , 153 &#125;, &#123; 306 , 125 &#125;, &#123; 316 , 156 &#125;, &#123; 259 , 181 &#125;, &#123; 249 , 218&#125;, &#123; 326, 194 &#125;, &#123; 283 , 181 &#125;, &#123; 305 , 188 &#125;, &#123; 279 , 222 &#125;, &#123; 305 , 227 &#125;, &#123; 335 , 228 &#125;, &#123; 364 , 271 &#125;, &#123; 340, 284 &#125;, &#123; 317, 290 &#125;, &#123; 296 , 293 &#125;, &#123; 443 , 155 &#125;, &#123; 416, 148 &#125;, &#123; 427 , 177&#125;, &#123; 320 , 252 &#125;, &#123; 264 , 331 &#125;, &#123; 265 , 369 &#125;, &#123; 264 , 443 &#125;, &#123; 264, 406 &#125;, &#123; 286 , 331 &#125;, &#123; 287 , 369 &#125;, &#123; 286 , 406 &#125;, &#123; 285 , 443 &#125;, &#123; 314 , 332 &#125;, &#123; 309 , 443 &#125;, &#123; 310 , 405 &#125;, &#123; 308 , 368 &#125;, &#123; 583 , 365 &#125;, &#123; 517 , 406 &#125;, &#123; 493 , 439 &#125;, &#123; 517 , 442 &#125;, &#123; 574 , 440 &#125;, &#123; 547 , 442 &#125;, &#123; 538 , 403 &#125;, &#123; 565 , 403 &#125;, &#123; 550 , 366 &#125;, &#123; 360 , 443 &#125; &#125;; //小麦占地.20*19 总共104个 int plantPositions3[][2] = &#123; //最右上角一块 &#123; 607 , 166 &#125;, &#123; 609 , 189 &#125;, &#123; 604 , 210 &#125;, &#123; 525 , 144 &#125;, &#123; 532 , 167 &#125;, &#123; 524 , 189 &#125;, &#123; 544 , 189 &#125;, &#123; 562 , 189 &#125;, &#123; 586 , 183&#125;, &#123; 556 , 170 &#125;, &#123; 526 , 212 &#125;, &#123; 548 , 212 &#125;, &#123; 569 , 212 &#125;, &#123; 584 , 204 &#125;, &#123; 534 , 237 &#125;, &#123; 559 , 236 &#125;, &#123; 532 , 265 &#125;, &#123; 527 , 290 &#125;, &#123; 555 , 285 &#125;, &#123; 579 , 283 &#125;, &#123; 553 , 259 &#125;, &#123; 576 , 262 &#125;, &#123; 581 , 240 &#125;, // 中间 &#123; 260 , 104 &#125;, &#123; 257 , 128 &#125;, &#123; 249 , 153 &#125;, &#123; 242 , 178 &#125;, &#123; 234 , 202 &#125;, &#123; 227 , 226 &#125;, &#123; 220 , 250 &#125;, &#123; 213 , 274 &#125;, &#123; 230 , 275 &#125;, &#123; 230 , 299&#125;, &#123; 327 , 104 &#125;, &#123; 330 , 128 &#125;, &#123; 336 , 151 &#125;, &#123; 344 , 174 &#125;, &#123; 351 , 198 &#125;, &#123; 357 , 222 &#125;, &#123; 364 , 247 &#125;, //第三块 8 &#123; 385 , 106 &#125;, &#123; 410 , 108 &#125;, &#123; 434 , 108 &#125;, &#123; 389 , 133 &#125;, &#123; 415 , 134 &#125;, &#123; 445 , 135 &#125;, &#123; 393, 161 &#125;, // 整个上区域 20 &#123;231 , 107 &#125;, &#123; 228 , 130 &#125;, &#123; 222 , 152 &#125;, &#123; 215 , 173 &#125;, &#123; 207 , 197 &#125;, &#123; 200 , 223 &#125;, &#123; 190 , 249 &#125;, &#123; 182 , 271 &#125;, &#123; 194 , 288 &#125;, &#123; 204 , 108 &#125;, &#123; 176 , 108 &#125;, &#123; 150 , 107 &#125;, &#123; 169 , 132 &#125;, &#123; 196 , 132 &#125;, &#123; 188 , 154 &#125;, &#123; 192 , 176 &#125;, &#123; 33 , 261 &#125;, &#123; 59 , 272 &#125;, &#123; 83 , 275 &#125;, &#123; 2 , 235 &#125;, //所有下方区域 32 &#123; 131 , 330 &#125;, &#123; 133 , 353 &#125;, &#123; 137, 377 &#125;, &#123; 142 , 401 &#125;, &#123; 146 , 425 &#125;, &#123; 146 , 450 &#125;, &#123; 157 , 331 &#125;, &#123; 159 , 353 &#125;, &#123; 162 , 378 &#125;, &#123; 167 , 402 &#125;, &#123; 170 , 425&#125;, &#123; 168 , 455 &#125;, &#123; 10 , 342 &#125;, &#123; 22 , 365 &#125;, &#123; 29 , 392 &#125;, &#123; 21 , 437 &#125;, &#123; 28 , 415 &#125;, &#123; 36 , 337 &#125;, &#123; 47 , 361 &#125;, &#123; 53 , 387 &#125;, &#123; 54 , 411 &#125;, &#123; 52 , 434 &#125;, &#123; 465 , 378 &#125;, &#123; 470 , 406 &#125;, &#123; 469 , 432 &#125;, &#123; 469 , 456 &#125;, &#123; 443 , 391 &#125;, &#123; 445 , 415 &#125;, &#123; 443 , 444 &#125;, &#123; 420 , 412&#125;, &#123; 419 , 447 &#125;, &#123; 393 , 455 &#125;, &#123; 88 , 341 &#125;, &#123;90,384 &#125;, &#123;72 ,399 &#125;, &#123;93 ,413 &#125;, &#123; 97,437 &#125; &#125;; for (i = 0; i &lt; sizeof(plantPositions1) / sizeof(plantPositions1[0]); i++)//画植物 &#123; yumi(plantPositions1[i][0], plantPositions1[i][1]); &#125; for (i = 0; i &lt; sizeof(plantPositions2) / sizeof(plantPositions2[0]); i++)// &#123; mianhua(plantPositions2[i][0], plantPositions2[i][1]); &#125; for (i = 0; i &lt; sizeof(plantPositions3) / sizeof(plantPositions3[0]); i++) &#123; xiaomaikuai(plantPositions3[i][0], plantPositions3[i][1]); &#125; setxtzhiwu(plantPositions1, plantPositions2, plantPositions3);//记录植物的坐标&#125;//============================================================//小农田主界面int elsetian(int* a5)&#123; srand(time(NULL)); if (*a5 == 1)//绘图 &#123; cleardevice(); clrmous(MouseX, MouseY); drawBackground(); //梯田 bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 *a5 = 0; &#125; //============= //恢复农田 if (*a5 == -1) &#123; cleardevice(); clrmous(MouseX, MouseY); drawBackground(); bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 binghai(); *a5 = 2; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(100, 5, 100 + 140, 50); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a5 = 1; return 1;//返回前一个界面 &#125; else if (mouse_press(100, 5, 240, 50) == 1) &#123; delay(100); clrmous(MouseX, MouseY); grow();//无人机动画的实现 if (*a5 == 2 || *a5 == -1) &#123; delay(200); cleardevice(); clrmous(MouseX, MouseY); drawBackground(); bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0);//208*180 tian();//画农田。 bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants();//画植物 drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0);//石头 drawScarecrow(570, 61);//稻草人1 drawScarecrow(500, 325);//稻草人2 &#125; showxtbaifen(); showxtnianchong(); showxtymmian(); showxtymnian(); showxtmhxiu(); showxtmhmian(); *a5 = 2; &#125; if (*a5 == 2 || *a5 == -1) &#123; showbiankuang(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50); showbiankuang(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50); if (mouse_press(100 + 140 + 30, 5, 100 + 140 + 30 + 140, 50) == 1) &#123; *a5 = -1; delay(100); return 5;//结果查看部分 &#125; else if (mouse_press(100 + 140 + 140 + 30 + 30, 5, 100 + 140 + 140 + 30 + 30 + 140, 50) == 1) &#123; *a5 = -1; delay(100); return 7;//准备喷洒部分 &#125; &#125; return 3;&#125;// 画稻草人void drawScarecrow(int x, int y)&#123; setcolor(BROWN); setfillstyle(SOLID_FILL, YELLOW); fillellipse(x, y, 10, 10); setfillstyle(SOLID_FILL, DARKGRAY); fillellipse(x, y - 5, 15, 5); setfillstyle(SOLID_FILL, BLACK); fillellipse(x - 3, y + 2, 2, 2); fillellipse(x + 3, y + 2, 2, 2); setfillstyle(SOLID_FILL, YELLOW); bar(x - 5, y + 10, x + 5, y + 60); bar(x - 20, y + 10, x - 5, y + 15); bar(x + 5, y + 10, x + 20, y + 15); bar(x - 2, y + 60, x + 2, y + 80);&#125;void drawdxg(int x, int y)//电线杆&#123; setcolor(LIGHTGRAY); setfillstyle(SOLID_FILL, LIGHTGRAY); bar(14 + x, y, 18 + x, 83 + y); line(x + 0, y +26 , x +25 , y +18 ); line(x +25 , y +18 , x +25 , y +21 ); line(x + 25, y + 21, x +0 , y +29 ); line(x + 0, y +29 , x +0 , y +26 ); floodfill(x+8, y+25, LIGHTGRAY); floodfill(x+21,y+ 20, LIGHTGRAY); line(x + 3, y +6 , x + 27, y + 13); line(x + 27, y +13 , x +27 , y +17 ); line(x + 27, y +17 , x +1 , y +9 ); line(x + 1, y +9 , x + 2, y + 6); line(x + 2, y +6 , x + 3, y + 6); floodfill(x + 10, y + 9, LIGHTGRAY); floodfill(x + 20, y + 13, LIGHTGRAY);&#125;// 画不规则形状的农田void tian(void)&#123; int points1[] = &#123; 150,480,130,335, 285,480 - 130,405,335,400,430,500,370,640,405,640,480 &#125;;//最下面中间的 int points2[] = &#123; 400,280,500,360, 640,340,640,116,200,116,200,280 &#125;;//上面的 setcolor(BROWN); setfillstyle(1, BROWN); arc(-62, 420, 0, 360, 90); arc(70, 560, 0, 360, 105); line(140, 480, 125, 335); line(125, 335, 0, 352); floodfill(100, 420, BROWN);//左下角的 fillpoly(8, points1);//多边形绘制 fillpoly(6, points2);//多边形绘制 line(0, 280, 210, 280); ellipse(100, 280, 180, 360, 100, 50);//椭圆 floodfill(100, 290, BROWN); line(0 + 200, 280, 210 + 200 - 10, 280); ellipse(100 + 200, 280, 180, 360, 100, 50);//椭圆 floodfill(100 + 200, 290, BROWN); line(150, 280 + 20 + 10, 280, 300 + 10); floodfill(200, 290, BROWN); line(400, 280, 500, 360); line(500, 360, 640, 340); line(640, 340, 640, 116); line(110, 116, 640, 116); line(200, 116, 200, 280); line(200, 280, 400, 280); line(400, 280, 500, 360); line(500, 360, 640, 340); line(640, 340, 640, 116); line(110, 116, 640, 116); line(200, 116, 200, 280); line(200, 280, 400, 280); setfillstyle(1, BLUE); floodfill(630, 350, BROWN); floodfill(10, 400, BROWN); floodfill(100, 470, BROWN); setcolor(WHITE); line(208, 280, 258, 116); line(400, 280 + 1, 350, 116); line(500, 360 - 1, 500, 116); setfillstyle(1, GREEN); setcolor(GREEN); line(0, 98, 640, 98);//分割线 line(630, 116, 640, 116); line(640, 116, 640, 340); line(640, 340, 630, 342); line(630, 342, 630, 116); floodfill(632, 120, GREEN);&#125;void binghai(void)//画病害&#123; int row; FILE* filePointer1; FILE* filePointer2; FILE* filePointer3; FILE* filePointer4; FILE* filePointer5; FILE* filePointer6; int a22[68 * 35][2] = &#123; 0 &#125;; int a11[103 * 31][2] = &#123; 0 &#125;; filePointer1 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 103 * 31; row++) &#123; fscanf(filePointer1, &quot;%d %d&quot;, &amp;a11[row][0], &amp;a11[row][1]); &#125; fclose(filePointer1); for (row = 0; row &lt; 103 * 31; row++)// &#123; setcolor(WHITE); putpixel(a11[row][0], a11[row][1], WHITE); &#125; for (row = 0; row &lt; 103 * 31; row++) &#123; a11[row][0] = 0; a11[row][1] = 0; &#125; filePointer2 = fopen(&quot;data//xmncdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 103 * 31; row++) &#123; fscanf(filePointer2, &quot;%d %d&quot;, &amp;a11[row][0], &amp;a11[row][1]); &#125; for (row = 0; row &lt; 103 * 31; row++) &#123; setcolor(YELLOW); putpixel(a11[row][0], a11[row][1], YELLOW); &#125; fclose(filePointer2); filePointer3 = fopen(&quot;data//ymncdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer3, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(YELLOW); putpixel(a22[row][0], a22[row][1], YELLOW); &#125; fclose(filePointer3); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer4 = fopen(&quot;data//ymmldian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer4, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(BLUE); putpixel(a22[row][0], a22[row][1], BLUE); &#125; fclose(filePointer4); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer5 = fopen(&quot;data//mhmldian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer5, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(BLUE); putpixel(a22[row][0], a22[row][1], BLUE); &#125; fclose(filePointer5); for (row = 0; row &lt; 68 * 35; row++) &#123; a22[row][0] = 0; a22[row][1] = 0; &#125; filePointer6 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;r&quot;); for (row = 0; row &lt; 68 * 35; row++) &#123; fscanf(filePointer6, &quot;%d %d&quot;, &amp;a22[row][0], &amp;a22[row][1]); &#125; for (row = 0; row &lt; 68 * 35; row++) &#123; setcolor(LIGHTRED); putpixel(a22[row][0], a22[row][1], LIGHTRED); &#125; fclose(filePointer6);&#125; 类似大农田，实现的功能类似。加了个显示高度的功能。好累啊，自己看吧 outcome.h1234567891011121314#ifndef _OUTCOME_H_#define _OUTCOME_H_//=大农田的 结果查看int outcome(int* a3);//核心void draw111(void);//普通绘图void xiaomaioutcome(void);//小麦结果void yumioutcome(void);//玉米结果//=====================================int elseoutcome(int* a3);void draw222(void);void elseyumioutcome(void);void elsexiaomaioutcome(void);void elsemianhuaoutcome(void);#endif outcome.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731#include&quot;common.h&quot;/*=========================大农田小麦结果查看===========================*/void xiaomaioutcome(void)&#123; int y2, y3, y4; int i; double yt; char string[20]; yt = 0; y2 = 0; y3 = 0; y4 = 0; draw111(); setcolor(GREEN); line(64, 419, 563, 419); line(556-5, 406, 563, 419); line(563, 419, 556-5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总小麦面积比例&quot;, 16, 15, GREEN); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419-150, 65, 419 - 150); outtextxy(15, 419 - 150-9, &quot;50%&quot;); line(63, 419-75, 65, 419 - 75); outtextxy(15, 419 - 75-9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225-9, &quot;75%&quot;); line(84, 418, 84, 420); line(84+70, 418, 84+70, 420); puthz(84+20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84+70+30, 418, 84+70+30, 420); line(84 + 70 + 30+70, 418,84 + 70 + 30+70, 420); puthz(84+70+30+5, 430, &quot;患白粉病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70+30, 418, 84 + 70 + 30 + 70+30, 420); line(84 + 70 + 30 + 70 + 30+70, 418, 84 + 70 + 30 + 70+70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30+5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70+30, 418, 84 + 70 + 30 + 70 +30+ 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70+70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 +70+ 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 192; i++) &#123; if (bai.bfzuobiao[i][0] == 0 &amp;&amp; bai.bfzuobiao[i][1] == 0&amp;&amp; nian.bfzuobiao[i][0] == 0 &amp;&amp; nian.bfzuobiao[i][1]==0) &#123; yt+=1; &#125; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; y2++; &#125; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; y3++; &#125; if(bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0&amp;&amp; nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; y4++; &#125; &#125; setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 192, 84 + 70, 419); sprintf(string, &quot;%.lf/192&quot;, yt); outtextxy(84, 419 - (yt * 300) / 192-20, string); bar(84 + 100 + 70,419 - (y2 * 300) / 192, 84 + 100, 419 ); sprintf(string, &quot;%d/192&quot;, y2); outtextxy(84 + 100 , 419 - (y2 * 300) / 192-20, string); bar( 84 + 270, 419 - (y3 * 300) / 192, 84 + 200, 419); sprintf(string, &quot;%d/192&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 192-20, string); bar(84 +370, 419 - (y4 * 300) / 192,84 + 300, 419 ); sprintf(string, &quot;%d/192&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 192-20, string); if (yt &gt;= 192 - 8) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 15) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 25) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 35) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 192 - 60) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================大农田结果查看===========================*/int outcome(int* a3)&#123; if (*a3 == 1) &#123; cleardevice(); draw111(); *a3 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(311 - 25, 3, 421, 37); showbiankuang(442, 3, 546 + 25, 37); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; delay(100); return 2;//返回前一个界面 &#125; else if (mouse_press(311 - 25, 3, 421, 35) == 1&amp;&amp;( *a3==0 || *a3== 3)) &#123; *a3 = 2; cleardevice(); delay(100); xiaomaioutcome(); //小麦的 &#125; else if (mouse_press(442, 3, 546 + 25, 35) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2)) &#123; *a3 = 3; cleardevice(); delay(100); yumioutcome(); //玉米的 &#125; return 6;&#125;/*=========================小农田结果查看===========================*/int elseoutcome(int* a3)&#123; if (*a3 == 1) &#123; cleardevice(); draw222(); *a3 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(197, 3, 325, 37); showbiankuang(329, 3, 455, 37); showbiankuang(461, 3, 586, 37); //界面的跳转 if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a3 = 1; delay(100); return 3;//返回前一个界面 &#125; else if (mouse_press(197, 3, 325, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 3 || *a3 == 4)) &#123; *a3 = 2; cleardevice(); delay(100); elsexiaomaioutcome(); //小麦的 &#125; else if (mouse_press(329, 3, 455, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2 || *a3 == 4)) &#123; *a3 = 3; cleardevice(); delay(100); elseyumioutcome(); //玉米的 &#125; else if (mouse_press(461, 3, 586, 37) == 1 &amp;&amp; (*a3 == 0 || *a3 == 2 || *a3 == 3)) &#123; *a3 = 4; cleardevice(); delay(100); elsemianhuaoutcome(); //棉花的 &#125; return 5;&#125;/*=========================小农田小麦结果查看===========================*/void elsexiaomaioutcome(void)&#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2] ; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 filePointer12 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); //坐标轴绘制 setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总小麦面积比例&quot;, 16, 15, GREEN); puthz(200, 50, &quot;小麦生长状况柱形图&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;患白粉病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); //统计植物病虫害情况。 for (i = 0; i &lt; 103; i++) &#123; int a, b; a=fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]) ; b=fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]) ; if (a==2) &#123; y2++; &#125; if ( b== 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt;y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 103 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); //坐标轴。柱形图 setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 103, 84 + 70, 419); sprintf(string, &quot;%.lf/103&quot;, yt); outtextxy(84, 419 - (yt * 300) / 103 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 103, 84 + 100, 419); sprintf(string, &quot;%d/103&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 103 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/103&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 103 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/103&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 103 - 20, string); //显示总体评价 if (yt &gt;= 103 - 7) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 13) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 20) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 30) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 103 - 50) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================小农田玉米结果查看===========================*/void elseyumioutcome(void) &#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2]; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtymnian.dat&quot;, &quot;r&quot;); // 以读取模式打开文件 filePointer12 = fopen(&quot;data//xtymmian.dat&quot;, &quot;r&quot;); yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;玉米生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总玉米株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 68; i++) &#123; int a, b; a = fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]); b = fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]); if (a == 2) &#123; y2++; &#125; if (b == 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt; y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 68 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 68, 84 + 70, 419); sprintf(string, &quot;%.lf/68&quot;, yt); outtextxy(84, 419 - (yt * 300) / 68 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 68, 84 + 100, 419); sprintf(string, &quot;%d/68&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 68 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/68&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 68 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/68&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 68 - 20, string); if (yt &gt;= 68 -5) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 10) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 14) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 20) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 40) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================小农田棉花结果查看===========================*/void elsemianhuaoutcome(void)&#123; int y2, y3, y4; int i, j; double yt; char string[20]; int baifen[103][2]; int nianchong[103][2]; FILE* filePointer11; FILE* filePointer12; filePointer11 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;r&quot;); filePointer12 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;r&quot;); yt = 0; y2 = 0; y3 = 0; y4 = 0; draw222(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;棉花生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占总棉花株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30 + 5, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;患上锈病&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); for (i = 0; i &lt; 68; i++) &#123; int a, b; a = fscanf(filePointer11, &quot;%d %d&quot;, &amp;baifen[i][0], &amp;baifen[i][1]); b = fscanf(filePointer12, &quot;%d %d&quot;, &amp;nianchong[i][0], &amp;nianchong[i][1]); if (a == 2) &#123; y2++; &#125; if (b == 2) &#123; y3++; &#125; &#125; for (i = 0; i &lt; y2; i++) &#123; for (j = 0; j &lt; y3; j++) &#123; if (baifen[i][0] == nianchong[j][0] &amp;&amp; baifen[i][1] == nianchong[j][1]) &#123; y4++; &#125; &#125; &#125; yt = 68 - y2 - y3 + y4; fclose(filePointer11); fclose(filePointer12); setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (yt * 300) / 68, 84 + 70, 419); sprintf(string, &quot;%.lf/68&quot;, yt); outtextxy(84, 419 - (yt * 300) / 68 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 68, 84 + 100, 419); sprintf(string, &quot;%d/68&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 68 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 103, 84 + 200, 419); sprintf(string, &quot;%d/68&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 68 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 103, 84 + 300, 419); sprintf(string, &quot;%d/68&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 68 - 20, string); if (yt &gt;= 68 - 5) &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 9) &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68- 15) &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 25) &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN);// &#125; else if (yt &gt;= 68 - 34) &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN);// &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN);// &#125;&#125;/*=========================绘制大农田普适背景===========================*/void draw111(void)&#123; setbkcolor(WHITE); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); line(0, 40, 640, 40); setfillstyle(1, WHITE); bar(90, 1, 140, 22); setcolor(GREEN); puthz(90 + 2, 1 + 2, &quot;白粉病&quot;, 16, 15, GREEN); setfillstyle(1, BLUE); bar(145, 1, 195, 22); puthz(145 + 2, 1 + 2, &quot;棉铃虫&quot;, 16, 15, GREEN); setfillstyle(1, YELLOW); bar(200, 1, 250, 22); puthz(200 + 2, 1 + 2, &quot;黏虫病&quot;, 16, 15, GREEN); setfillstyle(1, GREEN); bar(311 - 25, 3, 421, 37); bar(442, 3, 546 + 25, 37); puthz(311 - 25 + 2, 3, &quot;小麦情况&quot;, 32, 30, WHITE); puthz(442 + 2, 3, &quot;玉米情况&quot;, 32, 30, WHITE);&#125;/*=========================绘制小农田普适背景===========================*/void draw222(void)&#123; setbkcolor(WHITE); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); line(0, 40, 640, 40); setfillstyle(1, WHITE); bar(90, 0, 140, 19); setcolor(GREEN); puthz(90 + 2, 0 + 2, &quot;白粉病&quot;, 16, 15, GREEN); setfillstyle(1, BLUE); bar(145, 0, 195, 19); puthz(145 + 2, 0 + 2, &quot;棉铃虫&quot;, 16, 15, GREEN); setfillstyle(1, YELLOW); bar(90, 19, 140, 38); puthz(90 + 2, 19 + 2, &quot;黏虫病&quot;, 16, 15, GREEN); setfillstyle(1, LIGHTRED); bar(145, 19, 195, 38); puthz(145 + 2, 19 + 2, &quot;锈病&quot;, 16, 15, GREEN); setfillstyle(1, GREEN); bar(197, 3, 325, 37); bar(329, 3, 455, 37); bar(461, 3, 586, 37); puthz(197 + 2, 3, &quot;小麦情况&quot;, 32, 30, WHITE); puthz(329 + 2, 3, &quot;玉米情况&quot;, 32, 30, WHITE); puthz(461 + 2, 3, &quot;棉花情况&quot;, 32, 30, WHITE);&#125;/*=========================大农田玉米结果查看===========================*/void yumioutcome(void)&#123; int y2, y3, y4; int i; double y1; char string[20]; int j; y1 = 0; y2 = 0; y3 = 0; y4 = 0; draw111(); setcolor(GREEN); line(64, 419, 563, 419); line(556 - 5, 406, 563, 419); line(563, 419, 556 - 5, 432); line(64, 419, 64, 76); line(64, 76, 53, 88); line(64, 76, 72, 88); puthz(200, 50, &quot;玉米生长状况柱形图&quot;, 16, 15, GREEN); puthz(400, 50, &quot;总体：&quot;, 16, 15, GREEN); puthz(70, 80, &quot;占玉米总株数比例&quot;, 16, 15, GREEN); line(63, 119, 65, 119); settextstyle(1, HORIZ_DIR, 1); outtextxy(15, 110, &quot;100%&quot;); line(63, 419 - 150, 65, 419 - 150); outtextxy(15, 419 - 150 - 9, &quot;50%&quot;); line(63, 419 - 75, 65, 419 - 75); outtextxy(15, 419 - 75 - 9, &quot;25%&quot;); line(63, 419 - 225, 65, 419 - 225); outtextxy(15, 419 - 225 - 9, &quot;75%&quot;); line(84, 418, 84, 420); line(84 + 70, 418, 84 + 70, 420); puthz(84 + 20, 430, &quot;健康&quot;, 16, 15, GREEN); line(84 + 70 + 30, 418, 84 + 70 + 30, 420); line(84 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70, 420); puthz(84 + 70 + 30, 430, &quot;感染棉铃虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70, 418, 84 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 5, 430, &quot;感染黏虫&quot;, 16, 15, GREEN); line(84 + 70 + 30 + 70 + 30 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 30, 420); line(84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 418, 84 + 70 + 30 + 70 + 30 + 70 + 70 + 30, 420); puthz(84 + 70 + 30 + 70 + 30 + 70 + 30, 430, &quot;两种均感染&quot;, 16, 15, GREEN); //统计各个植物的患病情况 for (i = 0, j = 192; i &lt; 192, j &lt; 384; i++, j++) &#123; if (mian.bfzuobiao[i][0] == 0 &amp;&amp; mian.bfzuobiao[i][1] == 0 &amp;&amp; nian.bfzuobiao[j][0] == 0 &amp;&amp; nian.bfzuobiao[j][1] == 0) &#123; y1 += 1;//无病 &#125; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; y2++; &#125; if (nian.bfzuobiao[j][0] != 0 &amp;&amp; nian.bfzuobiao[j][1] != 0) &#123; y3++; &#125; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0 &amp;&amp; nian.bfzuobiao[j][0] != 0 &amp;&amp; nian.bfzuobiao[j][1] != 0) &#123; y4++;//二者均患 &#125; &#125; //绘制坐标轴，以及显示柱形图 setcolor(RED); settextstyle(1, HORIZ_DIR, 1); bar(84, 419 - (y1 * 300) / 192, 84 + 70, 419); sprintf(string, &quot;%.lf/192&quot;, y1); outtextxy(84, 419 - (y1 * 300) / 192 - 20, string); bar(84 + 100 + 70, 419 - (y2 * 300) / 192, 84 + 100, 419); sprintf(string, &quot;%d/192&quot;, y2); outtextxy(84 + 100, 419 - (y2 * 300) / 192 - 20, string); bar(84 + 270, 419 - (y3 * 300) / 192, 84 + 200, 419); sprintf(string, &quot;%d/192&quot;, y3); outtextxy(84 + 200, 419 - (y3 * 300) / 192 - 20, string); bar(84 + 370, 419 - (y4 * 300) / 192, 84 + 300, 419); sprintf(string, &quot;%d/192&quot;, y4); outtextxy(84 + 300, 419 - (y4 * 300) / 192 - 20, string); //显示生长状态 if (y1 &gt;= 192 - 8)//8 &#123; puthz(370 + 84, 50, &quot;健康&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 15)//15 &#123; puthz(370 + 84, 50, &quot;正常&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 25)//25 &#123; puthz(370 + 84, 50, &quot;病虫预防&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 35)//35 &#123; puthz(370 + 84, 50, &quot;急需喷洒&quot;, 16, 15, GREEN); &#125; else if (y1 &gt;= 192 - 60)//60 &#123; puthz(370 + 84, 50, &quot;严重病害&quot;, 16, 15, GREEN); &#125; else &#123; puthz(370 + 84, 50, &quot;重大病害&quot;, 16, 15, GREEN); &#125;&#125; 看起来很复杂，其实很简单，就是一个画柱形图的功能。。。。 好累，你自己看吧 growlook无人机动画核心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551#include &quot;common.h&quot;/*===========================================生长检测部分1。这里仅仅只是实现了动画效果。如，无人机的动画，植物范围的变色，不同的颜色代表了不同的病虫害。具体数据要到结果查看部分。=============================================*/void grow(void)//将两个农田的无人机运动合为一体化&#123; if (getpixel(20, 65) == BROWN)//根据这个判断两个农田.这个是平地农田 &#123; dronemove1(); &#125; else// (getpixel(20,65) == WHITE) //这个是小农田 &#123; dronemove2(); &#125;&#125;//小农田无人机动画void move21(int points[][2], int num_points, int x, int y, int* buffer)&#123; int i; int barrier[2][2] = &#123; 0 &#125;;//障碍物 int barrier1[2][2] = &#123; 0 &#125;; int barrier2[2][2] = &#123; 0 &#125;; int xiao[103][2]; int yu[68][2]; int mian[68][2]; getxtxiao(xiao); getxtyumi(yu); getxtmianhua(mian); barrier[0][0] = 249; barrier[0][1] = 239; barrier[1][0] = 278; barrier[1][1] = 324; barrier1[0][0] = 480; barrier1[0][1] = 326 - 10; barrier1[1][0] = 519; barrier1[1][1] = 415 ; barrier2[0][0] = 549; barrier2[0][1] = 49; barrier2[1][0] = 589; barrier2[1][1] = 141; srand(time(NULL)); // 初始化随机种子 for (i = 0; i &lt; num_points; i++) &#123; int target_x = points[i][0]; // 获取当前目标点的x坐标 int target_y = points[i][1]; // 获取当前目标点的y坐标 int j; int dx = 0; int dy = 0; int xxx = 2; int yyy = 2; int judge; int xmax, ymax, xmin, ymin; int randx[400] = &#123; 0 &#125;; int randy[400] = &#123; 0 &#125;; int randfuzhi; int rand_numbers[400] = &#123; 0 &#125;; // 数组用于存储生成的随机数 int canshu1; int canshu2; int judgee; int movebar[2][2] = &#123; 0 &#125;; if ((target_x - x) &gt;= 0)//判断目标点 &#123; xxx = 0; &#125; else if ((target_x - x) &lt; 0) &#123; xxx = 1; &#125; if ((target_y - y) &gt;= 0) &#123; yyy = 0; &#125; else if ((target_y - y) &lt; 0) &#123; yyy = 1; &#125; if (abs(target_x - x) &gt;= abs(target_y - y)) &#123; for (randfuzhi = 0; randfuzhi &lt; abs((target_x - x) / 2); randfuzhi++) &#123; randx[randfuzhi] = 2;//控制速度 ====================================== randy[randfuzhi] = 0; &#125; for (randfuzhi = 0; randfuzhi &lt; abs((target_y - y) / 2); randfuzhi++) &#123; while (1) &#123; judgee = 1; canshu1 = rand() % (abs(target_y - y) / 2) + 1; for (j = 0; j &lt; randfuzhi; j++) &#123; if (rand_numbers[j] == canshu1) &#123; judgee = 0; &#125; &#125; if (judgee == 1) &#123; break; &#125; &#125; rand_numbers[randfuzhi] = canshu1; // 将生成的随机数标记为已使用 randy[canshu1 - 1] = 2; &#125; &#125; else if (abs(target_x - x) &lt; abs(target_y - y)) &#123; for (randfuzhi = 0; randfuzhi &lt; abs((target_y - y) / 2); randfuzhi++) &#123; randx[randfuzhi] = 0;//控制速度 ====================================== randy[randfuzhi] = 2; &#125; for (randfuzhi = 0; randfuzhi &lt; abs((target_x - x) / 2); randfuzhi++) &#123; while (1) &#123; judgee = 1; canshu2 = rand() % (abs(target_x - x) / 2) + 1; for (j = 0; j &lt; randfuzhi; j++) &#123; if (rand_numbers[j] == canshu2) &#123; judgee = 0; &#125; &#125; if (judgee == 1) &#123; break; &#125; &#125; rand_numbers[randfuzhi] = canshu2; // 将生成的随机数标记为已使用 randx[canshu2 - 1] = 2; randx[randfuzhi] = 2; &#125; &#125; while (x != target_x || y != target_y) &#123; int jj = 0; int aa, bb, cc, dd; judge = rand() % 2; movebar[0][0] = x - 25; movebar[0][1] = y - 44; movebar[1][0] = x + 50; movebar[1][1] = y; if (abs(target_x - x) &lt; 10 || abs(target_y - y) &lt; 10) &#123; if (x != target_x)// &#123; if (judge == 0) &#123; dx = 1; dy = 0; &#125; &#125; if (y != target_y)// &#123; if (judge == 1) &#123; dx = 0; dy = 1; &#125; &#125; &#125; else &#123; dx = randx[jj]; dy = randy[jj]; jj++; &#125; if (x != target_x &amp;&amp; y == target_y &amp;&amp; abs(target_x - x) &lt; 10) &#123; dx = 1; dy = 0; &#125; else if (x != target_x &amp;&amp; y == target_y &amp;&amp; abs(target_x - x) &gt;= 10) &#123; dx = 2; dy = 0; &#125; if (y != target_y &amp;&amp; x == target_x &amp;&amp; abs(target_y - y) &lt; 10) &#123; dx = 0; dy = 1; &#125; else if (y != target_y &amp;&amp; x == target_x &amp;&amp; abs(target_y - y) &gt;= 10) &#123; dx = 0; dy = 2; &#125; aa = skipthing(barrier, movebar, &amp;dx, &amp;dy); bb = skipthing(barrier1, movebar, &amp;dx, &amp;dy); cc = skipthing(barrier2, movebar, &amp;dx, &amp;dy); if (aa == 1 &amp;&amp; bb == 1 &amp;&amp; cc == 1) &#123; if ((target_x - x) &gt;= 0) &#123; xxx = 0; &#125; else if ((target_x - x) &lt; 0) &#123; xxx = 1; &#125; if ((target_y - y) &gt;= 0) &#123; yyy = 0; &#125; else if ((target_y - y) &lt; 0) &#123; yyy = 1; &#125; &#125; xmax = (x + 50) &gt; 639 ? 639 : (x + 50); ymax = (y + 0) &gt; 479 ? 479 : (y + 0); xmin = (x - 25) &lt; 0 ? 0 : (x - 25); ymin = (y - 44) &lt; 20 ? 0 : (y - 44); showheight(x, y, xiao, yu, mian); getimage(xmin, ymin, xmax, ymax, buffer); drtdrone(x, y - 44); //无人机速度控制 delay(15);//15 if (abs(x - target_x) &lt; 2 &amp;&amp; abs(y - target_y) &lt; 2) &#123; delay(50);//100 &#125; putimage(xmin, ymin, buffer, COPY_PUT); if (xxx == 0) &#123; x += dx; // 更新x坐标 &#125; else if (xxx == 1) &#123; x -= dx; // 更新x坐标 &#125; if (yyy == 0) &#123; y += dy; // 更新y坐标 &#125; else if (yyy == 1) &#123; y -= dy; // 更新y坐标 &#125; &#125; &#125;&#125;int skipthing(int barrier[][2], int movebar[][2], int* dx, int* dy)&#123; //barrier 储存的是障碍物坐标，movebar 是无人机坐标。dx,dy是运动的 值。targetxy是终点坐标。 if (barrier[0][0] - 5 &lt;= movebar[1][0] &amp;&amp; barrier[1][0] - 5 &gt;= movebar[0][0] &amp;&amp; barrier[0][1] + 5 &lt;= movebar[1][1] &amp;&amp; barrier[1][1] + 5 &gt;= movebar[0][1] )//障碍物与无人机 相交：：：判断两矩形是否相交。，这里扩充了障碍物，边界+10 &#123; if (abs(movebar[0][1] - barrier[1][1]) &lt; 4)//无人机 上边与 障碍物下边 相交 &#123;//无人机从 上方碰见障碍物 *dy = 0;// 1; *dx = 1; &#125; else if (abs(movebar[1][1] - barrier[0][1]) &lt; 4)//无人机 下边与 障碍物上边 相交 &#123;//无人机从 下方碰见障碍物 *dy = 0;// 1; *dx = 1; &#125; else if (abs(movebar[0][0] - barrier[1][0]) &lt; 4)//无人机 左边与 障碍物右边 相交 &#123;//无人机从 右方碰见障碍物 *dx = 0;// 1; *dy = -1; &#125; else if (abs(movebar[1][0] - barrier[0][0]) &lt; 4)//无人机 右边与 障碍物左边 相交 &#123;//无人机从 左方碰见障碍物 *dx = 0; // -1; *dy = 1; &#125; return 0; &#125; return 1;&#125;void dronemove2(void)&#123; void* buffer1 = malloc(imagesize(0, 0, 75, 44));//定义缓存区 int x1, y1; int a[239][2]; int i, j, k; int temp[2]; int quyu[12] = &#123; 77,110,137,157,185,219,265,316,355,384,417,480 &#125;;//将农田分成11区域，有12个分界线无人机扫描11次 int count[11] = &#123; 0 &#125;;//计算每个区域有多少植物 int ii[11] = &#123; 0 &#125;; int barrier[2][2] = &#123; 0 &#125;; int barrier1[2][2] = &#123; 0 &#125;; int barrier2[2][2] = &#123; 0 &#125;; getxtxiao(a); getxtyumi(&amp;a[103]); getxtmianhua(&amp;a[171]); barrier[0][0] = 249; barrier[0][1] = 239; barrier[1][0] = 278; barrier[1][1] = 324; barrier1[0][0] = 480; barrier1[0][1] = 326 - 10; barrier1[1][0] = 519; barrier1[1][1] = 415 - 10; barrier2[0][0] = 549; barrier2[0][1] = 49; barrier2[1][0] = 589; barrier2[1][1] = 141; paipai(a, barrier2); paipai(a, barrier1); paipai(a, barrier); for (i = 0; i &lt; 238; i++) &#123; for (j = i + 1; j &lt; 239; j++) &#123; if (a[i][1] &gt; a[j][1]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; for (i = 0; i &lt; 239; i++) &#123; for (k = 0; k &lt; 11; k++) &#123; if (a[i][1] &gt;= quyu[k] &amp;&amp; a[i][1] &lt; quyu[k + 1])//判断植物在第几区域内部 &#123; count[k]++; &#125; &#125; &#125; for (i = 1; i &lt; 11; i++) &#123; for (j = 0; j &lt; i; j++) &#123; ii[i] += count[j]; &#125; &#125; ii[0] = 0; i = 0; for (k = 0; k &lt; 11; k++) &#123; if ((k % 2) == 0)//向右移动，x小的 在前 &#123; for (i = ii[k]; i &lt; ii[k] + count[k] - 1; i++) &#123; for (j = i + 1; j &lt; ii[k] + count[k]; j++) &#123; if (a[i][0] &gt; a[j][0]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; &#125; else &#123; for (i = ii[k]; i &lt; ii[k] + count[k] - 1; i++) &#123; for (j = i + 1; j &lt; ii[k] + count[k]; j++) &#123; if (a[i][0] &lt; a[j][0]) &#123; temp[0] = a[i][0]; temp[1] = a[i][1]; a[i][0] = a[j][0]; a[i][1] = a[j][1]; a[j][0] = temp[0]; a[j][1] = temp[1]; &#125; &#125; &#125; &#125; &#125; x1 = 0;//初始化无人机坐标 y1 = 60; move21(a, 239, x1, y1, buffer1); free(buffer1); setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(100, 56, 250, 88); // 清除时间显示区域 delay(100);&#125;void paipai(int a[][2], int barrier2[][2])//排序&#123; int i; for (i = 0; i &lt; 238; i++) &#123; if (a[i][0] &gt;= barrier2[0][0] - 52 &amp;&amp; a[i][0] &lt;= barrier2[1][0] + 26 &amp;&amp; a[i][1] &gt;= barrier2[0][1] &amp;&amp; a[i][1] &lt;= barrier2[1][1] + 46) &#123; if (a[i][0] &lt;= ((barrier2[1][0] + barrier2[0][1]) / 2)) &#123; a[i][0] = barrier2[1][0] - 53; a[i][1] = barrier2[0][1]; &#125; else &#123; a[i][0] = barrier2[1][0] + 27; a[i][1] = barrier2[1][1]; &#125; &#125; &#125;&#125;//大农田的无人机运动void dronemove1(void)&#123; //-======================================================== void* buffer1 = malloc(imagesize(0, 0, 25, 25)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int* judge = malloc(sizeof(int)); int i; *x1 = 0; *judge = 65; *y1 = 65; //==================================== //整个运动的实现 for (i = 0; i &lt; 7; i++) &#123; move11(x1, y1, buffer1); move12(x1, y1, buffer1, judge); move13(x1, y1, buffer1); move12(x1, y1, buffer1, judge); //这三个运动为一个循环。。。 &#125; move11(x1, y1, buffer1); move12(x1, y1, buffer1, judge); for (; *x1 &gt; 0; *x1 = *x1 - 2)//运动到了最左端。。 &#123; getimage(*x1, *y1, *x1 + 25, *y1 + 25, buffer1);//保存image到buffer drfdrone(*x1, *y1); delay(8); putimage(*x1, *y1, buffer1, COPY_PUT);//恢复图像 &#125; for (; *y1 &gt; 65; *y1 = *y1 - 1)//运动到了最左端。。 &#123; getimage(*x1, *y1, *x1 + 25, *y1 + 25, buffer1);//保存image到buffer drfdrone(*x1, *y1); delay(5); putimage(*x1, *y1, buffer1, COPY_PUT);//恢复图像 &#125; free(buffer1); free(x1); free(y1); free(judge); delay(100);&#125;void showheight(int x, int y, int xiao[][2], int yu[][2], int mian[][2])//显示无人机高度&#123; char string[20]; int high = 0; int i; int judge = 0; int randshu; if (x &gt; 1 &amp;&amp; x &lt; 203 &amp;&amp; y &lt; 278 &amp;&amp; y&gt;76)//梯田区域 &#123; for (i = 0; i &lt; 103; i++) &#123; if (abs(x - xiao[i][0]) &lt; 4 &amp;&amp; abs(y - xiao[i][1]) &lt; 4) &#123; high = rand() % 30 + 150 + 300; judge = 1; &#125; &#125; for (i = 0; i &lt; 68; i++) &#123; if (abs(x - yu[i][0]) &lt; 4 &amp;&amp; abs(y - yu[i][1]) &lt; 4) &#123; high = rand() % 50 + 330 + 300; judge = 1; &#125; if (abs(x - mian[i][0]) &lt; 4 &amp;&amp; abs(y - mian[i][1]) &lt; 4) &#123; high = rand() % 50 + 210 + 300; judge = 1; &#125; &#125; &#125; else &#123; for (i = 0; i &lt; 103; i++) &#123; if (abs(x - xiao[i][0]) &lt; 4 &amp;&amp; abs(y - xiao[i][1]) &lt; 4) &#123; high = rand() % 30 + 150; judge = 1; &#125; &#125; for (i = 0; i &lt; 68; i++) &#123; if (abs(x - yu[i][0]) &lt; 4 &amp;&amp; abs(y - yu[i][1]) &lt; 4) &#123; high = rand() % 50 + 330; judge = 1; &#125; if (abs(x - mian[i][0]) &lt; 4 &amp;&amp; abs(y - mian[i][1]) &lt; 4) &#123; high = rand() % 50 + 210; judge = 1; &#125; &#125; &#125; if (judge == 0) &#123; randshu = rand() % 100; if (randshu == 1) &#123; if (getpixel(x, y) == BLUE) &#123; high = rand() % 40 + 300; &#125; else if (x &gt; 1 &amp;&amp; x &lt; 203 &amp;&amp; y &lt; 278 &amp;&amp; y&gt;76)//梯田区域 &#123; high = rand() % 40 + 100+300; &#125; else if (high &lt; 150) &#123; high = rand() % 40 + 200; &#125; &#125; else high = 0; &#125; if (high &gt;= 150) &#123; setcolor(WHITE); setfillstyle(SOLID_FILL, WHITE); bar(177, 56, 230, 88); // 清除高度 setcolor(GREEN); settextstyle(1, HORIZ_DIR, 1); sprintf(string, &quot;height: %d cm&quot;, high); outtextxy(107, 57, string);//显示字符串 &#125;&#125; 这段代码小农田的不用细看，因为这个避障和斜线运动功能确实很难做，所以当时也是乱凑，凑出来了个半成品。。。。显示高度可以看看。自己看吧，打算一口气结束这个C课设拯救计划了。太累了了了了了 队友写的反正我当时没看多久，也没看懂，现在更加不想看了，有兴趣可以自己分析。 zpjm.h1234567891011121314151617181920212223#ifndef _ZPJM_H_#define _ZPJM_H_int zpjiemian(int* a9, int nongyao[6]);void chejian(void);//绘画车间图像void nongdu(int judge);//浓度显示void jizhan(void);//无人机基站图像void xiangzi(int x, int y , int num,int judge2);//农药储存箱图像void drcar(int x, int y,int judge1);//小车void nydrone(int x, int y ,int judge4);//车间内无人机图像void fushitu(int x, int y);//小农田农药无人机图void suofangtu(int x, int y , int judge4);//大农田农药无人机缩放图void zpdh(int judge3);//农药装配动画void moveps0(int judge1, int* x, int* y, int* buffer2);//向左特殊运动void moveps1(int judge1, int* x, int* y, int* buffer2);//向右特殊运动void moveps2(int judge1, int* x, int* y, int* buffer2);//向右进一区void moveps3(int judge1, int* x, int* y, int* buffer2);//向上进一区void moveps4(int judge1, int* x, int* y, int* buffer2);//向下进一区void moveps6(int judge1, int* x, int* y, int* buffer2);//向左进一区void moveps7(int judge1, int* x, int* y, int* buffer2);//向下取药void moveps8(int judge1, int* x, int* y, int* buffer2);//向上回位void moveps9(int judge1, int* x, int* y, int* buffer2);//向上装药#endif zpjm.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594 #include &quot;common.h&quot;int zpjiemian(int* a9, int nongyao[6])&#123; if (*a9 == 1) &#123; chejian(); *a9 = 0; &#125; if (*a9 == 0 || (*a9 &gt; 1 &amp;&amp; *a9 &lt; 10)) if (mouse_press(20, 95, 110, 135) == 1) &#123; if (*a9 == 0) *a9 = 2; else if (*a9 &gt; 1 &amp;&amp; *a9 &lt; 10) *a9 = *a9 + 1; nongdu(*a9); delay(400); &#125; if (*a9 &gt; 1 &amp;&amp; *a9 &lt; 11) if (mouse_press(130, 95, 220, 135) == 1) &#123; if (*a9 == 2) *a9 = 0; else if (*a9 &gt; 2 &amp;&amp; *a9 &lt; 11) *a9 = *a9 - 1; nongdu(*a9); delay(400); &#125; if (mouse_press(220, 200, 370, 300) == 1) &#123; if (nongyao[0] == 1) &#123; nongyao[0] = 2; zpdh(0); *a9 = 1; return 9; &#125; if (nongyao[0] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(420, 200, 570, 300) == 1) &#123; if (nongyao[1] == 1) &#123; nongyao[1] = 2; zpdh(1); *a9 = 1; return 9; &#125; if (nongyao[1] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(20, 350, 170, 450) == 1) &#123; if (nongyao[2] == 1) &#123; nongyao[2] = 2; zpdh(2); *a9 = 1; return 9; &#125; if (nongyao[2] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(220, 350, 370, 450) == 1) &#123; if (nongyao[3] == 1) &#123; nongyao[3] = 2; zpdh(3); *a9 = 1; return 9; &#125; if (nongyao[3] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(420, 350, 570, 450) == 1) &#123; if (nongyao[4] == 1) &#123; nongyao[4] = 2; zpdh(4); *a9 = 1; return 9; &#125; if (nongyao[4] == 0) &#123; return 8; &#125; &#125; else if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a9 = 1; return 7;//返回前一个界面 &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); return 8;&#125;void chejian(void)//绘画车间图像&#123; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, LIGHTGRAY); bar(20, 150, 620, 200); bar(20, 300, 620, 350); bar(170, 200, 220, 450); bar(370, 200, 420, 450); bar(570, 200, 620, 450); bar(370, 20, 420, 150); setcolor(DARKGRAY); line(370, 20, 370, 150); line(420, 20, 420, 150); line(20, 150, 370, 150); line(20, 200, 170, 200); line(420, 150, 620, 150); line(620, 150, 620, 450); line(170, 200, 170, 300); line(20, 300, 170, 300); jizhan(); xiangzi(220, 200, 0, nongyao[0]); xiangzi(420, 200, 1, nongyao[1]); xiangzi(20, 350, 2, nongyao[2]); xiangzi(220, 350, 3, nongyao[3]); xiangzi(420, 350, 4, nongyao[4]); drcar(20, 150,0); nydrone(265, 40, 0); setfillstyle(1, YELLOW); bar(20, 55, 220, 135); setfillstyle(1, RED); bar(20, 95, 220, 135); setfillstyle(1, WHITE); bar(60, 95, 70, 135); bar(45, 110, 85, 120); bar(150, 108, 200, 122); rectangle(20, 55, 220, 135); line(20, 95, 220, 95); setfillstyle(1, DARKGRAY); bar(110, 95, 130, 135); puthz(25, 60, &quot;浓度&quot;, 24, 30, GREEN); settextstyle(1, HORIZ_DIR, 2); setcolor(GREEN); outtextxy(85, 56, &quot;:&quot;); setcolor(RED); outtextxy(140, 58, &quot;%&quot;); nongdu(0);&#125;void nongdu(int judge)//浓度显示&#123; char a[3]; setcolor(RED); setfillstyle(1, YELLOW); bar(100, 58, 138, 94); if(judge==0) sprintf(a, &quot;%d&quot;, 10); if (judge == 2) sprintf(a, &quot;%d&quot;, 20); if (judge == 3) sprintf(a, &quot;%d&quot;, 30); if (judge == 4) sprintf(a, &quot;%d&quot;, 40); if (judge == 5) sprintf(a, &quot;%d&quot;, 50); if (judge == 6) sprintf(a, &quot;%d&quot;, 60); if (judge == 7) sprintf(a, &quot;%d&quot;, 70); if (judge == 8) sprintf(a, &quot;%d&quot;, 80); if (judge == 9) sprintf(a, &quot;%d&quot;, 90); if (judge == 10) sprintf(a, &quot;%d&quot;, 100); outtextxy(100, 58, a);&#125;void jizhan(void)//无人机基站图像&#123; setcolor(DARKGRAY); setfillstyle(1, DARKGRAY); bar(290, 45, 370, 50); bar(330, 55, 335, 80); bar(320, 80, 345, 82); setfillstyle(1, LIGHTGRAY); bar(320, 40, 345, 55); rectangle(320, 40, 345, 55);&#125;void xiangzi(int x, int y ,int num,int judge2)//农药储存箱图像&#123; setcolor(DARKGRAY); setfillstyle(1,LIGHTGRAY); bar(x, y, x + 150, y + 100); bar(x+125, y-10, x+145 , y); rectangle(x + 125, y - 10, x + 145, y); rectangle(x, y, x + 150, y + 100); line(x, y + 1, x + 150, y + 1); line(x, y + 99, x + 150, y + 99); line(x + 149, y, x + 149, y + 100); setfillstyle(1, DARKGRAY); bar(x + 125, y -10, x + 150, y - 4); if (judge2 == 1) &#123; if (num == 0) &#123; puthz(x + 5, y + 35, &quot;氯铃胺&quot;, 24, 30, DARKGRAY); &#125; else if (num == 1) &#123; puthz(x + 5, y + 35, &quot;甲胺磷&quot;, 24, 30, DARKGRAY); &#125; else if (num == 2) &#123; puthz(x + 5, y + 35, &quot;氯氰菊酯&quot;, 24, 30, DARKGRAY); &#125; else if (num == 3) &#123; puthz(x + 5, y + 35, &quot;甲维盐&quot;, 24, 30, DARKGRAY); &#125; else if (num == 4) &#123; puthz(x + 5, y + 35, &quot;菌酯&quot;, 24, 30, DARKGRAY); &#125; &#125; else &#123; line(x, y, x + 150, y + 100); line(x+150, y, x , y + 100); line(x+1, y, x + 151 ,y + 100); line(x + 151, y, x+1, y + 100); &#125;&#125;void drcar(int x, int y,int judge1)//小车&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y + 20, x + 50, y + 40); rectangle(x, y + 20, x + 50, y + 40); setfillstyle(1, DARKGRAY); bar(x + 35, y, x + 45, y + 20); bar(x, y, x + 40, y + 6); bar(x + 5, y + 35, x + 20, y + 50); bar(x + 30, y + 35, x + 45, y + 50); setfillstyle(1, WHITE); bar(x + 10, y + 40, x + 15, y + 45); bar(x + 35, y + 40, x + 40, y + 45); if (judge1 == 0) &#123; setfillstyle(1, RED); bar(x + 35, y + 25, x + 40, y + 30); rectangle(x + 35, y + 25, x + 40, y + 30); &#125; else if (judge1 == 1) &#123; setfillstyle(1, GREEN); bar(x + 35, y + 25, x + 40, y + 30); rectangle(x + 35, y + 25, x + 40, y + 30); &#125;&#125;void nydrone(int x , int y , int judge4)//车间内无人机图像&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y - 5, x + 25, y + 30); rectangle (x, y - 5, x + 25, y + 30); line(x + 5, y - 5, x + 5, y + 30); line(x + 6, y - 5, x + 6, y + 30); line(x + 20, y - 5, x + 20, y + 30); line(x + 19, y - 5, x + 19, y + 30); setfillstyle(1, DARKGRAY); bar(x - 5, y - 5, x, y); bar(x - 10, y - 10, x - 5, y - 5); bar(x + 25, y - 5, x + 30, y); bar(x + 30, y - 10, x + 35, y-5); bar(x - 5, y +25, x, y+30); bar(x - 10, y + 30, x-5, y + 35); bar(x + 25, y + 25, x + 30, y + 30); bar(x + 30, y + 30, x + 35, y + 35); bar(x - 15, y - 20, x - 10, y + 45); bar(x + 35 , y - 20, x + 40, y + 45); if (judge4 == 0) &#123; setfillstyle(1, RED); bar(x + 10,y+10 , x + 15, y+15); &#125; else if (judge4 == 1) &#123; setfillstyle(1, GREEN); bar(x + 10, y + 10, x + 15, y + 15); &#125;&#125;void fushitu(int x, int y)//小农田农药无人机图&#123; setcolor(DARKGRAY); setfillstyle(1, BLUE); bar(x+6, y, x + 14, y + 10); rectangle(x+6 , y, x + 14, y + 10); setfillstyle(1, DARKGRAY); bar(x , y, x + 20, y + 2); bar(x , y, x +2, y + 5); bar(x + 18, y, x + 20, y + 5); setfillstyle(1, LIGHTGRAY); bar(x+5, y, x + 15, y + 5); rectangle(x+5, y, x + 15, y + 5);&#125;void suofangtu(int x, int y, int judge4)//大农田农药无人机缩放图&#123; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(x, y - 2, x + 10, y + 12); rectangle(x, y - 2, x + 10, y + 12); line(x + 2, y - 2, x + 2, y + 12); line(x + 3, y - 2, x + 3, y + 12); line(x + 8, y - 2, x + 8, y + 12); line(x + 7, y - 2, x + 7, y + 12); setfillstyle(1, DARKGRAY); bar(x - 2, y - 2, x, y); bar(x - 4, y - 4, x - 2, y - 2); bar(x + 10, y - 2, x + 12, y); bar(x + 12, y - 4, x + 14, y - 2); bar(x - 2, y + 10, x, y + 12); bar(x - 4, y + 12, x - 2, y + 14); bar(x + 10, y + 10, x + 12, y + 12); bar(x + 12, y + 12, x + 14, y + 14); bar(x - 6, y - 8, x - 4, y + 18); bar(x + 14, y - 8, x + 16, y + 18); if (judge4 == 0) &#123; setfillstyle(1, RED); bar(x + 4, y + 4, x + 6, y + 6); &#125; else if (judge4 == 1) &#123; setfillstyle(1, GREEN); bar(x + 4, y + 4, x + 6, y + 6); &#125;&#125;void zpdh(int judge3)//农药装配动画&#123; void* buffer2 = malloc(imagesize(0, 0, 50, 50)); int* x2 = malloc(sizeof(int)); int* y2 = malloc(sizeof(int)); int i; *x2 = 20; *y2 = 150; setcolor(DARKGRAY); setfillstyle(1, LIGHTGRAY); bar(20, 150, 70, 200); line(20, 150, 370, 150); line(20, 200, 170, 200); moveps1(0, x2, y2, buffer2); if (judge3 == 0) &#123; moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 1) &#123; moveps2(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps6(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 2) &#123; moveps4(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps2(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 3) &#123; moveps4(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; else if (judge3 == 4) &#123; moveps4(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps2(0, x2, y2, buffer2); moveps7(0, x2, y2, buffer2); moveps8(1, x2, y2, buffer2); moveps3(1, x2, y2, buffer2); moveps6(1, x2, y2, buffer2); moveps9(1, x2, y2, buffer2); moveps0(0, x2, y2, buffer2); &#125; drcar(20, 150, 0); free(buffer2); free(x2); free(y2); delay(100);&#125;void moveps0(int judge1, int* x, int* y, int* buffer2)//向左特殊运动&#123; for (; *x &gt;20; *x = *x - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps1(int judge1, int* x, int* y, int* buffer2)//向右特殊运动&#123; for (; *x &lt;170; *x = *x + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y,judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps2(int judge1, int* x, int* y, int* buffer2)//向右进一区&#123; int xx; xx = *x; for (; *x-xx &lt; 200; *x = *x + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps3(int judge1, int* x, int* y, int* buffer2)//向上进一区&#123; int yy; yy = *y; for (; yy - *y &lt; 150; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps4(int judge1, int* x, int* y, int* buffer2)//向下进一区&#123; int yy; yy = *y; for (; *y - yy &lt; 150; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps6(int judge1, int* x, int* y, int* buffer2)//向左进一区&#123; int xx; xx = *x; for (; xx - *x &lt; 200; *x = *x - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps7(int judge1, int* x, int* y, int* buffer2)//向下取药&#123; int yy; yy = *y; for (; *y - yy &lt; 40; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(200); drcar(*x, *y, 1); delay(200); putimage(*x, *y, buffer2, COPY_PUT);&#125;void moveps8(int judge1, int* x, int* y, int* buffer2)//向上回位&#123; int yy; yy = *y; for (; yy-*y &lt; 40; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(8); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125;void moveps9(int judge1, int* x, int* y, int* buffer2)//装药，回位&#123; int yy; yy = *y; for (; yy - *y &lt; 50; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(16); putimage(*x, *y, buffer2, COPY_PUT); &#125; for (; yy - *y &lt; 105; *y = *y - 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, judge1); delay(200); drcar(*x, *y, 0); nydrone(265, 40, 1); delay(200); putimage(*x, *y, buffer2, COPY_PUT); for (; yy - *y &gt;50; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, 0); delay(20); putimage(*x, *y, buffer2, COPY_PUT); &#125; for (; yy - *y &gt;0; *y = *y + 2) &#123; getimage(*x, *y, *x + 50, *y + 50, buffer2); drcar(*x, *y, 0); delay(16); putimage(*x, *y, buffer2, COPY_PUT); &#125;&#125; pssj.h12345#ifndef _PSSJ_H#define _PSSJ_Hint moveint2(int (*hanshu)(int*, int*), int* a, int b[6]);int moveint3(int (*hanshu)(int*, int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49], int(*)[2], int*), int* a, int b[6], unsigned char c[384][49], unsigned char d[192][49], unsigned char e[192][49], int f[386][2], int* g);#endif pssj.c1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;pssj.h&quot;#include &quot;common.h&quot;int moveint2(int (*hanshu)(int*,int* ), int* a, int b[6])&#123; int bbbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbbb = hanshu(a, b); if (*a != -10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbbb;&#125;int moveint3(int (*hanshu)(int*, int*, unsigned char(*)[49], unsigned char(*)[49], unsigned char(*)[49], int(*)[2], int*), int* a, int b[6], unsigned char c[384][49], unsigned char d[192][49], unsigned char e[192][49],int f[386][2], int* g)&#123; int bbbbbb; if (*a == 1) &#123; clrmous(MouseX, MouseY); &#125; bbbbbb = hanshu(a, b, c, d, e,f,g); if (*a != -10) &#123; newmouse(&amp;MouseX, &amp;MouseY, &amp;press); &#125; return bbbbbb;&#125; pensadh.h12345678910111213141516#ifndef _PENSADH_H_#define _PENSADH_H_int psdonghua(int *a10,int nongyao[6], unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49], int rount[386][2],int* amtjudge);void ljgh(int grandjudge, int *judge, int ny0[384][2], int ny1[192][2], int ny2[192][2], int ny3[192][2], int ny4[192][2], int rount[386][2]);//路径规划void therount(int rount[386][2], int *amtjudge);//路径画面void huigui(void);//未发现病害，回归void huigui2(int i);//喷洒农药后回归void nyphoto(int x, int y);//农药图像void anima1(int rount[386][2], int* amtjudge);//大农田路径动画void anima2(int rount[386][2], int* amtjudge);//小农田路径动画int linemove1(int* x, int* y, int* buffer1);//大农田沿线段运动int linemove21(int judge1 ,int* x, int* y, int* buffer1);//小农田沿线段运动(顺时针) 21，22合并后，动画卡顿且容易把系统卡爆int linemove22(int judge1 ,int* x, int* y, int* buffer1);//小农田沿线段运动(逆时针)#endif pensadh.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737#include &quot;common.h&quot;int psdonghua(int* a10, int nongyao[6], unsigned char diannian[384][49], unsigned char dianbai[192][49], unsigned char dianmian[192][49], int rount[386][2],int* amtjudge)&#123; FILE* filePointer1; FILE* filePointer2; FILE* filePointer3; FILE* filePointer4; FILE* filePointer5; FILE* filePointer6; int i,j; int grandjudge = 0, jg0=0, jg1 = 0, jg2 = 0, jg3 = 0, jg4 = 0;//granjudge:确定农药使用，jg用于贮存相应得病植株数量 int ny0[384][2] = &#123;0&#125;;//ny用于贮存坐标 int ny1[192][2] = &#123; 0 &#125;; int ny2[192][2] = &#123; 0 &#125;; int ny3[192][2] = &#123; 0 &#125;; int ny4[192][2] = &#123; 0 &#125;; if (*a10==1) &#123; rount[0][0] = 20; rount[0][1] = 465; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); setfillstyle(1, GREEN); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40); bar(260, 5, 400, 50); puthz(270, 10, &quot;喷洒农药&quot;, 32, 30, WHITE); bar(100, 5, 240, 50); puthz(110, 10, &quot;路径规划&quot;, 32, 30, WHITE); rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); if (nongyao[5] == 0)//大农田，已经排除了棉花用的农药，关注0，2，4 &#123; farmfield(); for (i = 0; i &lt; 192; i++)//小麦，黏虫 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1], diannian[i]); ny0[jg0][0] = nian.bfzuobiao[i][0]; ny0[jg0][1] = nian.bfzuobiao[i][1]; jg0++; &#125; &#125; for (i = 192; i &lt; 384; i++)//玉米，黏虫 &#123; if (nian.bfzuobiao[i][0] != 0 &amp;&amp; nian.bfzuobiao[i][1] != 0) &#123; nianchong(nian.bfzuobiao[i][0], nian.bfzuobiao[i][1], diannian[i]); ny2[jg2][0] = nian.bfzuobiao[i][0]; ny2[jg2][1] = nian.bfzuobiao[i][1]; jg2++; &#125; &#125; for (i = 0; i &lt; 192; i++)//玉米，棉铃虫 &#123; if (mian.bfzuobiao[i][0] != 0 &amp;&amp; mian.bfzuobiao[i][1] != 0) &#123; mianling(mian.bfzuobiao[i][0], mian.bfzuobiao[i][1], dianmian[i]); ny0[jg0][0] = mian.bfzuobiao[i][0]; ny0[jg0][1] = mian.bfzuobiao[i][1]; jg0++; &#125; &#125; for (i = 0; i &lt; 192; i++)//小麦，白粉病 &#123; if (bai.bfzuobiao[i][0] != 0 &amp;&amp; bai.bfzuobiao[i][1] != 0) &#123; baifen(bai.bfzuobiao[i][0], bai.bfzuobiao[i][1], dianbai[i]); ny4[jg4][0] = bai.bfzuobiao[i][0]; ny4[jg4][1] = bai.bfzuobiao[i][1]; jg4++; &#125; &#125; &#125; else if (nongyao[5] == 1)//小农田 &#123; bmp_convert(&quot;5.bmp&quot;, &quot;5.dbm&quot;); open_display(); show_dbm(0, 100, &quot;5.dbm&quot;, 0); tian(); bmp_convert(&quot;stone.bmp&quot;, &quot;stone.dbm&quot;); open_display(); drawPlants(); drawdxg(250, 240); show_dbm(194, 447, &quot;stone.dbm&quot;, 0); drawScarecrow(570, 61); drawScarecrow(500, 325); binghai(); filePointer1 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer1, &quot;%d %d&quot;, &amp;ny0[jg0][0], &amp;ny0[jg0][1]) != -1) jg0++; else break; &#125; fclose(filePointer1); filePointer2 = fopen(&quot;data//xtymmian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer2, &quot;%d %d&quot;, &amp;ny0[jg0][0], &amp;ny0[jg0][1]) != -1) jg0++; else break; &#125; fclose(filePointer2); filePointer3 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer3, &quot;%d %d&quot;, &amp;ny1[jg1][0], &amp;ny1[jg1][1]) != -1) jg1++; else break; &#125; fclose(filePointer3); filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer4, &quot;%d %d&quot;, &amp;ny2[jg2][0], &amp;ny2[jg2][1]) != -1) jg2++; else break; &#125; fclose(filePointer4); filePointer5 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer5, &quot;%d %d&quot;, &amp;ny3[jg3][0], &amp;ny3[jg3][1]) != -1) jg3++; else break; &#125; fclose(filePointer5); filePointer6 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;r&quot;); for (i = 0; i &lt; 192; i++) &#123; if (fscanf(filePointer6, &quot;%d %d&quot;, &amp;ny4[jg4][0], &amp;ny4[jg4][1]) != -1) jg4++; else break; &#125; fclose(filePointer6); &#125; if (nongyao[0] == 2) &#123; if (jg0 == 0) &#123; nongyao[0] = 0; huigui(); return 7; &#125; if (jg0 &gt; 0) &#123; grandjudge = 0; *amtjudge = jg0; &#125; &#125; if (nongyao[1] == 2) &#123; if (jg1 == 0) &#123; nongyao[1] = 0; huigui(); return 7; &#125; if (jg1 &gt; 0) &#123; grandjudge = 1; *amtjudge = jg1; &#125; &#125; if (nongyao[2] == 2) &#123; if (jg2 == 0) &#123; nongyao[2] = 0; huigui(); return 7; &#125; if (jg2 &gt; 0) &#123; grandjudge = 2; *amtjudge = jg2; &#125; &#125; if (nongyao[3] == 2) &#123; if (jg3 == 0) &#123; nongyao[3] = 0; huigui(); return 7; &#125; if (jg3 &gt; 0) &#123; grandjudge = 3; *amtjudge = jg3; &#125; &#125; if (nongyao[4] == 2) &#123; if (jg4 == 0) &#123; nongyao[4] = 0; huigui(); return 7; &#125; if (jg4 &gt; 0) &#123; grandjudge = 4; *amtjudge = jg4; &#125; &#125; ljgh(grandjudge, amtjudge, ny0, ny1, ny2, ny3, ny4, rount); *a10 = 0; &#125; if (*a10 == 2) &#123; therount(rount, amtjudge); *a10 = 3; &#125; if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a10 = 1; for (i = 0; i &lt; 5; i++) &#123; if (nongyao[i] &gt; 1) &#123; nongyao[i] = 0; &#125; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); return 8;//返回农药选择界面 &#125; if (*a10 == 0) &#123; if (mouse_press(100, 5, 240, 50) == 1) &#123; *a10 = 2; &#125; showbiankuang(100, 5, 240, 50); &#125; if (*a10 == 3) &#123; if (mouse_press(260, 5, 400, 50) == 1) &#123; if (nongyao[5] == 0) &#123; clrmous(MouseX, MouseY); anima1(rount, amtjudge); *a10 = 4; &#125; else if (nongyao[5] == 1) &#123; clrmous(MouseX, MouseY); anima2(rount, amtjudge); *a10 = 5; &#125; &#125; showbiankuang(260, 5, 400, 50); &#125; if (*a10 == 4) &#123; for (i = 0; i &lt; 5; i++) if (nongyao[i] == 2) break; if (i == 0) for (j = 0; j &lt; 192; j++) &#123; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][1] = 0; mian.bfzuobiao[j][0] = 0; mian.bfzuobiao[j][1] = 0; &#125; if (i == 2) &#123; for (j =192; j &lt; 384; j++) &#123; nian.bfzuobiao[j][0] = 0; nian.bfzuobiao[j][1] = 0; &#125; &#125; if (i == 4) &#123; for (j = 0; j &lt; 192; j++) &#123; bai.bfzuobiao[j][0] = 0; bai.bfzuobiao[j][1] = 0; &#125; &#125; nongyao[i] = 0; *a10 = 1; huigui2(i); return 2; &#125; if(*a10==5) &#123; for (i = 0; i &lt; 5; i++) if (nongyao[i] == 2) break; if (i == 0) &#123; filePointer1 = fopen(&quot;data//xtxmnian.dat&quot;, &quot;w&quot;); fclose(filePointer1); filePointer1 = fopen(&quot;data//xmncdian.dat&quot;, &quot;w&quot;); fclose(filePointer1); filePointer2 = fopen(&quot;data//xtymmian.dat&quot;, &quot;w&quot;); fclose(filePointer2); filePointer2 = fopen(&quot;data//ymmldian.dat&quot;, &quot;w&quot;); fclose(filePointer2); &#125; if (i == 1) &#123; filePointer3 = fopen(&quot;data//xtmhmian.dat&quot;, &quot;w&quot;); fclose(filePointer3); filePointer3 = fopen(&quot;data//mhmldian.dat&quot;, &quot;w&quot;); fclose(filePointer3); &#125; if (i == 2) &#123; filePointer4 = fopen(&quot;data//xtymnian.dat&quot;, &quot;w&quot;); fclose(filePointer4); filePointer4 = fopen(&quot;data//ymncdian.dat&quot;, &quot;w&quot;); fclose(filePointer4); &#125; if (i == 3) &#123; filePointer5 = fopen(&quot;data//xtmhxiu.dat&quot;, &quot;w&quot;); fclose(filePointer5); filePointer5 = fopen(&quot;data//mhxbdian.dat&quot;, &quot;w&quot;); fclose(filePointer5); &#125; if (i == 4) &#123; filePointer6 = fopen(&quot;data//xtxmbai.dat&quot;, &quot;w&quot;); fclose(filePointer6); filePointer6 = fopen(&quot;data//xmbfdian.dat&quot;, &quot;w&quot;); fclose(filePointer6); &#125; nongyao[i] = 0; *a10 = 1; huigui2(i); return 3; &#125; return 9;&#125;void ljgh(int grandjudge, int *judge, int ny0[384][2], int ny1[192][2], int ny2[192][2], int ny3[192][2], int ny4[192][2],int rount[386][2])//路径规划&#123; int i = 0, j = 0, k = *judge-1,K = 1 + *judge; int len1 = 0, len2 = 0; int dist1 = 0, dist2 = 0; int temp0 = 0, temp1 = 0; if (grandjudge == 0) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny0[i][0]; rount[j][1] = ny0[i][1]; &#125; &#125; if (grandjudge == 1) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny1[i][0]; rount[j][1] = ny1[i][1]; &#125; &#125; if (grandjudge == 2) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny2[i][0]; rount[j][1] = ny2[i][1]; &#125; &#125; if (grandjudge == 3) &#123; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny3[i][0]; rount[j][1] = ny3[i][1]; &#125; &#125; if (grandjudge == 4) &#123; j = 1; for (i = 0; i &lt; *judge; i++) &#123; j = i + 1; rount[j][0] = ny4[i][0]; rount[j][1] = ny4[i][1]; &#125; &#125; rount[K][0] = rount[0][0]; rount[K][1] = rount[0][1]; for (i = 0; i &lt; k; i++) &#123; len1 = rount[i + 1][0] - rount[i][0]; len2 = rount[i + 1][1] - rount[i][1]; len1 = len1 / 25; len2 = len2 / 25; dist1 = len1 * len1 + len2 * len2; for (j = i + 2; j &lt; K; j++) &#123; len1 = rount[j][0] - rount[i][0]; len2 = rount[j][1] - rount[i][1]; len1 = len1 / 25; len2 = len2 / 25; dist2 = len1 * len1 + len2 * len2; if (dist2 &lt; dist1) &#123; dist1 = dist2; temp0 = rount[j][0]; temp1 = rount[j][1]; rount[j][0] = rount[i + 1][0]; rount[j][1] = rount[i + 1][1]; rount[i+1][0] = temp0; rount[i+1][1] = temp1; &#125; &#125; &#125;&#125;void therount(int rount[386][2], int * amtjudge)//路径画面&#123; int i = 0; for (i=0;i&lt;* amtjudge+1;i++) &#123; setcolor(RED); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); &#125; line(rount[*amtjudge][0], rount[*amtjudge][1], rount[0][0], rount[0][1]);&#125;void huigui(void)//回归&#123; cleardevice(); clrmous(MouseX, MouseY); puthz(150, 200, &quot;未发现相关病状&quot;, 32, 40, RED); setcolor(BLUE); rectangle(110, 300, 530, 380); puthz(125, 322, &quot;回归中&quot;, 32, 50, RED); setfillstyle(1, BLUE); bar(265, 320, 305, 360); delay(400); bar(315, 320, 355, 360); delay(400); bar(365, 320, 405, 360); delay(400); bar(415, 320, 455, 360); delay(400); bar(465, 320, 505, 360); delay(1000);&#125;void huigui2(int i)//喷洒农药后回归&#123; cleardevice(); clrmous(MouseX, MouseY); puthz(100, 150, &quot;已清除下列植物的下列病状&quot;, 32, 40, BLUE); if (i == 0) &#123; puthz(100, 250, &quot;小麦黏虫&quot;, 32, 40, RED); puthz(300, 250, &quot;玉米棉铃虫&quot;, 32, 40, RED); &#125; if (i == 1) puthz(100, 250, &quot;棉花棉铃虫&quot;, 32, 40, RED); if (i == 2) puthz(100, 250, &quot;玉米黏虫&quot;, 32, 40, RED); if (i == 3) puthz(100, 250, &quot;棉花锈病&quot;, 32, 40, RED); if (i == 4) puthz(100, 250, &quot;小麦白粉病&quot;, 32, 40, RED); setcolor(BLUE); rectangle(90, 350, 550, 430); puthz(100, 372, &quot;回归农田&quot;, 32, 50, RED); setfillstyle(1, BLUE); bar(285, 370, 325, 410); delay(400); bar(335, 370, 375, 410); delay(400); bar(385, 370, 425, 410); delay(400); bar(435, 370, 475, 410); delay(400); bar(485, 370, 525, 410); delay(1000);&#125;void nyphoto(int x, int y)//农药图像&#123; setfillstyle(1, LIGHTBLUE); bar(x, y+2, x + 3, y + 5); bar(x + 10, y + 7, x + 13, y + 10); bar(x + 20, y+3, x + 23, y + 6); bar(x, y + 10, x + 3, y + 13); bar(x + 20, y + 5, x + 23, y + 8); bar(x + 20, y+15, x + 23, y + 18); bar(x, y + 19, x + 3, y + 22); bar(x + 12, y + 22, x + 15, y + 25);&#125;void anima1(int rount[386][2], int* amtjudge)//大农田路径动画&#123; void* buffer1 = malloc(imagesize(0, 0, 22, 26)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i,k; *x1 = rount[0][0]; *y1 = rount[0][1]; for (i = 0; i &lt; *amtjudge+1; i++) &#123; setcolor(CYAN); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); do &#123; k = linemove1(x1, y1, buffer1); &#125; while (k == 1); getimage(*x1 - 6, *y1 - 8, *x1 + 16, *y1 + 18, buffer1); suofangtu(*x1, *y1, 1); delay(100); putimage(*x1 - 6, *y1 - 8, buffer1, COPY_PUT); if (i &lt; *amtjudge) nyphoto(rount[i + 1][0], rount[i + 1][1]); &#125; getimage(*x1 - 6, *y1 - 8, *x1 + 16, *y1 + 18, buffer1); suofangtu(*x1, *y1, 1); delay(500); putimage(*x1 - 6, *y1 - 8, buffer1, COPY_PUT); free(buffer1); free(x1); free(y1);&#125;void anima2(int rount[386][2], int* amtjudge)//小农田路径动画&#123; void* buffer1 = malloc(imagesize(0, 0, 20, 10)); int* x1 = malloc(sizeof(int)); int* y1 = malloc(sizeof(int)); int i, k ; for (i = 0; i &lt; *amtjudge + 1; i++) &#123; *x1 = rount[i][0]; *y1 = rount[i][1]; setcolor(CYAN); rectangle(185, 443, 233, 480); rectangle(184, 444, 234, 479); rectangle(245, 225, 287, 323); rectangle(244, 226, 288, 322); rectangle(553, 43, 582, 136); rectangle(552, 44, 583, 135); rectangle(483, 307, 512, 400); rectangle(482, 308, 513, 399); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); setcolor(BLUE); rectangle(185, 444, 233, 479); rectangle(245, 226, 287, 322); rectangle(553, 44, 582, 135); rectangle(483, 308, 512, 399); if (rount[i][0] &lt; rount[i + 1][0]&amp;&amp; rount[i][1] &gt;= rount[i + 1][1])//第一象限 &#123; do &#123; k = linemove21(6,x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &gt;= rount[i + 1][0] &amp;&amp; rount[i][1] &gt; rount[i + 1][1])//第二象限 &#123; do &#123; k = linemove22(6, x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &gt; rount[i + 1][0] &amp;&amp; rount[i][1] &lt;= rount[i + 1][1])//第三象限 &#123; do &#123; k = linemove22(0, x1, y1, buffer1); &#125; while (k == 1); &#125; else if (rount[i][0] &lt;= rount[i + 1][0] &amp;&amp; rount[i][1] &lt; rount[i + 1][1])//第三象限 &#123; do &#123; k = linemove21(0, x1, y1, buffer1); &#125; while (k == 1); &#125; getimage(*x1, *y1, *x1 + 20, *y1 + 10, buffer1); fushitu(*x1, *y1); delay(100); putimage(*x1 , *y1 , buffer1, COPY_PUT); setcolor(RED); line(rount[i][0], rount[i][1], rount[i + 1][0], rount[i + 1][1]); if (i &lt; *amtjudge) nyphoto(rount[i + 1][0], rount[i + 1][1]); &#125; getimage(*x1, *y1, *x1 + 20, *y1 +10, buffer1); fushitu(*x1, *y1); delay(500); putimage(*x1 , *y1, buffer1, COPY_PUT); free(buffer1); free(x1); free(y1);&#125;int linemove1( int* x, int* y, int* buffer1)//大农田沿线段运动&#123; int a[10][2] = &#123; &#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = 1; i &lt; 9; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x-6, *y-8, *x + 16, *y + 18, buffer1); suofangtu(*x, *y,1); delay(8); putimage(*x-6, *y-8, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i-1][0], *y + a[i-1][1], RED); putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x , *y , RED); *x = *x + x0; *y = *y + y0; putpixel(*x,*y, RED); &#125; return judge;&#125;int linemove21(int judge1, int* x, int* y, int* buffer1)//小农田沿线段运动(顺时针)&#123; int a[17][2] = &#123; &#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;, &#123;-1,-1&#125;,&#123;0,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = judge1; i &lt; judge1+8; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x, *y, *x + 20, *y + 10, buffer1); fushitu(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x , *y , RED); *x = *x + x0; *y = *y + y0; putpixel(*x,*y, RED); &#125; return judge;&#125;int linemove22(int judge1, int* x, int* y, int* buffer1)//小农田沿线段运动(逆时针)&#123; int a[17][2] = &#123; &#123;0,-1&#125;, &#123;-1,-1&#125;, &#123;-1,0&#125;, &#123;-1,1&#125;, &#123;0,1&#125; , &#123;1,1&#125;, &#123;1,0&#125;, &#123;1,-1&#125;, &#123;0,-1&#125;, &#123;-1,-1&#125;, &#123;-1,0&#125;, &#123;-1,1&#125;, &#123;0,1&#125; , &#123;1,1&#125;, &#123;1,0&#125;, &#123;1,-1&#125;,&#123;0,-1&#125; &#125;; int b, judge = 0; int i; int x0 = 0, y0 = 0; for (i = judge1; i &lt; judge1+8; i++) &#123; b = getpixel(a[i][0] + *x, a[i][1] + *y); if (b == CYAN) &#123; x0 = a[i][0]; y0 = a[i][1]; judge = 1; break; &#125; &#125; getimage(*x, *y, *x + 20, *y + 10, buffer1); fushitu(*x, *y); delay(8); putimage(*x, *y, buffer1, COPY_PUT); if (judge == 1) &#123; putpixel(*x + a[i][0], *y + a[i][1], RED); putpixel(*x + a[i+1][0], *y + a[i+1][1], RED); putpixel(*x, *y, RED); *x = *x + x0; *y = *y + y0; putpixel(*x, *y, RED); &#125; return judge;&#125; pensa.h12345678910#ifndef _PENSA_H_#define _PENSA_H_int zhuzhan(int* a8,int nongyao[6]);void peizhi(void);void drhook(int x, int y);void cross(int x, int y);void drline(int x, int y);#endif pensa.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278 #include &quot;common.h&quot;int zhuzhan(int* a8,int nongyao[6])&#123; int i; if (*a8 == 1) &#123; peizhi(); *a8 = 0; &#125; showbiankuang(600, 0, 640, 40); showbiankuang(0, 0, 80, 40); showbiankuang(370, 0, 580, 60); if (mouse_press(600, 0, 640, 40) == 1) &#123; return -1;//关闭BC。 &#125; else if (mouse_press(0, 0, 80, 40) == 1) &#123; *a8 = 1; if (nongyao[5] == 0) return 2; else if (nongyao[5] == 1) return 3; &#125; if (nongyao[0] == 0) &#123; if (mouse_press(300, 145, 440, 225) == 1 || mouse_press(160, 225, 300, 305) == 1)//氟铃脲 &#123; *a8 = 1; nongyao[0] = 1; &#125; &#125; if (nongyao[2] == 0) &#123; if (mouse_press(300, 225, 440, 305) == 1)//氯氰菊酯 &#123; *a8 = 1; nongyao[2] = 1; &#125; &#125; if (nongyao[4] == 0) &#123; if (mouse_press(160, 305, 300, 385) == 1)//菌酯 &#123; *a8 = 1; nongyao[4] = 1; &#125; &#125; if (nongyao[5] == 1) &#123; if (nongyao[1] == 0) &#123; if (mouse_press(440, 145, 580, 225) == 1)//甲胺磷 &#123; *a8 = 1; nongyao[1] = 1; &#125; &#125; if (nongyao[3] == 0) &#123; if (mouse_press(440, 385, 580, 465) == 1)//甲维盐 &#123; *a8 = 1; nongyao[3] = 1; &#125; &#125; &#125; if (nongyao[0] == 1) &#123; if (mouse_press(410, 145, 440, 175) == 1 || mouse_press(270, 225, 300, 255) == 1)//氟铃脲 &#123; *a8 = 1; nongyao[0] = 0; delay(400); &#125; &#125; if (nongyao[2] == 1) &#123; if (mouse_press(410, 225, 440, 255) == 1)//氯氰菊酯 &#123; *a8 = 1; nongyao[2] = 0; delay(400); &#125; &#125; if (nongyao[4] == 1) &#123; if (mouse_press(270, 305, 300, 335) == 1)//菌酯 &#123; *a8 = 1; nongyao[4] = 0; delay(400); &#125; &#125; if (nongyao[5] == 1) &#123; if (nongyao[1] == 1) &#123; if (mouse_press(550, 145, 580, 175) == 1)//甲胺磷 &#123; *a8 = 1; nongyao[1] = 0; delay(400); &#125; &#125; if (nongyao[3] == 1) &#123; if (mouse_press(550, 385, 580, 415) == 1)//甲维盐 &#123; *a8 = 1; nongyao[3] = 0; delay(400); &#125; &#125; &#125; if (mouse_press(370, 0, 580, 60) == 1)//装配农药 &#123; *a8 = 1; return 8; &#125; return 7;&#125;void peizhi(void)//配置界面绘画&#123; int i; int x,y; cleardevice(); clrmous(MouseX, MouseY); setcolor(RED); rectangle(600, 0, 640, 40); line(600, 0, 640, 40); line(640, 0, 600, 40);//关闭按钮 rectangle(0, 0, 80, 40); puthz(5, 5, &quot;返回&quot;, 32, 40, GREEN); setfillstyle(1, BLUE); bar(20, 65, 580, 465); bar(370, 0, 580, 60); puthz(390, 10, &quot;装配农药&quot;, 32, 40, WHITE); puthz(100, 10, &quot;选择配置农药&quot;, 32, 40, BLUE); setcolor(LIGHTGRAY); rectangle(370, 0, 580, 60); line(20, 65, 160, 145); for (i = 0; i &lt; 6; i++) &#123; x = 20 + 140 * i; line(x, 65, x, 465); line(x+1, 65, x+1, 465); y = 65 + 80 * i; line(20, y, 580, y); line(20, y+1, 580, y+1); &#125; puthz(80, 70, &quot;植株种类&quot;, 16, 20, WHITE); puthz(30, 120, &quot;病害种类&quot;, 16, 20, WHITE); puthz(25, 170, &quot;棉铃虫&quot;, 24, 30, WHITE); puthz(25, 250, &quot;黏虫&quot;, 24, 30, WHITE); puthz(25, 330, &quot;白粉病&quot;, 24, 30, WHITE); puthz(25, 410, &quot;锈病&quot;, 24, 30, WHITE); puthz(165, 90, &quot;小麦&quot;, 24, 30, WHITE); puthz(165, 255, &quot;氟铃脲&quot;, 24, 30, WHITE); puthz(165, 335, &quot;菌酯&quot;, 24, 30, WHITE); puthz(305, 90, &quot;玉米&quot;, 24, 30, WHITE); puthz(305, 175, &quot;氟铃脲&quot;, 24, 30, WHITE); puthz(305, 255, &quot;氯氰菊酯&quot;, 24, 30, WHITE); puthz(445, 90, &quot;棉花&quot;, 24, 30, WHITE); puthz(445, 175, &quot;甲胺磷&quot;, 24, 30, WHITE); puthz(445, 415, &quot;甲维盐&quot;, 24, 30, WHITE); drline(160, 145); drline(160, 385); drline(300, 305); drline(300, 385); drline(440, 225); drline(440, 305); if (nongyao[0] == 1) &#123; setfillstyle(1, WHITE); bar(300, 145, 440, 225); bar(160, 225, 300, 305); puthz(165, 255, &quot;氟铃脲&quot;, 24, 30, BLUE); puthz(305, 175, &quot;氟铃脲&quot;, 24, 30, BLUE); drhook(300, 145); drhook(160, 225); setfillstyle(1, RED); bar(410, 145, 440, 175); bar(270, 225, 300, 255); cross(410, 145); cross(270, 225); rectangle(300, 145, 440, 225); rectangle(160, 225, 300, 305); &#125; if (nongyao[1] == 1) &#123; setfillstyle(1, WHITE); bar(440, 145, 580, 225); puthz(445, 175, &quot;甲胺磷&quot;, 24, 30, BLUE); drhook(440, 145); setfillstyle(1, RED); bar(550, 145, 580, 175); cross(550, 145); rectangle(440, 145, 580, 225); &#125; if (nongyao[2] == 1) &#123; setfillstyle(1, WHITE); bar(300, 225, 440, 305); puthz(305, 255, &quot;氯氰菊酯&quot;, 24, 30, BLUE); drhook(300, 225); setfillstyle(1, RED); bar(410, 225, 440, 255); cross(410, 225); rectangle(300, 225, 440, 305); &#125; if (nongyao[3] == 1) &#123; setfillstyle(1, WHITE); bar(440, 385, 580, 465); puthz(445, 415, &quot;甲维盐&quot;, 24, 30, BLUE); drhook(440, 385); setfillstyle(1, RED); bar(550, 385, 580, 415); cross(550, 385); rectangle(440, 385, 580, 465); &#125; if (nongyao[4] == 1) &#123; setfillstyle(1, WHITE); bar(160, 305, 300, 385); puthz(165, 335, &quot;菌酯&quot;, 24, 30, BLUE); drhook(160, 305); setfillstyle(1, RED); bar(270, 305, 300, 335); cross(270, 305); rectangle(160, 305, 300, 385); &#125; if (nongyao[5] == 0) &#123; setfillstyle(1, BLUE); bar(442, 147, 578, 223); bar(442, 387, 578, 463); drline(440, 145); drline(440, 385); &#125;&#125;void drhook(int x, int y)&#123; setcolor(RED); line(x + 110, y + 70, x + 125, y + 80); line(x + 111, y + 70, x + 126, y + 80); line(x + 124, y + 80, x + 139, y + 50); line(x + 125, y + 80, x + 140, y + 50);&#125;void cross(int x, int y)&#123; setcolor(WHITE); line(x, y, x + 30, y + 30); line(x, y + 1, x + 29, y + 30); line(x + 1, y, x + 30, y + 29); line(x, y + 30, x + 30, y); line(x, y + 29, x + 29, y); line(x + 1, y + 30, x + 30, y + 1);&#125;void drline(int x, int y)&#123; setcolor(LIGHTGRAY); line(x, y, x + 140, y + 80); line(x+1, y, x + 141, y + 80);&#125; 借用祖传hz.h123456#ifndef __HZ_H__#define __HZ_H__void puthz(int x, int y,char *s,int flag,int part,int color);#endif hz.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&quot;hz.h&quot;void puthz(int x, int y,char *s,int flag,int part,int color)&#123; FILE *hzk_p=NULL; //定义汉字库文件指针 unsigned char quma,weima; //定义汉字的区码和位码 unsigned long offset; //定义汉字在字库中的偏移量 unsigned char mask[] = &#123;0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01&#125;; //功能数组，用于显示汉字点阵中的亮点 int i,j,pos; switch(flag) //不同的flag对应不同的汉字库，实现了汉字的大小可根据需要改变 &#123; case 16 : &#123; char mat[32]; //16*16的汉字需要32个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\HZ16&quot;,&quot;rb&quot;); //使用相对路径 if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,1); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk16 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*32L; //求出要显示的汉字在字库文件中的偏移 fseek(hzk_p,offset,SEEK_SET); //重定位文件指针 fread (mat,32,1,hzk_p); //读出该汉字的具体点阵数据,1为要读入的项数 for(i=0;i&lt;16;i++) &#123; pos=2*i; //16*16矩阵中有每一行有两外字节 for(j=0;j&lt;16;j++) //一行一行地扫描，将位上为了1的点显示出来 &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) //j%8只能在0—8之间循环，j/8在0，1之间循环 &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; /*==================================================== 以上是一个汉字显示完 ====================================================*/ x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后,重新从左侧开始输出汉字，给y一个偏移量 &#125; break; &#125; case 24 : &#123; char mat[72]; //24*24矩阵要72个字节来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\Hzk24k&quot;,&quot;rb&quot;); if (hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk24 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while(x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*72L; fseek(hzk_p,offset,SEEK_SET); fread (mat,72,1,hzk_p); for (i=0;i&lt;24;i++) &#123; pos=3*i; //矩阵中每一行有三个字节 for (j=0;j&lt;24;j++) // 每一行有24位 &#123; if ((mask[j%8]&amp;mat[pos+j/8])!=NULL) putpixel(x+j,y,color); &#125; y++; &#125; x+=part; s+=2; &#125; x=x0;y0+=flag+10; &#125; break; &#125; case 32 : &#123; char mat[128]; //32*32的汉字需要128个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\HZK32S&quot;,&quot;rb&quot;); if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk32 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*128L; fseek(hzk_p,offset,SEEK_SET); fread (mat,128,1,hzk_p); for(i=0;i&lt;32;i++) &#123; pos=4*i; //32*32矩阵中有每一行有两外字节 for(j=0;j&lt;32;j++) &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; //以上是一个汉字显示完 x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后，给y一个偏移量 &#125; break; &#125; case 48: &#123; char mat[288]; //48*48的汉字需要288个字节的数组来存储 int y0=y; int x0=x; hzk_p = fopen(&quot;HZK\\Hzk48k&quot;,&quot;rb&quot;); if(hzk_p==NULL) &#123; settextjustify(LEFT_TEXT,TOP_TEXT); //左部对齐，顶部对齐 settextstyle(GOTHIC_FONT,HORIZ_DIR,3); //黑体笔划输出，水平输出，24*24点阵 outtextxy(10,10,&quot;Can&#x27;t open hzk48 file!Press any key to quit...&quot;); getch(); exit(1); &#125; while(*s!=NULL) &#123; while (x&lt;640-flag &amp;&amp; (*s!=NULL)) &#123; y=y0; quma=s[0]-0xa0; //求出区码 weima=s[1]-0xa0; //求出位码 offset=(94*(quma-1)+(weima-1))*288L; //求出要显示的汉字在字库文件中的偏移 fseek(hzk_p,offset,SEEK_SET); //重定位文件指针 fread (mat,288,1,hzk_p); //读出该汉字的具体点阵数据,1为要读入的项数 for(i=0;i&lt;48;i++) &#123; pos=6*i; for(j=0;j&lt;48;j++) //一行一行地扫描，将位上为了1的点显示出来 &#123; if((mask[j%8]&amp;mat[pos+j/8])!=NULL) //j%8只能在0—8之间循环，j/8在0，1之间循环 &#123; putpixel(x+j,y,color); &#125; &#125; y++; &#125; //以上是一个汉字显示完 x+=part; //给x 一个偏移量part s+=2; //汉字里存放的是内码，2个字节，所以要加2 &#125; x=x0;y0+=flag+10; //一行汉字显示完后，给y一个偏移量 &#125; break; &#125; default: break; &#125; fclose(hzk_p);&#125; IMAGE.h1234567891011121314#ifndef IMAGE_H#define IMAGE_Hint bmp_convert(char *bmp,char *dbm); //将 *.bmp 变为 *.dbm,字符串bmp中为bmp所在地址，字dbmp为输出地址int show_dbm(int x,int y,char *dbm,int nowpage); //输入dbmp的路径,在(x,y)输出图片(x需为8的倍数)void cir_bar(int x1,int y1,int x2,int y2,int color); //在指定位置画出一个圆角矩形框 void movetopage(int x1, int y1, int x2, int y2,int page1);void set_color(int color_no,int red,int green,int blue); //指定颜色编号，修改其对应的rgb值 int quick_move_2(int Start, int End, int Size);int quick_move_1(int Start, int End, int Size);void close_display(void); //关闭屏幕显示void open_display(void); //打开屏幕显示 #endif IMAGE.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301/***********************该图像转换及输出函数，要求输入的图片分辨率在640*480之内***********************/#include &lt;stdio.h&gt;#include &lt;dos.h&gt;#include &quot;image.h&quot;#include &lt;graphics.h&gt;#include &lt;conio.h&gt;int bmp_convert(char *bmp,char *dbm) //将 *.bmp 变为 *.dbm,字符串bmp中为bmp所在地址，字dbmp为输出地址&#123;// static int color[16]=&#123;0,4,2,6,1,5,3,7,8,12,10,14,9,13,11,15&#125;; 上win下ps static int color[16]=&#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;//索引与bc内颜色序号对应转换（建议用win画图转化） unsigned char dbmline[640],bmpline[640],pixel[8],Vbyte; int ImageW,ImageH,i,j,k,n,now,bmpcom,gg ; long hangsize; FILE *fbmp,*fdbm; union &#123; unsigned char val; struct &#123; unsigned cl:4; unsigned ch:4; &#125;color; //用位域储存颜色信息，分拆颜色信息 &#125;MyColor; if((fbmp=fopen(bmp,&quot;rb&quot;))==NULL) &#123; printf(&quot;%s\n&quot;,bmp); printf(&quot;Open bmp error!&quot;); return 1; &#125; fseek(fbmp,18,SEEK_SET); //bmp图像的宽高在文件头18字节后 fread(&amp;gg,4,1,fbmp); // fread(&amp;ImageW,4,1,fbmp); fread(&amp;ImageH,4,1,fbmp); ImageW=gg; // ImageH*=2; // printf(&quot;%d &quot;,ImageW); // printf(&quot;%d&quot;,ImageH); if(ImageW==0||ImageH==0||ImageW&gt;641||ImageH&gt;481)/////注意注意！！根据实际修改/ &#123; printf(&quot;The image is too large!Please input image below 640*480.&quot;); fclose(fbmp); return 1; &#125; if((fdbm=fopen(dbm,&quot;wb&quot;))==NULL) &#123; printf(&quot;Creat \&quot;%s\&quot; error!&quot;,dbm); return 1; &#125; bmpcom=(ImageW-1)/8+1; //行处理单元数 hangsize=bmpcom*4; //每行字节数（DIB数据要求每行字节为4整数倍，已计算补零） fwrite(&amp;ImageW,sizeof(int),1,fdbm); fwrite(&amp;ImageH,sizeof(int),1,fdbm); fseek(fbmp,-hangsize,SEEK_END); for(i=0;i&lt;ImageH;i++) &#123; now=0; fread(bmpline,hangsize,1,fbmp); fseek(fbmp,-hangsize*2,SEEK_CUR); for(n=3;n&gt;=0;n--) //每行拆成四个位面的数据输出 // for(n=0;n&lt;=3;n++) &#123; for(j=0;j&lt;bmpcom;j++) &#123; Vbyte=0; for(k=0;k&lt;4;k++) &#123; MyColor.val=bmpline[j*4+k]; pixel[k*2]=color[MyColor.color.ch]; pixel[k*2+1]=color[MyColor.color.cl]; &#125; for(k=0;k&lt;8;k++) &#123; Vbyte+=(pixel[k]&gt;&gt;n&amp;1)&lt;&lt;(7-k); &#125; dbmline[now++]=Vbyte; &#125; &#125; fwrite(dbmline,hangsize,1,fdbm); &#125; fclose(fdbm); fclose(fbmp); return 0;&#125;int show_dbm(int x,int y,char *dbm,int nowpage) //输入dbmp的路径,在(x,y)输出图片(x需为8的倍数)&#123; int ImageW,ImageH,n,i,j; long hangsize; FILE * fdbm; char far * per; if(nowpage==0) per=(char far *)0xA0000000L; else per=(char far *)0xA8000000L; // _VideoBusy=YES; //hanenv系统内的显示寄存器保护变量 if((fdbm=fopen(dbm,&quot;rb&quot;))==NULL) &#123; // printf(&quot;%s&quot;,dbm); // getchar(); // printf(&quot;Open Error!&quot;); return 1; &#125; fread(&amp;ImageW,sizeof(int),1,fdbm); fread(&amp;ImageH,sizeof(int),1,fdbm); // printf(&quot;%d %d&quot;,ImageW,ImageH); hangsize=(ImageW-1)/8; per=per+x/8+y*80; if((ImageH+y)&gt;480) ImageH=480-y; //VGAMED 640*480 for(i=0;i&lt;ImageH;i++) &#123; for(n=8;n&gt;=1;n&gt;&gt;=1) //从第三位颜色平面写到第0 &#123; outportb(0x3c4,2); outportb(0x3c5,n); fread(per,hangsize,1,fdbm); fseek(fdbm,1,SEEK_CUR); &#125; // fseek(fdbm,hangsize*2,SEEK_CUR); per+=80; &#125; fclose(fdbm); // _VideoBusy=NO; outportb(0x3c5,0xf); return 0;&#125;void cir_bar(int x1,int y1,int x2,int y2,int color) //在指定位置画出一个圆角矩形框 &#123; int w=x2-x1,h=y2-y1; setcolor(color); setlinestyle(SOLID_LINE,0,THICK_WIDTH); ellipse(5+x1,10+y1,90,180,5,10); line(0+x1,10+y1,0+x1,10+h-20+y1); ellipse(5+x1,10+h-20+y1,180,270,5,10); line(5+x1,0+y1,5+w-10+x1,0+y1); ellipse(5+w-10+x1+1,10+y1,0,90,5,10); line(w+x1,10+y1,w+x1,y2-10); ellipse(w-5+x1+1,10+h-20+y1,270,360,5,10); line(5+x1,h+y1,5+w-10+x1,h+y1);&#125;void movetopage(int x1, int y1, int x2, int y2,int page1) //显示页间局部图像数据传输，输入左上角坐标及右上角坐标，从page1移动到page2&#123; int per1, per2; int hangsize = (x2 - x1) / 8; int high = y2 - y1 + 1; register int i, p1, p2; if (page1 == 0) &#123; per2 = 0xA0000000L; per1 = 0xA8000000L; &#125; else &#123; per1 = 0xA0000000L; per2 = 0xA8000000L; &#125; per1 = per1 + (x1) / 8 + (y1 ) * 80; per2 = per2 + (x1) / 8 + (y1 ) * 80; for (i = 0; i &lt;high; i++) //传输视频图像 &#123; for (p1 = 8, p2 = 3; p1 &gt;= 1; p1 &gt;&gt;= 1, p2--) //从第三位颜色平面写到第0 &#123; outportb(0x3c4, 2); //颜色位面写寄存器 outportb(0x3c5, p1); outportb(0x3ce, 4); //颜色位面读寄存器 outportb(0x3cf, p2); if (page1 == 0) &#123; quick_move_2(per2, per1, hangsize); &#125; else &#123; quick_move_1(per2, per1, hangsize); &#125; &#125; per1 += 80; per2 += 80; &#125; outportb(0x3cf,0); //恢复设置 outportb(0x3c5,0xf);&#125;void set_color(int color_no,int red,int green,int blue) //指定颜色编号，修改其对应的rgb值 &#123; if(color_no&lt;16) &#123; _AX=0x1007; //选择10H显示中断中的第7号功能 _BL=color_no; geninterrupt(0x10); color_no=_BH; &#125; else color_no = 0xff; //将屏幕边缘色指向调色板255 //修改调色板寄存器 _DH=red; _CH=green; _CL=blue; _BX=color_no; _AX=0x1010; geninterrupt(0x10); //处理屏幕边缘颜色 if(color_no==0xff) &#123; _BH=0xff; _AX=0x1001; geninterrupt(0x10); &#125; &#125;/*此为用汇编编写的支持跨段寻址的数据传输函数，来自《VGA页面图形数据移动技术在特殊显示效果中的应用》一文*/int quick_move_1(int Start,int End,int Size) //Start为原处首地址，End为目标位置首地址 (1 to 0)&#123; asm&#123; push es push ds push di push si push ax push cx push dx mov ax,0a800h mov ds,ax mov ax,Start mov si,ax mov ax,0a000h mov es,ax mov ax,End mov di,ax mov cx,Size rep movsb pop dx pop cx pop ax pop si pop di pop ds pop es &#125; return 0;&#125;int quick_move_2(int Start,int End,int Size) //Start为原处首地址，End为目标位置首地址 (0 to 1)&#123; asm&#123; push es push ds push di push si push ax push cx push dx mov ax,0a000h mov ds,ax mov ax,Start mov si,ax mov ax,0a800h mov es,ax mov ax,End mov di,ax mov cx,Size rep movsb pop dx pop cx pop ax pop si pop di pop ds pop es &#125; return 0;&#125;void close_display(void) //关闭屏幕显示&#123; _BL=0x32; _AH=0x12; _AL=0x01; geninterrupt(0x10);&#125;void open_display(void) //打开屏幕显示&#123; _BL=0x32; _AH=0x12; _AL=0x00; geninterrupt(0x10);&#125; mouse.h123456789101112131415161718#ifndef _mouse_h_#define _mouse_h_int mouse_press(int x1, int y1, int x2, int y2);//如果在框中点击，则返回1；在框中未点击，则返回2；不在框中则返回0void mouse(int,int);//设计鼠标void mouseinit(void);//初始化void mou_pos(int*,int*,int*);//更改鼠标位置void mread(int *,int *,int*);//改坐标不画void save_bk_mou(int x,int y);//存鼠标背景void clrmous(int x,int y);//清除鼠标void drawmous(int x,int y);//画鼠标void newmouse(int *nx,int *ny,int *nbuttons); //更新鼠标extern int MouseX;extern int MouseY;extern int MouseS;extern int press;extern union REGS regs;#endif mouse.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include&lt;conio.h&gt;#include&lt;graphics.h&gt;#include&lt;dos.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &quot;mouse.h&quot;/**************************MOUSE.cUPDATER: dengshuuminFUNCTION: mouse actionABSTRACT: A.mread B.newmouseVERSION: 3.0***************************/int MouseX;int MouseY;int MouseS;int press;//形状用 &amp;pressvoid *buffer;//union REGS regs;int flag=0;void mouseinit()//初始化&#123; int retcode; int xmin,xmax,ymin,ymax,x_max=625,y_max=480; int size; xmin=2; xmax=x_max-1; ymin=8; ymax=y_max-2; regs.x.ax=0; int86(51,&amp;regs,&amp;regs); retcode=regs.x.ax; if(retcode==0) &#123; printf(&quot;Mouse or Mouse Driver Obsent,Please Install!&quot;); delay(5000); &#125; else &#123; regs.x.ax=7; regs.x.cx=xmin; regs.x.dx=xmax; int86(51,&amp;regs,&amp;regs); regs.x.ax=8; regs.x.cx=ymin; regs.x.dx=ymax; int86(51,&amp;regs,&amp;regs); &#125; MouseS = 0; MouseX=320,MouseY=240; save_bk_mou(320,240); mouse(MouseX,MouseY); flag=1;&#125;/*****************************FUNCTION: mouseDESCRIPTION: 画不同形态的鼠标INPUT: x,yRETURN: 无******************************/void mouse(int x,int y)&#123; switch(MouseS) &#123; case 1: //手势鼠标 &#123; setcolor(WHITE); setlinestyle(0,0,1); line(x-1,y+9,x-1,y+8); line(x,y+7,x,y+11); line(x+1,y+6,x+1,y+13); line(x+2,y+8,x+2,y+14); line(x+3,y-1,x+3,y+15); arc(x+4,y-1,0,180,1); line(x+4,y-2,x+4,y+15); line(x+5,y-1,x+5,y+16); arc(x+6,y+3,0,180,1); line(x+6,y+2,x+6,y+16); line(x+7,y+3,x+7,y+17); arc(x+8,y+5,0,180,1); line(x+8,y+4,x+8,y+17); line(x+9,y+5,x+9,y+16); arc(x+10,y+7,0,180,1); line(x+10,y+6,x+10,y+16); line(x+11,y+7,x+11,y+13); setcolor(DARKGRAY); line(x-1,y+9,x-1,y+8); line(x-1,y+8,x+1,y+6); line(x+1,y+6,x+3,y+10); line(x+3,y+10,x+3,y-1); arc(x+4,y-1,0,180,1); line(x+5,y-1,x+5,y+5); arc(x+6,y+3,0,180,1); line(x+7,y+3,x+7,y+7); arc(x+8,y+5,0,180,1); line(x+9,y+5,x+9,y+9); arc(x+10,y+7,0,180,1); line(x+11,y+7,x+11,y+13); arc(x+7,y+13,-90,0,4); line(x+7,y+17,x+3,y+15); line(x+3,y+15,x+1,y+13); line(x+1,y+13,x-1,y+9); &#125; break; case 2: //光标 &#123; setcolor(DARKGRAY); setlinestyle(0,0,1); line(x+1,y-1,x+9,y-1); line(x+1,y+15,x+9,y+15); line(x+5,y-1,x+5,y+15); &#125; break; case 3: //十字 &#123; setcolor(WHITE); setlinestyle(0,0,1); line(x-1,y+7,x+11,y+7); line(x+5,y-1,x+5,y+15); &#125; break; default: //默认鼠标 &#123; setlinestyle(0,0,1); setcolor(WHITE); line(x,y,x,y+13); line(x+1,y+1,x+1,y+12); line(x+2,y+2,x+2,y+11); line(x+3,y+3,x+3,y+10); line(x+4,y+4,x+4,y+12); line(x+5,y+5,x+5,y+9); line(x+5,y+11,x+5,y+14); line(x+6,y+6,x+6,y+9); line(x+6,y+13,x+6,y+15); line(x+7,y+7,x+7,y+9); line(x+8,y+8,x+8,y+9); line(x+9,y+9,x+9,y+9); setcolor(DARKGRAY); line(x-1,y-1,x-1,y+14); line(x-1,y+14,x+3,y+11); line(x+3,y+11,x+3,y+12); line(x+3,y+12,x+4,y+13); line(x+4,y+13,x+4,y+14); line(x+4,y+14,x+7,y+17); line(x+7,y+17,x+7,y+13); line(x+7,y+13,x+6,y+12); line(x+6,y+12,x+6,y+11); line(x+6,y+11,x+5,y+10); line(x+5,y+10,x+11,y+10); line(x+11,y+10,x-1,y-2); &#125; break; &#125;&#125;void mou_pos(int *nx,int *ny,int*nbuttons)//更改鼠标位置&#123; int x0=*nx,y0=*ny; mread(nx,ny,nbuttons); clrmous(x0,y0); save_bk_mou(*nx,*ny); drawmous(*nx,*ny);&#125;void mread(int *nx,int *ny,int*nbuttons)//改坐标不画&#123; int x0=*nx,y0=*ny,buttons0=*nbuttons; int xnew,ynew,buttonsnew; do&#123; regs.x.ax=3; int86(51,&amp;regs,&amp;regs); buttonsnew=regs.x.bx; delay(10); regs.x.ax=3; int86(51,&amp;regs,&amp;regs); if(regs.x.bx==buttonsnew) *nbuttons=regs.x.bx; else *nbuttons=buttons0; xnew=regs.x.cx; ynew=regs.x.dx; &#125;while(xnew==x0&amp;&amp;ynew==y0&amp;&amp;*nbuttons==0); *nx=xnew; *ny=ynew;&#125;/***************************************FUNCTION: mreadDESCRIPTION: 获取新的寄存器信息INPUT: nx,ny,nbuttonsRETURN: 无****************************************///void mread(int *nx,int *ny,int *nbuttons) //&#123;// regs.x.ax=3;// int86(51,&amp;regs,&amp;regs);// *nx = regs.x.cx;// *ny = regs.x.dx;// *nbuttons = regs.x.bx;//&#125;/*******************************************FUNCTION: newmouseDESCRIPTION: 鼠标状态发生变化则更新鼠标INPUT: nx,ny,nbuttonsRETURN: 无********************************************/void newmouse(int *nx,int *ny,int *nbuttons)&#123; int xn,yn,buttonsn; int x0=*nx,y0=*ny,buttons0=*nbuttons; mread(&amp;xn,&amp;yn,&amp;buttonsn); *nx = xn; *ny = yn; *nbuttons = buttonsn; if(buttons0 == *nbuttons) *nbuttons = 0; //使得能连续按键 if(xn == x0 &amp;&amp; yn == y0 &amp;&amp; buttonsn == buttons0) return; //鼠标状态不变则直接返回S clrmous(x0,y0); //说明鼠标状态发生了改变 save_bk_mou(*nx,*ny); drawmous(*nx,*ny);&#125;void save_bk_mou(int nx,int ny)//存鼠标背景&#123; int size; size=imagesize(nx-1,ny-2,nx+11,ny+17); buffer=malloc(size); if(buffer!=NULL) getimage(nx-1,ny-2,nx+11,ny+17,buffer); else printf(&quot;Error&quot;);&#125;void clrmous(int nx,int ny)//清除鼠标&#123; if(flag==1) &#123; setwritemode(XOR_PUT); mouse(nx,ny); putimage(nx-1,ny-2,buffer,COPY_PUT); free(buffer); flag=0; setwritemode(COPY_PUT); &#125;&#125;void drawmous(int nx,int ny)&#123; if(flag==0) &#123; setwritemode(COPY_PUT); mouse(nx,ny); flag=1; &#125;&#125;//如果在框中点击，则返回1；在框中未点击，则返回2；不在框中则返回0int mouse_press(int x1, int y1, int x2, int y2)&#123; //在框中点击，则返回1 if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 1) &#123; return 1; &#125; //在框中未点击，则返回2 else if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 0) &#123; return 2; &#125; //在框中点击右键，则返回3 else if(MouseX &gt; x1 &amp;&amp;MouseX &lt; x2 &amp;&amp;MouseY &gt; y1 &amp;&amp;MouseY &lt; y2 &amp;&amp;press == 2) &#123; return 3; &#125; else &#123; return 0; &#125;&#125; 后续补充（完结撒花&emsp;整个程序的源代码。需要解压密码，可以找到我问到，或者自己蒙，下方评论留言留下联系方式亦可。什么？你问我为什么要解压密码，当然是因为知识产权了，毕竟不是我一个编写的，还是不能随意传播，而且用处不大，你只需要学习就可以了，而且❀可A院这个爆烂的C应该不久会淘汰吧？或许会换新的爆烂。 点击下载源代码 如果不出意外，这个系列更新应该是无了。如果以后有幸帮学妹学弟搞这玩意，又有了新的东西和新的羁绊，我或许会再加一点东西。现在已经不想更了，因为这一切都和我没关系了（doge），我写的时候可没有像我这么好的人专门花大量时间搞这个。。。顺带提一嘴，b站学长（原本叫：六个钢镚？什么的）发的视频莫名奇妙的被删掉了，所以未来很多人的C课设只能自己赶deadline喽，体验痛苦（比如我室友 愿世上再无C课设——7.29.2024 完结散花]]></content>
    
      <categories>
        <category>C课设拯救</category>
      </categories>
      <tags>
        <tag>C课设</tag>
      </tags>
  </entry>
</search>
